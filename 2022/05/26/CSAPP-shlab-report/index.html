<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"puitar.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":true,"preload":true},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="CSAPP-LAB4-SHELL-LAB-REPORT计科2002班 202001130329 杨铭 实验目的通过这个实验能够更加深刻理解进程控制和信号控制的相关概念。本次实验我们要写一个自己的类linux&#x2F;unix的shell程序，它能够支持工作的控制。 实验平台准备 Ubuntu-32 VMfare虚拟机 typora编写实验报告(经授课老师许可)  Hand Out 介绍首先解压实">
<meta property="og:type" content="article">
<meta property="og:title" content="CSAPP:shlab-report">
<meta property="og:url" content="https://puitar.github.io/2022/05/26/CSAPP-shlab-report/index.html">
<meta property="og:site_name" content="Puitar&#39;s Blog">
<meta property="og:description" content="CSAPP-LAB4-SHELL-LAB-REPORT计科2002班 202001130329 杨铭 实验目的通过这个实验能够更加深刻理解进程控制和信号控制的相关概念。本次实验我们要写一个自己的类linux&#x2F;unix的shell程序，它能够支持工作的控制。 实验平台准备 Ubuntu-32 VMfare虚拟机 typora编写实验报告(经授课老师许可)  Hand Out 介绍首先解压实">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://puitar.github.io/2022/05/26/CSAPP-shlab-report/image-20220525154122346.png">
<meta property="og:image" content="https://puitar.github.io/2022/05/26/CSAPP-shlab-report/image-20220526003548830.png">
<meta property="og:image" content="https://puitar.github.io/2022/05/26/CSAPP-shlab-report/image-20220526081536379.png">
<meta property="og:image" content="https://puitar.github.io/2022/05/26/CSAPP-shlab-report/image-20220526221432408.png">
<meta property="article:published_time" content="2022-05-26T15:31:03.000Z">
<meta property="article:modified_time" content="2022-05-28T03:17:13.956Z">
<meta property="article:author" content="Puitar">
<meta property="article:tag" content="CSAPP">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://puitar.github.io/2022/05/26/CSAPP-shlab-report/image-20220525154122346.png">

<link rel="canonical" href="https://puitar.github.io/2022/05/26/CSAPP-shlab-report/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>CSAPP:shlab-report | Puitar's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Puitar's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://puitar.github.io/2022/05/26/CSAPP-shlab-report/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Puitar">
      <meta itemprop="description" content="博客萌新时不时送来没什么软用的文章">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Puitar's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          CSAPP:shlab-report
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-05-26 23:31:03" itemprop="dateCreated datePublished" datetime="2022-05-26T23:31:03+08:00">2022-05-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-05-28 11:17:13" itemprop="dateModified" datetime="2022-05-28T11:17:13+08:00">2022-05-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/courses-learning/" itemprop="url" rel="index"><span itemprop="name">courses-learning</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="CSAPP-LAB4-SHELL-LAB-REPORT"><a href="#CSAPP-LAB4-SHELL-LAB-REPORT" class="headerlink" title="CSAPP-LAB4-SHELL-LAB-REPORT"></a>CSAPP-LAB4-SHELL-LAB-REPORT</h1><p>计科2002班</p>
<p>202001130329</p>
<p>杨铭</p>
<h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><p>通过这个实验能够更加深刻理解进程控制和信号控制的相关概念。本次实验我们要写一个自己的类linux&#x2F;unix的shell程序，它能够支持工作的控制。</p>
<h2 id="实验平台准备"><a href="#实验平台准备" class="headerlink" title="实验平台准备"></a>实验平台准备</h2><ul>
<li>Ubuntu-32 VMfare虚拟机</li>
<li>typora编写实验报告(经授课老师许可)</li>
</ul>
<h2 id="Hand-Out-介绍"><a href="#Hand-Out-介绍" class="headerlink" title="Hand Out 介绍"></a>Hand Out 介绍</h2><p>首先解压实验文件，然后做如下工作：</p>
<ul>
<li>使用命令<code>tar xvf shlab-handout.tar</code>解压文件</li>
<li>使用命令<code>make</code>来编译和链接测试程序</li>
<li>输入(你的队员)没有队员，把你的大名写在<code>tsh.c</code>程序的顶部注释中</li>
</ul>
<p>注意到你的<code>tsh.c</code>(<em>tiny shell</em>)文件，你会看到它包含了一个简单Unix的shell的函数框架。为了简化实验，实际上题目已经帮我们实现了一些没那么有趣的函数。我们的任务就是完成剩下的空的函数。</p>
<p><strong>需要实现</strong></p>
<table>
<thead>
<tr>
<th>目标函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>eval</td>
<td>主例程，用以分析和解释命令行（原型在课本8.4节）</td>
</tr>
<tr>
<td>builtin_cmd</td>
<td>执行bg和fg内置命令</td>
</tr>
<tr>
<td>waitfg</td>
<td>等待前台作业执行</td>
</tr>
<tr>
<td>sigchld_handler</td>
<td>响应处理SIGCHILD信号</td>
</tr>
<tr>
<td>sigint_handler</td>
<td>响应处理SIGINT（ctrl-c）信号</td>
</tr>
<tr>
<td>sigtstp_handler</td>
<td>响应处理SIGTP（ctrl-z）信号</td>
</tr>
</tbody></table>
<p>每一次修改<code>tsh.c</code>，都需要输入<code>make</code>来重编译它。运行你的<em>shell</em>，在命令行输入<code>tsh</code>如下</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unix&gt; ./tsh</span><br><span class="line">tsh&gt; [<span class="built_in">type</span> commands to your shell here]</span><br></pre></td></tr></table></figure>



<h2 id="普通的Unix-Shells概述"><a href="#普通的Unix-Shells概述" class="headerlink" title="普通的Unix Shells概述"></a>普通的Unix Shells概述</h2><p>一个<em>shell</em>是一个对于用户层面的交互程序，它能够对用户输入的命令行进行解析。一个<em>shell</em>通常会重复输出一个标识符（通常是’prompt‘），然后等待一个命令行输入或者<code>stdin</code>标准输入。一旦它取得了命令行之后就会用它的内容进行一系列的解析工作。</p>
<p>命令行是一个有序的ASCII字符序列，它们使用空格相隔。命令行的第一个单词通常是一个<em>shell</em>的内部命令或者一个可执行文件的路径名称。剩下的单词是命令行的参数。如果第一个单词是一个命令行的内部命令，<em>shell</em>会立即在当前进程（也就是<em>shell</em>）立即执行。否则的话，它是一个可执行文件的路径。在这个情况之下<em>shell</em>通过<code>fork</code>一个子进程，然后在子进程的上下文中加载并运行程序。由于解析一个命令行而创建的子进程又被称作是<code>job</code>（作业）。总的来说，一个job是由若干子进程组成的，这些子进程通过Unix管道进行连接。</p>
<p>如果一个命令行以“&amp;”符号结尾，那么这个job就会在<em>background</em>运行该程序。也就是在后台运行这个程序，这意味着<em>shell</em>不会等待这个子进程结束后才打印下一个prompt来解析下一条命令行。因此在任何时候，最多只有一个任务能够在前台运行。然而在后台可以运行任意数目的作业。</p>
<p>例如，输入命令行</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br></pre></td></tr></table></figure>

<p>会导致<em>shell</em>执行一个内置的作业命令。输入命令如下</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsh&gt; /bin/ls -l -d</span><br></pre></td></tr></table></figure>

<p>来在前台运行一个<code>ls</code>程序。按照惯例，<em>shell</em>确保当程序开始执行的时候，它的主例程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br></pre></td></tr></table></figure>

<p>这里的<code>argc</code>和<code>argv</code>拥有了如下值：</p>
<ul>
<li>argc &#x3D;&#x3D;  3，</li>
<li>argv[0] &#x3D;&#x3D; “&#x2F;bin&#x2F;ls”,</li>
<li>argv[1] &#x3D;&#x3D; “-l”,</li>
<li>argv[2] &#x3D;&#x3D; “-d”.</li>
</ul>
<p>或者另一方面，我们输入命令行如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsh&gt; /bin/ls -l -d &amp;</span><br></pre></td></tr></table></figure>

<p>就会使得<code>ls</code>程序在后台运行。</p>
<p>Unix shells支持<code>job control</code>，它能够允许用户对将作业在前台和后台之间移动，同时也能够改变进程的状态（running, stopped, or terminated）。输入<code>ctrl-c</code>会导致产生一个SIGINT信号，它被发送到前台的每个作业。类似的，如果你输入一个<code>ctrl-z</code>会导致一个SIGTSTP信号产生，并被发送给每一个前台的工作。对于SIGTSTP的默认行为是设置一个进程为stopped状态，它会保持停止状态直到直到它收到SIGCONT信号后才被唤醒。Unix shells同样提供不同的内置命令来支持这种工作的控制。例如</p>
<ul>
<li><code>jobs</code>：列出正在运行的以及停止的的后台作业</li>
<li><code>bg &lt;job&gt;</code>：改变一个停止的后台作业为一个后台运行态作业</li>
<li><code>fg &lt;job&gt;</code>：改变一个停止或运行的后台作业为一个运行的前台作业</li>
<li><code>kill &lt;job&gt;</code>：终止一个作业</li>
</ul>
<h2 id="tsh的特点"><a href="#tsh的特点" class="headerlink" title="tsh的特点"></a>tsh的特点</h2><p>我们的<code>tsh</code>应该具备以下特点</p>
<ul>
<li>标志符prompt应该是字符串“tsh&gt;”</li>
<li>用户输入的字符串应该由一个可执行的程序或者内嵌的指令开头（<code>name</code>），然后紧跟着0个或者更若干个参数。它们由一个或者更更多的空格隔开。如果<code>name</code>是一个内置指令，tsh直接处理执行，然后等待下一条指令。否则<code>tsh</code>就会把这个<code>name</code>当成是一个可执行文件的路径，然后初始化一个子进程，然后在这个子进程的上下文中加载执行这个程序（在这种情况下，我们所说的作业通常指这个子进程）</li>
<li><code>tsh</code>不需要支持管道符（|）或者I&#x2F;O的重定向（&lt;和&gt;）</li>
<li>输入ctrl-c（ctrl-z）应该导致SIGINT（SIGTSTP）信号产生然后被发送到当前的前台作业那里去，这些信号同样会被发送到这些前台进程的后代进程那里去。（例如它所派生的子进程）。如果没有任何前台进程，那么这个信号将不会有任何的效果</li>
<li>如果这个命令行是以&amp;结尾的，那么<code>tsh</code>应该让这个作业在后台运行。</li>
<li>每一个作业能够唯一的ID（PID）标识或者我们说这是一个作业ID（JID），它是一个<code>tsh</code>所分配的标识符。JIDs应该在命令行上用一个前缀’%‘来表示。例如：“%5”表示的是JID为5。（实验中提供了所有作业列表所需要的例程）</li>
<li><code>tsh</code>应该支持以下内置命令<ul>
<li><code>quit</code>命令用来终止<em>shell</em></li>
<li><code>jobs</code>用来列出所有后台作业</li>
<li><code>bg &lt;job&gt;</code>通过向<code>&lt;job&gt;</code>发送SIGCONT来重启它，然后让它运行在后台中，<code>&lt;job&gt;</code>参数可以用PID或者JID</li>
<li><code>fg &lt;job&gt;</code>命令通过发送SIGCONT信号给进程<code>&lt;job&gt;</code>，然后把它运行在前台中，<code>&lt;job&gt;</code>参数可以用PID或者JID</li>
</ul>
</li>
<li><code>tsh</code>应该回收它的所有僵尸孩子。如果任何作业因为接收到未捕获的信号而终止，则<code>tsh</code>应识别此事件并打印带有作业 PID 的消息和违规信号的描述</li>
</ul>
<h2 id="检查工作的正确性"><a href="#检查工作的正确性" class="headerlink" title="检查工作的正确性"></a>检查工作的正确性</h2><p>实验提供了一些工具来帮助我们检查工作是否正确。</p>
<p><strong>Reference solution.</strong><code>tshref</code>是一个Linux下的可执行文件为我们的<em>shell</em>提供了一个参考解决办法。运行这个程序来解决问题，看看我们的<code>tsh</code>执行的怎么样。你的<em>shell</em>应该提交输出和参考解决办法完全相同。</p>
<p><strong>Shell driver.</strong><code>sdriver.pl</code>程序将我们的<code>tsh</code>作为子进程执行，按照跟踪文件的指令向其发送命令和信号，并捕获显示<em>shell</em>的输出。使用<code>-h</code>。</p>
<p>我们有16个trace文件trace{01-16}.txt，用来和shell driver一起使用，用来测试我们的<em>shell</em>的正确性。那些数字小的trace文件做一些简单的测试，大的数字做的是更加复杂的测试。</p>
<p>可以简单通过</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unix&gt; make test01		<span class="comment">#执行test01</span></span><br><span class="line">unix&gt; make rtest01		<span class="comment">#用reference solution(tshref)执行test01</span></span><br></pre></td></tr></table></figure>

<p>看输出结果是否一致即可。</p>
<h2 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h2><p>为了保证实验的顺利进行，首先阅读课本第八章的内容。</p>
<p>根据实验指导书，这边建议根据trace文件来进行实验，trace给出你要做的事情的提示。</p>
<h3 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * main - The shell&#x27;s main routine </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">char</span> cmdline[MAXLINE];</span><br><span class="line">    <span class="type">int</span> emit_prompt = <span class="number">1</span>; <span class="comment">/* emit prompt (default) */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Redirect stderr to stdout (so that driver will get all output</span></span><br><span class="line"><span class="comment">     * on the pipe connected to stdout) */</span></span><br><span class="line">    dup2(<span class="number">1</span>, <span class="number">2</span>);	<span class="comment">// 把错误信息重定向到标准输出上，也就是输出到屏幕上</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Parse the command line */</span></span><br><span class="line">    <span class="comment">// 处理参数</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * -h 帮助文件</span></span><br><span class="line"><span class="comment">    * -v 发送额外的诊断信息</span></span><br><span class="line"><span class="comment">    * -p 不打印prompt</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">while</span> ((c = getopt(argc, argv, <span class="string">&quot;hvp&quot;</span>)) != EOF) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:             <span class="comment">/* print help message */</span></span><br><span class="line">            usage();</span><br><span class="line">	    <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;v&#x27;</span>:             <span class="comment">/* emit additional diagnostic info */</span></span><br><span class="line">            verbose = <span class="number">1</span>;</span><br><span class="line">	    <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;p&#x27;</span>:             <span class="comment">/* don&#x27;t print a prompt */</span></span><br><span class="line">            emit_prompt = <span class="number">0</span>;  <span class="comment">/* handy for automatic testing */</span></span><br><span class="line">	    <span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">            usage();</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Install the signal handlers */</span></span><br><span class="line">	<span class="comment">// 对各种信号进行处理</span></span><br><span class="line">    <span class="comment">/* These are the ones you will need to implement */</span></span><br><span class="line">    Signal(SIGINT,  sigint_handler);   <span class="comment">/* ctrl-c */</span></span><br><span class="line">    Signal(SIGTSTP, sigtstp_handler);  <span class="comment">/* ctrl-z */</span></span><br><span class="line">    Signal(SIGCHLD, sigchld_handler);  <span class="comment">/* Terminated or stopped child */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This one provides a clean way to kill the shell */</span></span><br><span class="line">    Signal(SIGQUIT, sigquit_handler); </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initialize the job list */</span></span><br><span class="line">    <span class="comment">// 初始化作业列表</span></span><br><span class="line">    initjobs(jobs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Execute the shell&#x27;s read/eval loop */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Read command line */</span></span><br><span class="line">    <span class="comment">// 打印一个prompt符</span></span><br><span class="line">	<span class="keyword">if</span> (emit_prompt) &#123;</span><br><span class="line">	    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, prompt);</span><br><span class="line">	    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 从标准获得命令行</span></span><br><span class="line">	<span class="keyword">if</span> ((fgets(cmdline, MAXLINE, <span class="built_in">stdin</span>) == <span class="literal">NULL</span>) &amp;&amp; ferror(<span class="built_in">stdin</span>))</span><br><span class="line">	    app_error(<span class="string">&quot;fgets error&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// EOF: 当输入ctrl-d的时候表示标准输入(文件)结束，此时直接退出</span></span><br><span class="line">	<span class="keyword">if</span> (feof(<span class="built_in">stdin</span>)) &#123; <span class="comment">/* End of file (ctrl-d) */</span></span><br><span class="line">	    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">	    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Evaluate the command line */</span></span><br><span class="line">	eval(cmdline);		<span class="comment">// 解析命令行</span></span><br><span class="line">	fflush(<span class="built_in">stdout</span>);</span><br><span class="line">	fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">/* control never reaches here */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码我们可以看出，<code>main</code>函数的主要工作就是从标准输出中读出命令行，然后把它交给<code>eval</code>来处理。</p>
<p>参考CSAPP官方网站上给出阉割版本的<em>shell.c</em>，我们可以看到eval主要工作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * eval - evaluate a command line</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">eval</span><span class="params">(<span class="type">char</span> *cmdline)</span> </span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">	<span class="comment">// 通过把argv传递给buildin_command让它判断是不是内置命令并执行</span></span><br><span class="line">    <span class="comment">// 如果不是返回零</span></span><br><span class="line">    <span class="keyword">if</span> (!builtin_command(argv)) &#123; </span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">* buildin_cmd</span></span><br><span class="line"><span class="comment">*/</span>  </span><br><span class="line"><span class="type">int</span> <span class="title function_">builtin_cmd</span><span class="params">(<span class="type">char</span> **argv)</span> </span><br><span class="line">&#123;</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>

<p>我们理清楚主要执行流程如下</p>
<p><img src="/2022/05/26/CSAPP-shlab-report/image-20220525154122346.png" alt="image-20220525154122346"></p>
<h3 id="test01"><a href="#test01" class="headerlink" title="test01"></a>test01</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest01</span><br><span class="line">./sdriver.pl -t trace01.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace01.txt - Properly terminate on EOF.</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure>

<p>我们参考第一个<code>test</code>，对<code>tshref</code>输出了如上结果。这个对于标准输入结束（EOF）的处理。实际上就是对ctrl-d的处理。我们观察到上面<code>main</code>函数中已经有包含对EOF的处理</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// EOF: 当输入ctrl-d的时候表示标准输入(文件)结束，此时直接退出</span></span><br><span class="line">	<span class="keyword">if</span> (feof(<span class="built_in">stdin</span>)) &#123; <span class="comment">/* End of file (ctrl-d) */</span></span><br><span class="line">	    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">	    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>因此我们不许要做什么，可以看到测试结果和参考一致。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make test01</span><br><span class="line">./sdriver.pl -t trace01.txt -s ./tsh -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace01.txt - Properly terminate on EOF.</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure>



<h3 id="test02"><a href="#test02" class="headerlink" title="test02"></a>test02</h3><p>这个一个明显需要做些什么。（不可能又帮你写好）</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest02</span><br><span class="line">./sdriver.pl -t trace02.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace02.txt - Process builtin quit command.</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure>

<p>这个测试要求我们完成对<code>tsh</code>的一条内嵌指令（quit）的处理。它完成的任务就是退出<code>tsh</code>。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ ./tsh</span><br><span class="line">tsh&gt; quit</span><br><span class="line">tsh&gt; </span><br></pre></td></tr></table></figure>

<p>我们可以看到如果什么都不做，是不能够退出的。</p>
<p>现在对这个<code>quit</code>指令的位置有两种思考方向。根据上面<code>main</code>的执行流程，我们说有两个后续处理的方向，一个就是放在eval里面处理，一个就是放在<code>buildin_cmd</code>里面。后者很好理解，这个<code>quit</code>本来就是内嵌指令，所以可以放在后者里面。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">builtin_cmd</span><span class="params">(<span class="type">char</span> **argv)</span>;</span><br></pre></td></tr></table></figure>

<p>可以看到<code>buildin_cmd</code>虽然是对内置指令的处理，这样一条<code>quit</code>非常简单，只要读到这条指令，直接<code>exit(0)</code>，就是它的全部逻辑了。</p>
<p>首先用到<code>parseline</code>来解析命令行，并建立<code>argv</code>，我们可以看到<code>parseline</code>函数的说明如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * parseline - Parse the command line and build the argv array.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Characters enclosed in single quotes are treated as a single</span></span><br><span class="line"><span class="comment"> * argument.  Return true if the user has requested a BG job, false if</span></span><br><span class="line"><span class="comment"> * the user has requested a FG job.  </span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>这个函数主要主要功能就是解析命令行字符串，然后建立<code>argv</code>参数数组，用来给后面execve使用等。</p>
<p>所以代码实现起来就是如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">eval</span><span class="params">(<span class="type">char</span> *cmdline)</span> </span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">// 参数字符串数组</span></span><br><span class="line">	<span class="type">char</span> *argv[MAXARGS]; <span class="comment">/* argv for execve() */</span></span><br><span class="line">	<span class="type">int</span> bg;              <span class="comment">/* should the job run in bg or fg? */</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* parse command line */</span></span><br><span class="line">    <span class="comment">// 解析cmdline获得argv</span></span><br><span class="line">    bg = parseline(cmdline, argv); </span><br><span class="line">	<span class="keyword">if</span> (!builtin_cmd(argv)) &#123; </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * builtin_cmd - If the user has typed a built-in command then execute</span></span><br><span class="line"><span class="comment"> *    it immediately.  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">builtin_cmd</span><span class="params">(<span class="type">char</span> **argv)</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;quit&quot;</span>))</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);  <span class="comment">/* terminate shell */</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>然后我们<code>make</code>编译以下，查看测试情况，</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make test02</span><br><span class="line">./sdriver.pl -t trace02.txt -s ./tsh -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace02.txt - Process builtin quit command.</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure>

<p>和参考一样，通关~</p>
<h3 id="test03-amp-test04"><a href="#test03-amp-test04" class="headerlink" title="test03 &amp; test04"></a>test03 &amp; test04</h3><p>测试3和测试4的内容放在一起讲好了，因为</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest03</span><br><span class="line">./sdriver.pl -t trace03.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace03.txt - Run a foreground job.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; quit</span><br><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest04</span><br><span class="line">./sdriver.pl -t trace04.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace04.txt - Run a background job.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./myspin 1 &amp;</span><br><span class="line">[1] (9950) ./myspin 1 &amp;</span><br></pre></td></tr></table></figure>

<p>可以看到参考程序中，对于测试3，它测试了前台运行<code>quit</code>，测试4在后台运行了<code>myspin</code>，<code>myspin</code>是自旋等待了1秒。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in `parseline`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* should the job run in the background? */</span></span><br><span class="line">    <span class="keyword">if</span> ((bg = (*argv[argc<span class="number">-1</span>] == <span class="string">&#x27;&amp;&#x27;</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">	argv[--argc] = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到在<code>parseline</code>通过上面的步骤解析判断了是否需要讲进程运行在后台。主要是通过检索命令行末尾的字符是否是‘&amp;’</p>
<p><strong>前台工作需要等待工作执行完毕就好了。不论是前台还是后台程序，都需要加入到jobs</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* global variables */</span></span><br><span class="line"><span class="type">int</span> nextjid = <span class="number">1</span>;            <span class="comment">/* next job ID to allocate */</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">/* addjob - Add a job to the job list */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">addjob</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span> *jobs, <span class="type">pid_t</span> pid, <span class="type">int</span> state, <span class="type">char</span> *cmdline)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">1</span>)	<span class="comment">// 无效pid</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++) &#123;	</span><br><span class="line">        <span class="comment">/* 如果jobs数组里面有pid等于0等于0的表项，表示这个位置可以用，把这个作业放进去 */</span></span><br><span class="line">        <span class="keyword">if</span> (jobs[i].pid == <span class="number">0</span>) &#123;</span><br><span class="line">            jobs[i].pid = pid;</span><br><span class="line">            jobs[i].state = state;</span><br><span class="line">            jobs[i].jid = nextjid++;</span><br><span class="line">            <span class="keyword">if</span> (nextjid &gt; MAXJOBS)</span><br><span class="line">                nextjid = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">strcpy</span>(jobs[i].cmdline, cmdline);</span><br><span class="line">            <span class="keyword">if</span>(verbose)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Added job [%d] %d %s\n&quot;</span>, jobs[i].jid, jobs[i].pid, jobs[i].cmdline);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Tried to create too many jobs\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>addjob</code>的工作就是为PID为pid的子进程分配一个jid，然后把jid保存在进程结构中,然后根据全局变量JID来给这个子进程为<code>tsh</code>编写这个子进程的JID。通过是为了防止JID越界的情况，需要额外对的<code>nextjid</code>进行判断。我们对此更加加深了对jid的理解。jid就是现在一共有几个job在<code>tsh</code>下面运行。由于<code>jobs</code>数组是有限的，所以jid超过了MAXJOBS的话是需要重置的。如果发生这种事情的话，只有当一个作业结束，<code>jobs</code>才能让出位置来，这是后才可以再分配工作。值得一提的是，根据课本<em>shell.c</em>的代码，我们可以在这里加一个，如果<code>verbose</code>有效的话，打印详细信息（加入的作业是啥）</p>
<p>我们还需要等待前台运行的子进程运行完，所以我们还要解决<code>waitfg</code>函数的问题。这个函数是需要我们自己编写的。主要功能就是阻塞当前进程也就是<code>tsh</code>，直到我们pid命名的子进程结束。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* fgpid - Return PID of current foreground job, 0 if no such job */</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fgpid</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span> *jobs)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++)</span><br><span class="line">	<span class="keyword">if</span> (jobs[i].state == FG)</span><br><span class="line">	    <span class="keyword">return</span> jobs[i].pid;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这个函数就是循环查看当前前台工作的作业的pid是多少。知道了这个我们就可以写<code>waitfg</code>函数了。当<code>pid</code>对应的进程还是前台进程的时候就一直循环等待。指导书里面说可以用循环<code>sleep(0)</code>进行等待。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">waitfg</span><span class="params">(<span class="type">pid_t</span> pid)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (pid == fgpid(jobs))</span><br><span class="line">        sleep(<span class="number">0</span>); <span class="comment">// 这里是指主动让出CPU的意思</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具备上面的基础，我们可以写出代码如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in `eval`</span></span><br><span class="line">...  </span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> (!builtin_cmd(argv)) &#123; </span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) == <span class="number">0</span>) &#123;  <span class="comment">/* child */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Background jobs should ignore SIGINT (ctrl-c)  */</span></span><br><span class="line">        <span class="comment">/* and SIGTSTP (ctrl-z) */</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        if (bg) &#123;</span></span><br><span class="line"><span class="comment">            // 课本对SIG_IGN有详细解释</span></span><br><span class="line"><span class="comment">            // 如果信号的handler是SIG_IGN，会忽略这个信号</span></span><br><span class="line"><span class="comment">            Signal(SIGINT, SIG_IGN);</span></span><br><span class="line"><span class="comment">            Signal(SIGTSTP, SIG_IGN);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        </span><br><span class="line">		<span class="comment">// 前台执行</span></span><br><span class="line">        <span class="keyword">if</span> (execve(argv[<span class="number">0</span>], argv, environ) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s: Command not found.\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">            fflush(<span class="built_in">stdout</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">// 如果没有这个可执行程序，那么直接终止这个子进程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* parent waits for foreground job to terminate or stop */</span></span><br><span class="line">    addjob(jobs, pid, (bg == <span class="number">1</span> ? BG : FG), cmdline);</span><br><span class="line">    <span class="keyword">if</span> (!bg) <span class="comment">// 前台运行则等待子进程</span></span><br><span class="line">        waitfg(pid);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%d] (%d) %s&quot;</span>, pid2jid(pid), pid, cmdline);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到上面的函数<code>fork</code>出一个子进程，然后<code>execve</code>执行某个可执行程序。对于父进程，父进程把这个进程添加到jobs队列中去。然后如果这是一个前台程序，就调用<code>waitfg</code>等待子进程结束。如果子进程结束了。通过SIGCHLD信号给父进程发信息，唤醒父进程回收自己。</p>
<p>父进程回收处理程序如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * sigchld_handler - The kernel sends a SIGCHLD to the shell whenever</span></span><br><span class="line"><span class="comment"> *     a child job terminates (becomes a zombie), or stops because it</span></span><br><span class="line"><span class="comment"> *     received a SIGSTOP or SIGTSTP signal. The handler reaps all</span></span><br><span class="line"><span class="comment"> *     available zombie children, but doesn&#x27;t wait for any other</span></span><br><span class="line"><span class="comment"> *     currently running children to terminate.  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sigchld_handler</span><span class="params">(<span class="type">int</span> sig)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (verbose)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sigchld_handler: entering \n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    * 回收僵尸进程</span></span><br><span class="line"><span class="comment">    * 这里的WNOHANG是非常重要的。</span></span><br><span class="line"><span class="comment">    * 它的本意是如果所有孩子都没有僵尸(终止)状态的，直接退出</span></span><br><span class="line"><span class="comment">    * 这个能够避免在这里等待所有前台的running和stopped程序终止</span></span><br><span class="line"><span class="comment">    * 这样tsh就不能正常接受用户的输入了</span></span><br><span class="line"><span class="comment">    * WUNTRACED是等待直到有一个子进程变成僵尸退出，返回它的pid</span></span><br><span class="line"><span class="comment">    * 这个选项开启能够检查已终止和被停止的子进程</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">while</span> ((pid = waitpid(<span class="number">-1</span>, &amp;status, WNOHANG | WUNTRACED)) &gt; <span class="number">0</span>) &#123; </span><br><span class="line">        <span class="comment">// 这里不管是不是正常exit或者ctrl-c或者ctrl-z退出的</span></span><br><span class="line">        <span class="comment">// 子进程都结束了，都要回收资源</span></span><br><span class="line">        deletejob(jobs, pid);</span><br><span class="line">        <span class="keyword">if</span> (verbose)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;sigchld_handler: job %d deleted\n&quot;</span>, pid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (verbose)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sigchld_handler: exiting\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>像上面这样写看起来是没有什么问题了。但是课本519中提示了一种苛刻同步问题。如果子进程在父进程将自己加入到<code>jobs</code>之前就执行完毕，然后<code>exit</code>退出，就会触发父进程的回收<code>sigchld_handler</code>程序，实际上，这样的删除显然没有任何意义。后续又将这个工作<code>addjob</code>，这也是没有什么意义的。</p>
<p>因此我们还要对上面的<code>eval</code>进一步修改为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in `eval`</span></span><br><span class="line">...   </span><br><span class="line"><span class="type">sigset_t</span> mask;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> (!builtin_cmd(argv)) &#123;</span><br><span class="line">        Sigprocmask(SIG_BLOCK, &amp;mask, &amp;prev);  <span class="comment">/* 阻塞SIGCHLD */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((pid = fork()) == <span class="number">0</span>) &#123;   <span class="comment">/* Child runs user job */</span></span><br><span class="line">            <span class="comment">/* 给fork出来的子进程设置一个独立的组，</span></span><br><span class="line"><span class="comment">	 		 * 子进程是这个组的组长,组id为子进程的pid */</span></span><br><span class="line">            setpgid(<span class="number">0</span>, <span class="number">0</span>);	</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/* 对于子进程并不需要阻塞SIGCHLD的信号 */</span></span><br><span class="line">            Sigprocmask(SIG_UNBLOCK, &amp;prev, <span class="literal">NULL</span>);  <span class="comment">// unblock SIGCHLD</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">/* </span></span><br><span class="line"><span class="comment">            * 前台执行 </span></span><br><span class="line"><span class="comment">            * 如果没有这个可执行程序，那么直接终止这个子进程</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">if</span> (execve(argv[<span class="number">0</span>], argv, environ) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s: Command not found.\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">                _exit(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        addjob(jobs, pid, bg ? BG : FG, cmdline);</span><br><span class="line">        <span class="comment">/* 已经加到jobs了，解除阻塞 */</span></span><br><span class="line">        Sigprocmask(SIG_SETMASK, &amp;prev, <span class="literal">NULL</span>);  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Parent waits for foreground job to terminate */</span></span><br><span class="line">        <span class="keyword">if</span> (!bg)  <span class="comment">// 前台运行则等待子进程</span></span><br><span class="line">            waitfg(pid);</span><br><span class="line">        <span class="keyword">else</span>      <span class="comment">// background</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[%d] (%d) %s&quot;</span>, pid2jid(pid), pid, cmdline);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>测试以下我们的代码的正确性</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest03</span><br><span class="line">./sdriver.pl -t trace03.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace03.txt - Run a foreground job.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; quit</span><br><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make test03</span><br><span class="line">./sdriver.pl -t trace03.txt -s ./tsh -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace03.txt - Run a foreground job.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; quit</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest04</span><br><span class="line">./sdriver.pl -t trace04.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace04.txt - Run a background job.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./myspin 1 &amp;</span><br><span class="line">[1] (10488) ./myspin 1 &amp;</span><br><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make test04</span><br><span class="line">./sdriver.pl -t trace04.txt -s ./tsh -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace04.txt - Run a background job.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./myspin 1 &amp;</span><br><span class="line">[1] (10494) ./myspin 1 &amp;</span><br></pre></td></tr></table></figure>

<p>测试程序都相同了，成功~</p>
<h3 id="test05"><a href="#test05" class="headerlink" title="test05"></a>test05</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest05</span><br><span class="line">./sdriver.pl -t trace05.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace05.txt - Process jobs builtin command.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./myspin 2 &amp;</span><br><span class="line">[1] (10504) ./myspin 2 &amp;</span><br><span class="line">tsh&gt; ./myspin 3 &amp;</span><br><span class="line">[2] (10506) ./myspin 3 &amp;</span><br><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br><span class="line">[1] (10504) Running ./myspin 2 &amp;</span><br><span class="line">[2] (10506) Running ./myspin 3 &amp;</span><br></pre></td></tr></table></figure>

<p>这里的任务是完成内嵌指令<code>jobs</code>的工作。它能够列出作业列表中的所有作业。</p>
<p>这个很简单，起始只要用一个<code>listjobs</code>就可已完成这个工作了，这个函数是实验已经帮我们实现了的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* listjobs - Print the job list */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">listjobs</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span> *jobs)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (jobs[i].pid != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[%d] (%d) &quot;</span>, jobs[i].jid, jobs[i].pid);</span><br><span class="line">            <span class="keyword">switch</span> (jobs[i].state) &#123;</span><br><span class="line">                <span class="keyword">case</span> BG: </span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Running &quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> FG: </span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Foreground &quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> ST: </span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Stopped &quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;listjobs: Internal error: job[%d].state=%d &quot;</span>, </span><br><span class="line">                           i, jobs[i].state);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, jobs[i].cmdline);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在<code>builtin_cmd</code>中加入<code>jobs</code>命令的入口就好。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">builtin_cmd</span><span class="params">(<span class="type">char</span> **argv)</span> </span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// jobs command    </span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;jobs&quot;</span>)) &#123;        </span><br><span class="line">        listjobs(jobs);        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>我们看看测试结果</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest05</span><br><span class="line">./sdriver.pl -t trace05.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace05.txt - Process jobs builtin command.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./myspin 2 &amp;</span><br><span class="line">[1] (10613) ./myspin 2 &amp;</span><br><span class="line">tsh&gt; ./myspin 3 &amp;</span><br><span class="line">[2] (10615) ./myspin 3 &amp;</span><br><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br><span class="line">[1] (10613) Running ./myspin 2 &amp;</span><br><span class="line">[2] (10615) Running ./myspin 3 &amp;</span><br><span class="line"></span><br><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make test05</span><br><span class="line">./sdriver.pl -t trace05.txt -s ./tsh -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace05.txt - Process jobs builtin command.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./myspin 2 &amp;</span><br><span class="line">[1] (10622) ./myspin 2 &amp;</span><br><span class="line">tsh&gt; ./myspin 3 &amp;</span><br><span class="line">[2] (10624) ./myspin 3 &amp;</span><br><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br><span class="line">[1] (10622) Running ./myspin 2 &amp;</span><br><span class="line">[2] (10624) Running ./myspin 3 &amp;</span><br></pre></td></tr></table></figure>

<p>和参考一致，表示正确。这里你可能会被英文的实验指导书迷惑了，实际上列出的是工作列表的所有工作，而不是后台的所有工作。通关~</p>
<h3 id="test06-amp-test07-amp-test08"><a href="#test06-amp-test07-amp-test08" class="headerlink" title="test06 &amp; test07 &amp; test08"></a>test06 &amp; test07 &amp; test08</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest06</span><br><span class="line">./sdriver.pl -t trace06.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace06.txt - Forward SIGINT to foreground job.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./myspin 4</span><br><span class="line">Job [1] (10840) terminated by signal 2</span><br><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest07</span><br><span class="line">./sdriver.pl -t trace07.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace07.txt - Forward SIGINT only to foreground job.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./myspin 4 &amp;</span><br><span class="line">[1] (10846) ./myspin 4 &amp;</span><br><span class="line">tsh&gt; ./myspin 5</span><br><span class="line">Job [2] (10848) terminated by signal 2</span><br><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br><span class="line">[1] (10846) Running ./myspin 4 &amp;</span><br><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest08</span><br><span class="line">./sdriver.pl -t trace08.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace08.txt - Forward SIGTSTP only to foreground job.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./myspin 4 &amp;</span><br><span class="line">[1] (10856) ./myspin 4 &amp;</span><br><span class="line">tsh&gt; ./myspin 5</span><br><span class="line">Job [2] (10858) stopped by signal 20</span><br><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br><span class="line">[1] (10856) Running ./myspin 4 &amp;</span><br><span class="line">[2] (10858) Stopped ./myspin 5 </span><br></pre></td></tr></table></figure>

<p>测试678要完成的任务是对于SIGINT和SIGTSTP的处理。对于上面的测试，测试6启动一个自旋程序到前台并且发出SIGINT终止它。测试7启动两个自旋，一个在前台一个在后台，然后发出SIGINT，检测到只有前台进程被终止了。测试8类似。</p>
<img src="/2022/05/26/CSAPP-shlab-report/image-20220526003548830.png" alt="image-20220526003548830" style="zoom:67%;">

<p>我们可以从课本上这幅图看到shell会给每一个子进程分配一个和PID一样的组id，这些shell的子进程的孩子都在这些子进程的组内。比如上图中的前台作业就是shell产生的子进程，但是它和shell不是一个组的，他自己独立成组，组id等于自己的pid，然后它的孩子都属于自己这个组。</p>
<p>首先需要完成SIGINT的处理，给前台进程的组的所有进程发送SIGINT信号(这里就是参数sig)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sigint_handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 这一步的保存和下一步的恢复，是由于在下面的kill系统调用中可能会覆盖errno的值</span></span><br><span class="line">    <span class="comment">// 导致现在的errno丢失</span></span><br><span class="line">    <span class="comment">// 而errno在sigchild_handler中还有使用到，为了避免产生这种错误需要在这里保存，在后面恢复</span></span><br><span class="line">    <span class="type">int</span> olderrno = errno;</span><br><span class="line">    <span class="comment">// get the foreground job pid</span></span><br><span class="line">    <span class="type">pid_t</span> fg_pid = fgpid(jobs);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * int kill(pid_t pid,int signo)</span></span><br><span class="line"><span class="comment"> 	* 功能: 向进程或进程组发送一个信号 （成功返回 0； 否则，返回 -1 ）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    kill(-fg_pid, sig); </span><br><span class="line">    <span class="comment">// -fg_pid表示向进程组号为pid的组中的每个进程发sig信号</span></span><br><span class="line">    <span class="comment">// 在这里就是向前台进程以及它的每一个子进程(子进程都在自己的父进程的pid为组id的组下)</span></span><br><span class="line">    errno = olderrno;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相同的原理，可以写出<code>sigtstp_handler</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sigtstp_handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 为了异步信号安全防止errno被覆盖</span></span><br><span class="line">    <span class="type">int</span> olderrno = errno;</span><br><span class="line">    <span class="comment">// get the foreground job pid</span></span><br><span class="line">    <span class="type">pid_t</span> fg_pid = fgpid(jobs);</span><br><span class="line">    <span class="comment">// kill the group in the foreground</span></span><br><span class="line">    kill(-fg_pid, sig);</span><br><span class="line">    errno = olderrno;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的两个函数就是信号处理过程。<code>sigchld_handler</code>里收到子进程终止或停止的消息后给出对应的输出然后改变其状态，对于终止的进程就在jobs里将其删除，对于停止的进程则设置其state为ST。</p>
<img src="/2022/05/26/CSAPP-shlab-report/image-20220526081536379.png" alt="image-20220526081536379" style="zoom:80%;">

<p>主要流程如上图。</p>
<p>然后就是对<code>sigchld_handler</code>的修改。我们需要针对上面的代码进一步进行修改。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sigchld_handler - The kernel sends a SIGCHLD to the shell whenever</span></span><br><span class="line"><span class="comment"> *     a child job terminates (becomes a zombie), or stops because it</span></span><br><span class="line"><span class="comment"> *     received a SIGSTOP or SIGTSTP signal. The handler reaps all</span></span><br><span class="line"><span class="comment"> *     available zombie children, but doesn&#x27;t wait for any other</span></span><br><span class="line"><span class="comment"> *     currently running children to terminate.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sigchld_handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> old_errno = errno;</span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (verbose)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sigchld_handler: entering \n&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* </span></span><br><span class="line"><span class="comment">    * 回收僵尸进程</span></span><br><span class="line"><span class="comment">    * 这里的WNOHANG是非常重要的。</span></span><br><span class="line"><span class="comment">    * 它的本意是如果所有孩子都没有僵尸(终止)状态的，直接退出</span></span><br><span class="line"><span class="comment">    * 这个能够避免在这里等待所有前台的running和stopped程序终止</span></span><br><span class="line"><span class="comment">    * 这样tsh就不能正常接受用户的输入了</span></span><br><span class="line"><span class="comment">    * WUNTRACED是等待直到有一个子进程变成僵尸退出，返回它的pid</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">while</span> ((pid = waitpid(<span class="number">-1</span>, &amp;status, WNOHANG | WUNTRACED)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* 这里实验指导书说不能用while，但是不用会出现错误。他说的while和我的判断条件不一样 */</span></span><br><span class="line">        <span class="comment">// 子进程正常退出</span></span><br><span class="line">        <span class="keyword">if</span> (WIFEXITED(status)) &#123;</span><br><span class="line">            deletejob(jobs, pid);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 子进程因为ctrl-c退出</span></span><br><span class="line">        <span class="keyword">if</span> (WIFSIGNALED(status)) &#123; <span class="comment">// terminated by ctrl-c</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Job [%d] (%d) terminated by signal %2d\n&quot;</span>, </span><br><span class="line">                   pid2jid(pid), pid, WTERMSIG(status));</span><br><span class="line">            deletejob(jobs, pid); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (WIFSTOPPED(status)) &#123; <span class="comment">// stopped by ctrl-z</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Job [%d] (%d) stopped by signal %2d\n&quot;</span>,</span><br><span class="line">                   pid2jid(pid), pid, WSTOPSIG(status));</span><br><span class="line">            <span class="comment">// 修改子进程状态为ST</span></span><br><span class="line">            getjobpid(jobs, pid)-&gt;state = ST;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    errno = old_errno;</span><br><span class="line">    <span class="keyword">if</span> (verbose) </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sigchld_handler: exiting\n&quot;</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的程序，在子进程发送SIGCHLD时处于不同状态的子进程，已经有了不同的处理。</p>
<p>但是还存在一个问题，就是<code>printf</code>是异步不安全的。可能出现死锁现象。</p>
<p><strong>死锁（Deadlock）：</strong>当你存在多个逻辑流在等待永远不会发生的场景时就会出现死锁。比如在信号处理程序中使用异步信号不安全的<code>printf</code>函数就可能会出现死锁现象。在主程序中执行了<code>printf</code>函数，则该函数会请求某些资源的一个锁，当该<code>printf</code>函数请求这个锁时它被某个信号处理程序中断了，而在信号处理程序中也要执行一个<code>printf</code>函数，这个<code>printf</code>也试图请求那个锁，但是由于主程序中的<code>printf</code>函数持有那个锁，所以信号处理程序中的<code>printf</code>得不到那个锁，所以这个<code>printf</code>就在等待那个锁被释放的锁，但是主程序只有在信号处理程序返回时才可能释放那个锁，所以这里就造成了死锁。</p>
<p>这里是线程安全但是不可重入的异步安全问题，使用锁是不能够解决的。</p>
<p>所以我们再主线程也就是<code>main</code>里面已经使用过<code>printf</code>了，就要避免在信号处理程序中在使用<code>printf</code>的出现。</p>
<p>我提供下面两种解决手段。</p>
<ul>
<li>一种想法是在这里使用<code>printf</code>的时候屏蔽或者说阻塞SIGCHLD信号，这样主线程在使用<code>printf</code>就不会被中断。但是带来的问题就是这个中断处理信号会被忽略。可能出现处理遗漏的情况。</li>
<li>还有一种处理手段是使用异步信号安全的可重入函数，如下</li>
</ul>
<blockquote>
<p>CSAPP课本实例程序提供了一种线程安全且可重入的函数sio系列函数，使用它，不调用<code>printf</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* private functions */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sio_reverse</span><span class="params">(<span class="type">char</span> s[])</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sio_ltoa</span><span class="params">(<span class="type">long</span> v, <span class="type">char</span> s[], <span class="type">int</span> b)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">size_t</span> <span class="title function_">sio_strlen</span><span class="params">(<span class="type">char</span> s[])</span>;</span><br><span class="line"><span class="comment">/* public functions */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sio_puts</span><span class="params">(<span class="type">char</span> s[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sio_putl</span><span class="params">(<span class="type">long</span> v)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sio_error</span><span class="params">(<span class="type">char</span> s[])</span>;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>查看Linux手册可以知道<code>write</code>是异步信号安全的，使用<code>write</code>就可以实现异步安全的输出了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sio_puts</span><span class="params">(<span class="type">char</span> s[])</span> <span class="comment">/* Put string */</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> write(STDOUT_FILENO, s, <span class="built_in">strlen</span>(s));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我对上面的sio族进行封装形成Sio系列。</p>
<p>我们把<code>sigchld_handler</code>修改以下如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sigchld_handler - The kernel sends a SIGCHLD to the shell whenever</span></span><br><span class="line"><span class="comment"> *     a child job terminates (becomes a zombie), or stops because it</span></span><br><span class="line"><span class="comment"> *     received a SIGSTOP or SIGTSTP signal. The handler reaps all</span></span><br><span class="line"><span class="comment"> *     available zombie children, but doesn&#x27;t wait for any other</span></span><br><span class="line"><span class="comment"> *     currently running children to terminate.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sigchld_handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> old_errno = errno;</span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (verbose)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sigchld_handler: entering \n&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* </span></span><br><span class="line"><span class="comment">    * 回收僵尸进程</span></span><br><span class="line"><span class="comment">    * 这里的WNOHANG是非常重要的。</span></span><br><span class="line"><span class="comment">    * 它的本意是如果所有孩子都没有僵尸(终止)状态的，直接退出</span></span><br><span class="line"><span class="comment">    * 这个能够避免在这里等待所有前台的running和stopped程序终止</span></span><br><span class="line"><span class="comment">    * 这样tsh就不能正常接受用户的输入了</span></span><br><span class="line"><span class="comment">    * WUNTRACED是等待直到有一个子进程变成僵尸退出，返回它的pid</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">while</span> ((pid = waitpid(<span class="number">-1</span>, &amp;status, WNOHANG | WUNTRACED)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程正常退出</span></span><br><span class="line">        <span class="keyword">if</span> (WIFEXITED(status)) &#123;</span><br><span class="line">            deletejob(jobs, pid);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 子进程因为ctrl-c退出</span></span><br><span class="line">        <span class="keyword">if</span> (WIFSIGNALED(status)) &#123; <span class="comment">// terminated by ctrl-c</span></span><br><span class="line">            <span class="comment">/* printf(&quot;Job [%d] (%d) terminated by signal %2d\n&quot;, </span></span><br><span class="line"><span class="comment">                   pid2jid(pid), pid, WTERMSIG(status)); */</span> &#123;</span><br><span class="line">            	Sio_puts(<span class="string">&quot;Job [&quot;</span>);</span><br><span class="line">                Sio_putl(pid2jid(pid));</span><br><span class="line">                Sio_puts(<span class="string">&quot;] (&quot;</span>);</span><br><span class="line">                Sio_putl(pid);</span><br><span class="line">                Sio_puts(<span class="string">&quot;) terminated by signal &quot;</span>);</span><br><span class="line">                Sio_putl(WTERMSIG(status));</span><br><span class="line">                Sio_puts(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            deletejob(jobs, pid); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (WIFSTOPPED(status)) &#123; <span class="comment">// stopped by ctrl-z</span></span><br><span class="line">            <span class="comment">/* printf(&quot;Job [%d] (%d) stopped by signal %2d\n&quot;,</span></span><br><span class="line"><span class="comment">                   pid2jid(pid), pid, WSTOPSIG(status)); */</span> &#123;</span><br><span class="line">            	Sio_puts(<span class="string">&quot;Job [&quot;</span>);</span><br><span class="line">                Sio_putl(pid2jid(pid));</span><br><span class="line">                Sio_puts(<span class="string">&quot;] (&quot;</span>);</span><br><span class="line">                Sio_putl(pid);</span><br><span class="line">                Sio_puts(<span class="string">&quot;) stopped by signal &quot;</span>);</span><br><span class="line">                Sio_putl(WSTOPSIG(status));</span><br><span class="line">                Sio_puts(<span class="string">&quot;\n&quot;</span>);           </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 修改子进程状态为ST</span></span><br><span class="line">            getjobpid(jobs, pid)-&gt;state = ST;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    errno = old_errno;</span><br><span class="line">    <span class="keyword">if</span> (verbose) &#123;</span><br><span class="line">        <span class="comment">/* printf(&quot;sigchld_handler: exiting\n&quot;); */</span> &#123;</span><br><span class="line">        	Sio_puts(<span class="string">&quot;sigchld_handler: exiting\n&quot;</span>);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就不会在处理信号程序中使用异步信号不安全的<code>printf</code>了。</p>
<p>然后，<em>shell</em>程序本身是所有子进程的父进程，按照<code>fork</code>函数简单实现，会被分配在一个组中。如果收到了SIGINT，发送给子进程的组，那也会发送给自己（子进程就在自己的组中），那么自己又会收到SIGINT，然后又会发送给自己的所有子进程，然后自己又收到…就陷入循环中无法继续，或者崩溃退出。所以<em>shell</em>不可以和它的子进程在同一个组内，就是要给每个子进程单独的组，组的id就是子进程的pid。我们应该把这个操作放在<code>fork</code>之后，修改它的组id，然后执行<code>execve</code>。</p>
<p>修改<code>eval</code>这一部分代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((pid = fork()) == <span class="number">0</span>) &#123;  <span class="comment">/* child */</span></span><br><span class="line">	<span class="comment">/* 给fork出来的子进程设置一个独立的组，</span></span><br><span class="line"><span class="comment">	 * 子进程是这个组的组长,组id为子进程的pid */</span></span><br><span class="line">    setpgid(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>setpgid</code>函数在实验英文指导书有介绍，用于设置进程组id</p>
<p>表头文件 #include&lt;unistd.h&gt;</p>
<p>定义函数 int setpgid(pid_t pid,pid_t pgid);</p>
<p>功能：设置pid所在的进程组的进程组id设置成pgid</p>
<p>setpgid(0, 0)的含义：</p>
<ul>
<li>第一个参数pid是0，则使用当前进程的pid</li>
<li>第二个参数pgid是0，则使用当前进程pid作为pgid</li>
</ul>
</blockquote>
<p>测试结果</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest06</span><br><span class="line">./sdriver.pl -t trace06.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace06.txt - Forward SIGINT to foreground job.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./myspin 4</span><br><span class="line">Job [1] (3427) terminated by signal 2</span><br><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make test06</span><br><span class="line">./sdriver.pl -t trace06.txt -s ./tsh -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace06.txt - Forward SIGINT to foreground job.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./myspin 4</span><br><span class="line">Job [1] (3433) terminated by signal 2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest07</span><br><span class="line">./sdriver.pl -t trace07.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace07.txt - Forward SIGINT only to foreground job.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./myspin 4 &amp;</span><br><span class="line">[1] (3440) ./myspin 4 &amp;</span><br><span class="line">tsh&gt; ./myspin 5</span><br><span class="line">Job [2] (3442) terminated by signal 2</span><br><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br><span class="line">[1] (3440) Running ./myspin 4 &amp;</span><br><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make test07</span><br><span class="line">./sdriver.pl -t trace07.txt -s ./tsh -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace07.txt - Forward SIGINT only to foreground job.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./myspin 4 &amp;</span><br><span class="line">[1] (3449) ./myspin 4 &amp;</span><br><span class="line">tsh&gt; ./myspin 5</span><br><span class="line">Job [2] (3451) terminated by signal 2</span><br><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br><span class="line">[1] (3449) Running ./myspin 4 &amp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest08</span><br><span class="line">./sdriver.pl -t trace08.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace08.txt - Forward SIGTSTP only to foreground job.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./myspin 4 &amp;</span><br><span class="line">[1] (3459) ./myspin 4 &amp;</span><br><span class="line">tsh&gt; ./myspin 5</span><br><span class="line">Job [2] (3461) stopped by signal 20</span><br><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br><span class="line">[1] (3459) Running ./myspin 4 &amp;</span><br><span class="line">[2] (3461) Stopped ./myspin 5 </span><br><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make test08</span><br><span class="line">./sdriver.pl -t trace08.txt -s ./tsh -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace08.txt - Forward SIGTSTP only to foreground job.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./myspin 4 &amp;</span><br><span class="line">[1] (3469) ./myspin 4 &amp;</span><br><span class="line">tsh&gt; ./myspin 5</span><br><span class="line">Job [2] (3471) terminated by signal 20</span><br><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br><span class="line">[1] (3469) Running ./myspin 4 &amp;</span><br><span class="line">[2] (3471) Stopped ./myspin 5 </span><br></pre></td></tr></table></figure>

<p>可以看到与参考输出一致，通关~</p>
<h3 id="test09-amp-test10"><a href="#test09-amp-test10" class="headerlink" title="test09 &amp; test10"></a>test09 &amp; test10</h3><p>第九个和第十个放在一起写。请往下看。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest09</span><br><span class="line">./sdriver.pl -t trace09.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace09.txt - Process bg builtin command</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./myspin 4 &amp;</span><br><span class="line">[1] (3480) ./myspin 4 &amp;</span><br><span class="line">tsh&gt; ./myspin 5</span><br><span class="line">Job [2] (3482) stopped by signal 20</span><br><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br><span class="line">[1] (3480) Running ./myspin 4 &amp;</span><br><span class="line">[2] (3482) Stopped ./myspin 5 </span><br><span class="line">tsh&gt; <span class="built_in">bg</span> %2</span><br><span class="line">[2] (3482) ./myspin 5 </span><br><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br><span class="line">[1] (3480) Running ./myspin 4 &amp;</span><br><span class="line">[2] (3482) Running ./myspin 5 </span><br></pre></td></tr></table></figure>

<p>我们先看看第九个测试的参考输出。我们可以看到我们需要构建的是<code>bg</code>内置命令的相关功能。</p>
<blockquote>
<p><code>bg &lt;job&gt;</code>通过向<code>&lt;job&gt;</code>发送SIGCONT来重启它，然后让它运行在后台中，<code>&lt;job&gt;</code>参数可以用PID或者JID</p>
<ul>
<li>如果参数是PID则直接输入pid即可</li>
<li>如果参数是JID则输入“%jid”</li>
</ul>
</blockquote>
<p>我们看到上面的测试。首先是开启一个后台自旋和一个前台自旋的程序。然后发起ctrl-z终止前台的进程。然后jobs可以看到两个进程以及状态。后台的进程仍然在正常运行，但是前台的进程由于SIGTSTP信号而进入stopped状态。然后使用<code>bg %2</code>指令，把第二个子进程（停止的“.&#x2F;myspin 5”）唤醒，然后放到后台执行。输入<code>jobs</code>指令可以看到两个都在执行，但是后者是后来被切换到后台的，所以没有它的cmdline还没有更新还是显示原来的“.&#x2F;myspin 5”。</p>
<p>再看看<code>rtest10</code>，第十个测试</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest10</span><br><span class="line">./sdriver.pl -t trace10.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace10.txt - Process fg builtin command. </span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./myspin 4 &amp;</span><br><span class="line">[1] (3510) ./myspin 4 &amp;</span><br><span class="line">tsh&gt; <span class="built_in">fg</span> %1</span><br><span class="line">Job [1] (3510) stopped by signal 20</span><br><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br><span class="line">[1] (3510) Stopped ./myspin 4 &amp;</span><br><span class="line">tsh&gt; <span class="built_in">fg</span> %1</span><br><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br></pre></td></tr></table></figure>

<p>它针对的是fg这个内置命令的处理。</p>
<blockquote>
<p><code>fg &lt;job&gt;</code>命令通过发送SIGCONT信号给进程<code>&lt;job&gt;</code>，然后把它运行在前台中，<code>&lt;job&gt;</code>参数可以用PID或者JID</p>
<ul>
<li>如果参数是PID则直接输入pid即可</li>
<li>如果参数是JID则输入“%jid”</li>
</ul>
</blockquote>
<p>可以看到上面的测试样例，一开始，是后台运行一个“.&#x2F;myspin 4”，然后把它放到前台运行，使用“fg %1”命令，切换到前台执行，<em>shell</em>等待它执行完毕。然后<code>jobs</code>查看看到有一个停止的工作，然后把它放到前台并开始运行。最后<code>jobs</code>查看，由于已经运行完了，所以没有输出。</p>
<p>对于这两个功能我们要实现的是<code>do_fgbg</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * do_bgfg - Execute the builtin bg and fg commands</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_bgfg</span><span class="params">(<span class="type">char</span>** argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">job_t</span>* <span class="title">job</span>;</span></span><br><span class="line">    <span class="type">char</span>* id = argv[<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断输入的是jid还是pid</span></span><br><span class="line">    <span class="keyword">if</span> (id[<span class="number">0</span>] == <span class="string">&#x27;%&#x27;</span>) &#123; <span class="comment">/* jid */</span></span><br><span class="line">        <span class="comment">//去掉&#x27;%&#x27;开始读jid，根据jid返回这个子进程的结构指针</span></span><br><span class="line">        <span class="type">int</span> jid = atoi(id + <span class="number">1</span>);</span><br><span class="line">        job = getjobjid(jobs, jid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;              <span class="comment">/* pid */</span></span><br><span class="line">        <span class="type">int</span> pid = atoi(id);</span><br><span class="line">        job = getjobpid(jobs, pid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    * kill不单是杀掉进程，还有发送信号的功能 </span></span><br><span class="line"><span class="comment">    * 这里唤醒job所在的组中的所有进程</span></span><br><span class="line"><span class="comment">    * 就是唤醒这个stopped的子进程，以及它派生的孙子进程</span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">    kill(-(job-&gt;pid), SIGCONT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;fg&quot;</span>)) &#123;  <span class="comment">// fg command</span></span><br><span class="line">        job-&gt;state = FG;</span><br><span class="line">        <span class="comment">// 等待该前台作业终止</span></span><br><span class="line">        waitfg(job-&gt;pid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;                         <span class="comment">// bg command</span></span><br><span class="line">        job-&gt;state = BG;</span><br><span class="line">        <span class="comment">/* 切换到bg后打印作业信息 */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%d] (%d) %s&quot;</span>, pid2jid(job-&gt;pid), job-&gt;pid, job-&gt;cmdline);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们在<code>builtin_cmd</code>中加入函数入口。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in `builtin_cmd`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// bg or fg command</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;bg&quot;</span>) || !<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;fg&quot;</span>)) &#123;</span><br><span class="line">    do_bgfg(argv);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看测试结果</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest09</span><br><span class="line">./sdriver.pl -t trace09.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace09.txt - Process bg builtin command</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./myspin 4 &amp;</span><br><span class="line">[1] (3627) ./myspin 4 &amp;</span><br><span class="line">tsh&gt; ./myspin 5</span><br><span class="line">Job [2] (3629) stopped by signal 20</span><br><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br><span class="line">[1] (3627) Running ./myspin 4 &amp;</span><br><span class="line">[2] (3629) Stopped ./myspin 5 </span><br><span class="line">tsh&gt; <span class="built_in">bg</span> %2</span><br><span class="line">[2] (3629) ./myspin 5 </span><br><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br><span class="line">[1] (3627) Running ./myspin 4 &amp;</span><br><span class="line">[2] (3629) Running ./myspin 5 </span><br><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make test09</span><br><span class="line">./sdriver.pl -t trace09.txt -s ./tsh -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace09.txt - Process bg builtin command</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./myspin 4 &amp;</span><br><span class="line">[1] (3638) ./myspin 4 &amp;</span><br><span class="line">tsh&gt; ./myspin 5</span><br><span class="line">Job [2] (3640) terminated by signal 20</span><br><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br><span class="line">[1] (3638) Running ./myspin 4 &amp;</span><br><span class="line">[2] (3640) Stopped ./myspin 5 </span><br><span class="line">tsh&gt; <span class="built_in">bg</span> %2</span><br><span class="line">[2] (3640) ./myspin 5 </span><br><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br><span class="line">[1] (3638) Running ./myspin 4 &amp;</span><br><span class="line">[2] (3640) Running ./myspin 5 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest10</span><br><span class="line">./sdriver.pl -t trace10.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace10.txt - Process fg builtin command. </span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./myspin 4 &amp;</span><br><span class="line">[1] (7350) ./myspin 4 &amp;</span><br><span class="line">tsh&gt; <span class="built_in">fg</span> %1</span><br><span class="line">Job [1] (7350) stopped by signal 20</span><br><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br><span class="line">[1] (7350) Stopped ./myspin 4 &amp;</span><br><span class="line">tsh&gt; <span class="built_in">fg</span> %1</span><br><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make test10</span><br><span class="line">./sdriver.pl -t trace10.txt -s ./tsh -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace10.txt - Process fg builtin command. </span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./myspin 4 &amp;</span><br><span class="line">[1] (7361) ./myspin 4 &amp;</span><br><span class="line">tsh&gt; <span class="built_in">fg</span> %1</span><br><span class="line">Job [1] (7361) stopped by signal 20</span><br><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br><span class="line">[1] (7361) Stopped ./myspin 4 &amp;</span><br><span class="line">tsh&gt; <span class="built_in">fg</span> %1</span><br><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br></pre></td></tr></table></figure>

<p>与参考一致，通关~</p>
<h3 id="test11-amp-test12-amp-test13"><a href="#test11-amp-test12-amp-test13" class="headerlink" title="test11 &amp; test12 &amp; test13"></a>test11 &amp; test12 &amp; test13</h3><p>先看看test11</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest11</span><br><span class="line">./sdriver.pl -t trace11.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace11.txt - Forward SIGINT to every process in foreground process group</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure>

<p>要求我们接收到SIGINT的时候把它发送给前台进程所处的进程组的所有进程。这个在我们前面的代码中的<code>sigint_handler</code>就已经有所处理了。</p>
<p>然后看看test12</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest12</span><br><span class="line">./sdriver.pl -t trace12.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace12.txt - Forward SIGTSTP to every process in foreground process group</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure>

<p>和测试11类似，我们接受到SIGTSTP的时候要把信号发给前台进程所处的进程组的所有进程。这个在<code>sigtstp_handler</code>就已经处理了。</p>
<p>再看看test13</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest13</span><br><span class="line">./sdriver.pl -t trace13.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace13.txt - Restart every stopped process in process group</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure>

<p>这个测试检测的是能够重启一个进程(原来是stopped状态)，这个功能在对于内置指令<code>fg</code>以及<code>bg</code>的处理上已经实现了。</p>
<blockquote>
<p>对于Linux下的ps命令a参数表示显示所有的进程</p>
<p>状态码：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Here are the different values that the s, <span class="built_in">stat</span> and state output specifiers (header <span class="string">&quot;STAT&quot;</span> or <span class="string">&quot;S&quot;</span>) will display to describe the state of a process:</span><br><span class="line"></span><br><span class="line">        D    uninterruptible <span class="built_in">sleep</span> (usually IO)</span><br><span class="line">        R    running or runnable (on run queue)</span><br><span class="line">        S    interruptible <span class="built_in">sleep</span> (waiting <span class="keyword">for</span> an event to complete)</span><br><span class="line">        T    stopped by job control signal</span><br><span class="line">        t    stopped by debugger during the tracing</span><br><span class="line">        W    paging (not valid since the 2.6.xx kernel)</span><br><span class="line">        X    dead (should never be seen)</span><br><span class="line">        Z    defunct (<span class="string">&quot;zombie&quot;</span>) process, terminated but not reaped by its parent</span><br><span class="line"></span><br><span class="line">For BSD formats and when the <span class="built_in">stat</span> keyword is used, additional characters may be displayed:</span><br><span class="line">        &lt;    high-priority (not <span class="built_in">nice</span> to other <span class="built_in">users</span>)</span><br><span class="line">        N    low-priority (<span class="built_in">nice</span> to other <span class="built_in">users</span>)</span><br><span class="line">        L    has pages locked into memory (<span class="keyword">for</span> real-time and custom IO)</span><br><span class="line">        s    is a session leader</span><br><span class="line">        l    is multi-threaded (using CLONE_THREAD, like NPTL pthreads <span class="keyword">do</span>)</span><br><span class="line">           +    is <span class="keyword">in</span> the foreground process group</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>我们直接对比测试结果</strong></p>
<ul>
<li><strong>test11</strong></li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest11</span><br><span class="line">./sdriver.pl -t trace11.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace11.txt - Forward SIGINT to every process in foreground process group</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./mysplit 4</span><br><span class="line">Job [1] (7419) terminated by signal 2</span><br><span class="line">tsh&gt; /bin/ps a</span><br><span class="line">  PID TTY      STAT   TIME COMMAND</span><br><span class="line"> 1190 tty4     Ss+    0:00 /sbin/getty -8 38400 tty4</span><br><span class="line"> 1197 tty5     Ss+    0:00 /sbin/getty -8 38400 tty5</span><br><span class="line"> 1207 tty2     Ss+    0:00 /sbin/getty -8 38400 tty2</span><br><span class="line"> 1209 tty3     Ss+    0:00 /sbin/getty -8 38400 tty3</span><br><span class="line"> 1230 tty6     Ss+    0:00 /sbin/getty -8 38400 tty6</span><br><span class="line"> 1352 tty7     Ss+   23:36 /usr/bin/X :0 -auth /var/run/lightdm/root/:0 -nolisten tcp vt7 -novtswitch -background none</span><br><span class="line"> 1785 tty1     Ss+    0:00 /sbin/getty -8 38400 tty1</span><br><span class="line"> 6865 pts/0    Ss     0:00 bash</span><br><span class="line"> 6971 pts/1    Ss+    0:00 /bin/bash</span><br><span class="line"> 7255 pts/0    R     39:18 ./tsh -p</span><br><span class="line"> 7256 pts/0    Z      0:00 [<span class="built_in">echo</span>] &lt;defunct&gt;</span><br><span class="line"> 7414 pts/0    S+     0:00 make rtest11</span><br><span class="line"> 7415 pts/0    S+     0:00 /bin/sh -c ./sdriver.pl -t trace11.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"> 7416 pts/0    S+     0:00 /usr/bin/perl ./sdriver.pl -t trace11.txt -s ./tshref -a -p</span><br><span class="line"> 7417 pts/0    S+     0:00 ./tshref -p</span><br><span class="line"> 7422 pts/0    R      0:00 /bin/ps a</span><br><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make test11</span><br><span class="line">./sdriver.pl -t trace11.txt -s ./tsh -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace11.txt - Forward SIGINT to every process in foreground process group</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./mysplit 4</span><br><span class="line">Job [1] (7433) terminated by signal 2</span><br><span class="line">tsh&gt; /bin/ps a</span><br><span class="line">  PID TTY      STAT   TIME COMMAND</span><br><span class="line"> 1190 tty4     Ss+    0:00 /sbin/getty -8 38400 tty4</span><br><span class="line"> 1197 tty5     Ss+    0:00 /sbin/getty -8 38400 tty5</span><br><span class="line"> 1207 tty2     Ss+    0:00 /sbin/getty -8 38400 tty2</span><br><span class="line"> 1209 tty3     Ss+    0:00 /sbin/getty -8 38400 tty3</span><br><span class="line"> 1230 tty6     Ss+    0:00 /sbin/getty -8 38400 tty6</span><br><span class="line"> 1352 tty7     Ss+   23:37 /usr/bin/X :0 -auth /var/run/lightdm/root/:0 -nolisten tcp vt7 -novtswitch -background none</span><br><span class="line"> 1785 tty1     Ss+    0:00 /sbin/getty -8 38400 tty1</span><br><span class="line"> 6865 pts/0    Ss     0:00 bash</span><br><span class="line"> 6971 pts/1    Ss+    0:00 /bin/bash</span><br><span class="line"> 7255 pts/0    R     39:26 ./tsh -p</span><br><span class="line"> 7256 pts/0    Z      0:00 [<span class="built_in">echo</span>] &lt;defunct&gt;</span><br><span class="line"> 7428 pts/0    S+     0:00 make test11</span><br><span class="line"> 7429 pts/0    S+     0:00 /bin/sh -c ./sdriver.pl -t trace11.txt -s ./tsh -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"> 7430 pts/0    S+     0:00 /usr/bin/perl ./sdriver.pl -t trace11.txt -s ./tsh -a -p</span><br><span class="line"> 7431 pts/0    R+     0:02 ./tsh -p</span><br><span class="line"> 7436 pts/0    R      0:00 /bin/ps a</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>test12</strong>和<strong>test13</strong>略（答案太长了）</li>
</ul>
<h3 id="test14"><a href="#test14" class="headerlink" title="test14"></a>test14</h3><p>这个测试需要对<code>fg</code>和<code>bg</code>的输入参数进行一些错误处理。例如没有参数或参数非数值或所选任务或进程不存在等。修改<code>do_bgfg</code>函数如。（&#x2F;* ADD PART *&#x2F;带有这个标签的就是增加的功能）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * do_bgfg - Execute the builtin bg and fg commands</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_bgfg</span><span class="params">(<span class="type">char</span>** argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">job_t</span>* <span class="title">job</span>;</span></span><br><span class="line">    <span class="type">char</span>* id = argv[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ADD PART bg和fg后边不跟任何参数不执行直接返回 */</span></span><br><span class="line">    <span class="comment">// no argument for bg/fg</span></span><br><span class="line">    <span class="keyword">if</span> (id == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s command requires PID or %%jobid argument\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 判断输入的是jid还是pid</span></span><br><span class="line">    <span class="keyword">if</span> (id[<span class="number">0</span>] == <span class="string">&#x27;%&#x27;</span>) &#123; <span class="comment">/* jid */</span></span><br><span class="line">        <span class="comment">/* ADD PART 检查输入的jid是不是数字 */</span></span><br><span class="line">        <span class="keyword">if</span> (!checkNum(id + <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s: argument must be a PID or %%jobid\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//去掉&#x27;%&#x27;开始读jid，根据jid返回这个子进程的结构指针</span></span><br><span class="line">        <span class="type">int</span> jid = atoi(id + <span class="number">1</span>);</span><br><span class="line">        job = getjobjid(jobs, jid);</span><br><span class="line">        <span class="comment">/* ADD PART 找不到输入的这个作业 */</span></span><br><span class="line">        <span class="keyword">if</span> (job == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%%%d: No such job\n&quot;</span>, jid);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;              <span class="comment">/* pid */</span></span><br><span class="line">        <span class="comment">/* ADD PART  检查输入的pid是不是数字 */</span></span><br><span class="line">        <span class="keyword">if</span> (!checkNum(id)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s: argument must be a PID or %%jobid\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> pid = atoi(id);</span><br><span class="line">        job = getjobpid(jobs, pid);</span><br><span class="line">        <span class="comment">/* ADD PART 找不到这个作业 */</span></span><br><span class="line">        <span class="keyword">if</span> (job == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;(%d): No such process\n&quot;</span>, pid);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    * kill不单是杀掉进程，还有发送信号的功能 </span></span><br><span class="line"><span class="comment">    * 这里唤醒job所在的组中的所有进程</span></span><br><span class="line"><span class="comment">    * 就是唤醒这个stopped的子进程，以及它派生的孙子进程</span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">    kill(-(job-&gt;pid), SIGCONT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;fg&quot;</span>)) &#123;  <span class="comment">// fg command</span></span><br><span class="line">        job-&gt;state = FG;</span><br><span class="line">        <span class="comment">// 等待该前台作业终止</span></span><br><span class="line">        waitfg(job-&gt;pid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;                         <span class="comment">// bg command</span></span><br><span class="line">        job-&gt;state = BG;</span><br><span class="line">        <span class="comment">/* 切换到bg后打印作业信息 */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%d] (%d) %s&quot;</span>, pid2jid(job-&gt;pid), job-&gt;pid, job-&gt;cmdline);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看参考输出</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest14</span><br><span class="line">./sdriver.pl -t trace14.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace14.txt - Simple error handling</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./bogus</span><br><span class="line">./bogus: Command not found</span><br><span class="line">tsh&gt; ./myspin 4 &amp;</span><br><span class="line">[1] (7521) ./myspin 4 &amp;</span><br><span class="line">tsh&gt; <span class="built_in">fg</span></span><br><span class="line"><span class="built_in">fg</span> <span class="built_in">command</span> requires PID or %jobid argument</span><br><span class="line">tsh&gt; <span class="built_in">bg</span></span><br><span class="line"><span class="built_in">bg</span> <span class="built_in">command</span> requires PID or %jobid argument</span><br><span class="line">tsh&gt; <span class="built_in">fg</span> a</span><br><span class="line"><span class="built_in">fg</span>: argument must be a PID or %jobid</span><br><span class="line">tsh&gt; <span class="built_in">bg</span> a</span><br><span class="line"><span class="built_in">bg</span>: argument must be a PID or %jobid</span><br><span class="line">tsh&gt; <span class="built_in">fg</span> 9999999</span><br><span class="line">(9999999): No such process</span><br><span class="line">tsh&gt; <span class="built_in">bg</span> 9999999</span><br><span class="line">(9999999): No such process</span><br><span class="line">tsh&gt; <span class="built_in">fg</span> %2</span><br><span class="line">%2: No such job</span><br><span class="line">tsh&gt; <span class="built_in">fg</span> %1</span><br><span class="line">Job [1] (7521) stopped by signal 20</span><br><span class="line">tsh&gt; <span class="built_in">bg</span> %2</span><br><span class="line">%2: No such job</span><br><span class="line">tsh&gt; <span class="built_in">bg</span> %1</span><br><span class="line">[1] (7521) ./myspin 4 &amp;</span><br><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br><span class="line">[1] (7521) Running ./myspin 4 &amp;</span><br><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make test14</span><br><span class="line">./sdriver.pl -t trace14.txt -s ./tsh -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace14.txt - Simple error handling</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./bogus</span><br><span class="line">tsh&gt; ./myspin 4 &amp;</span><br><span class="line">[1] (7540) ./myspin 4 &amp;</span><br><span class="line">tsh&gt; <span class="built_in">fg</span></span><br><span class="line"><span class="built_in">fg</span> <span class="built_in">command</span> requires PID or %jobid argument</span><br><span class="line">tsh&gt; <span class="built_in">bg</span></span><br><span class="line"><span class="built_in">bg</span> <span class="built_in">command</span> requires PID or %jobid argument</span><br><span class="line">tsh&gt; <span class="built_in">fg</span> a</span><br><span class="line"><span class="built_in">fg</span>: argument must be a PID or %jobid</span><br><span class="line">tsh&gt; <span class="built_in">bg</span> a</span><br><span class="line"><span class="built_in">bg</span>: argument must be a PID or %jobid</span><br><span class="line">tsh&gt; <span class="built_in">fg</span> 9999999</span><br><span class="line">(9999999): No such process</span><br><span class="line">tsh&gt; <span class="built_in">bg</span> 9999999</span><br><span class="line">(9999999): No such process</span><br><span class="line">tsh&gt; <span class="built_in">fg</span> %2</span><br><span class="line">%2: No such job</span><br><span class="line">tsh&gt; <span class="built_in">fg</span> %1</span><br><span class="line">Job [1] (7540) stopped by signal 20</span><br><span class="line">tsh&gt; <span class="built_in">bg</span> %2</span><br><span class="line">%2: No such job</span><br><span class="line">tsh&gt; <span class="built_in">bg</span> %1</span><br><span class="line">[1] (7540) ./myspin 4 &amp;</span><br><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br><span class="line">[1] (7540) Running ./myspin 4 &amp;</span><br></pre></td></tr></table></figure>

<p>对于输入的不合法的pid不是数字（例如44行）或者没有没有参数（42行）或者单纯没有这个pid（48行），都会进行处理并返回而不是崩溃。这个功能的晚上增强了<em>shell</em>的鲁棒性。</p>
<p>和参考基本一致，通关~</p>
<h3 id="test15-amp-test16"><a href="#test15-amp-test16" class="headerlink" title="test15 &amp; test16"></a>test15 &amp; test16</h3><p>我们看看测试的要求</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest15</span><br><span class="line">./sdriver.pl -t trace15.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace15.txt - Putting it all together</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure>

<p>测试15是要我们把所有的方法放在一起。这个都不要做，本来就在一个文件<code>tsh.c</code>下写的。。。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest16</span><br><span class="line">./sdriver.pl -t trace16.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace16.txt - Tests whether the shell can handle SIGTSTP and SIGINT</span></span><br><span class="line"><span class="comment">#     signals that come from other processes instead of the terminal.</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure>

<p>这个测试要我们测试<em>shell</em>收到SIGINT或者SIGTSTP的来源不是中断而是其他进程是否仍然能够正常工作。这个也不需要做什么。原因有二</p>
<ul>
<li>我们前面的<code>make testn</code>的时候，就是把我们的<code>tsh</code>作为<code>shell driver</code>的子进程，然后驱动给我们的<code>tsh</code>发送测试指令。其中就有SIGINT和SIGTSTP，我们能过够通过前面的，肯定是对的。</li>
<li>我们的<code>tsh</code>至始至终实现对的都是收到信号，然后对自己的孩子怎么处理。至于如何接受外部信号，是从中断收到还是其他的进程收到，我们实验过程中虽然没有关注到。但是我们在从unix的<em>shell</em>输入“.&#x2F;tsh”之后进入到<em>tsh</em>。<ul>
<li>这个过程是内核捕捉到SIGINT等信号发送给我们的unix shell，然后unix shell会把这些信号有发送给tsh，然后tsh又把它发送给子进程们。</li>
<li>关系如下图。</li>
</ul>
</li>
</ul>
<img src="/2022/05/26/CSAPP-shlab-report/image-20220526221432408.png" alt="image-20220526221432408" style="zoom:80%;">

<p>还有一个小知识点：参考<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/5422831/what-is-the-difference-between-using-exit-exit-in-a-conventional-linux-fo">exit与_exit的区别</a>，可以知道<strong>在fork出的child中要用_exit来退出</strong>，否则exit会调用用atexit注册的函数并刷新父进程的缓冲区。一般来说在一个main函数中只调用一次exit或return。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in `eval`</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">/* </span></span><br><span class="line"><span class="comment">            * 前台执行 </span></span><br><span class="line"><span class="comment">            * 如果没有这个可执行程序，那么直接终止这个子进程</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">if</span> (execve(argv[<span class="number">0</span>], argv, environ) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s: Command not found.\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">                _exit(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>





<h3 id="tsh-c文件综合"><a href="#tsh-c文件综合" class="headerlink" title="tsh.c文件综合"></a>tsh.c文件综合</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * tsh - A tiny shell program with job control</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;Puitar&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Misc manifest constants */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLINE    1024   <span class="comment">/* max line size */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXARGS     128   <span class="comment">/* max args on a command line */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXJOBS      16   <span class="comment">/* max jobs at any point in time */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXJID    1&lt;&lt;16   <span class="comment">/* max job ID */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Job states */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNDEF 0 <span class="comment">/* undefined */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FG 1    <span class="comment">/* running in foreground */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BG 2    <span class="comment">/* running in background */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ST 3    <span class="comment">/* stopped */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Jobs states: FG (foreground), BG (background), ST (stopped)</span></span><br><span class="line"><span class="comment"> * Job state transitions and enabling actions:</span></span><br><span class="line"><span class="comment"> *     FG -&gt; ST  : ctrl-z</span></span><br><span class="line"><span class="comment"> *     ST -&gt; FG  : fg command</span></span><br><span class="line"><span class="comment"> *     ST -&gt; BG  : bg command</span></span><br><span class="line"><span class="comment"> *     BG -&gt; FG  : fg command</span></span><br><span class="line"><span class="comment"> * At most 1 job can be in the FG state.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Global variables */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span>** environ;      <span class="comment">/* defined in libc */</span></span><br><span class="line"><span class="type">char</span> prompt[] = <span class="string">&quot;tsh&gt; &quot;</span>;    <span class="comment">/* command line prompt (DO NOT CHANGE) */</span></span><br><span class="line"><span class="type">int</span> verbose = <span class="number">0</span>;            <span class="comment">/* if true, print additional output */</span></span><br><span class="line"><span class="type">int</span> nextjid = <span class="number">1</span>;            <span class="comment">/* next job ID to allocate */</span></span><br><span class="line"><span class="type">char</span> sbuf[MAXLINE];         <span class="comment">/* for composing sprintf messages */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> &#123;</span>              <span class="comment">/* The job struct */</span></span><br><span class="line">    <span class="type">pid_t</span> pid;              <span class="comment">/* job PID */</span></span><br><span class="line">    <span class="type">int</span> jid;                <span class="comment">/* job ID [1, 2, ...] */</span></span><br><span class="line">    <span class="type">int</span> state;              <span class="comment">/* UNDEF, BG, FG, or ST */</span></span><br><span class="line">    <span class="type">char</span> cmdline[MAXLINE];  <span class="comment">/* command line */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> <span class="title">jobs</span>[<span class="title">MAXJOBS</span>];</span> <span class="comment">/* The job list */</span></span><br><span class="line"><span class="comment">/* End global variables */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Function prototypes */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Here are the functions that you will implement */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">eval</span><span class="params">(<span class="type">char</span>* cmdline)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">builtin_cmd</span><span class="params">(<span class="type">char</span>** argv)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">do_bgfg</span><span class="params">(<span class="type">char</span>** argv)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">waitfg</span><span class="params">(<span class="type">pid_t</span> pid)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sigchld_handler</span><span class="params">(<span class="type">int</span> sig)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sigtstp_handler</span><span class="params">(<span class="type">int</span> sig)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sigint_handler</span><span class="params">(<span class="type">int</span> sig)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Here are helper routines that we&#x27;ve provided for you */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">parseline</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* cmdline, <span class="type">char</span>** argv)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sigquit_handler</span><span class="params">(<span class="type">int</span> sig)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">clearjob</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span>* job)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">initjobs</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span>* jobs)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">maxjid</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span>* jobs)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">addjob</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span>* jobs, <span class="type">pid_t</span> pid, <span class="type">int</span> state, <span class="type">char</span>* cmdline)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">deletejob</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span>* jobs, <span class="type">pid_t</span> pid)</span>;</span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fgpid</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span>* jobs)</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="type">job_t</span>* <span class="title function_">getjobpid</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span>* jobs, <span class="type">pid_t</span> pid)</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="type">job_t</span>* <span class="title function_">getjobjid</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span>* jobs, <span class="type">int</span> jid)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pid2jid</span><span class="params">(<span class="type">pid_t</span> pid)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">listjobs</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span>* jobs)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">usage</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">unix_error</span><span class="params">(<span class="type">char</span>* msg)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">app_error</span><span class="params">(<span class="type">char</span>* msg)</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> <span class="title function_">handler_t</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">handler_t</span>* <span class="title function_">Signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">handler_t</span>* handler)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// wrapper functions get from csapp.h</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Sigprocmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span>* <span class="built_in">set</span>, <span class="type">sigset_t</span>* oldset)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Sigemptyset</span><span class="params">(<span class="type">sigset_t</span>* <span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Sigaddset</span><span class="params">(<span class="type">sigset_t</span>* <span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sio package declaration from csapp.h</span></span><br><span class="line"><span class="comment">/* Sio (Signal-safe I/O) routines */</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">sio_puts</span><span class="params">(<span class="type">char</span> s[])</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">sio_putl</span><span class="params">(<span class="type">long</span> v)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sio_error</span><span class="params">(<span class="type">char</span> s[])</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Sio wrappers */</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">Sio_puts</span><span class="params">(<span class="type">char</span> s[])</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">Sio_putl</span><span class="params">(<span class="type">long</span> v)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Sio_error</span><span class="params">(<span class="type">char</span> s[])</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * main - The shell&#x27;s main routine</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">char</span> cmdline[MAXLINE];</span><br><span class="line">    <span class="type">int</span> emit_prompt = <span class="number">1</span>; <span class="comment">/* emit prompt (default) */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Redirect stderr to stdout (so that driver will get all output</span></span><br><span class="line"><span class="comment">     * on the pipe connected to stdout) */</span></span><br><span class="line">    dup2(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Parse the command line */</span></span><br><span class="line">    <span class="keyword">while</span> ((c = getopt(argc, argv, <span class="string">&quot;hvp&quot;</span>)) != EOF) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:             <span class="comment">/* print help message */</span></span><br><span class="line">                usage();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;v&#x27;</span>:             <span class="comment">/* emit additional diagnostic info */</span></span><br><span class="line">                verbose = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;p&#x27;</span>:             <span class="comment">/* don&#x27;t print a prompt */</span></span><br><span class="line">                emit_prompt = <span class="number">0</span>;  <span class="comment">/* handy for automatic testing */</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                usage();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Install the signal handlers */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* These are the ones you will need to implement */</span></span><br><span class="line">    Signal(SIGINT, sigint_handler);   <span class="comment">/* ctrl-c */</span></span><br><span class="line">    Signal(SIGTSTP, sigtstp_handler);  <span class="comment">/* ctrl-z */</span></span><br><span class="line">    Signal(SIGCHLD, sigchld_handler);  <span class="comment">/* Terminated or stopped child */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This one provides a clean way to kill the shell */</span></span><br><span class="line">    Signal(SIGQUIT, sigquit_handler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initialize the job list */</span></span><br><span class="line">    initjobs(jobs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Execute the shell&#x27;s read/eval loop */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Read command line */</span></span><br><span class="line">        <span class="keyword">if</span> (emit_prompt) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, prompt);</span><br><span class="line">            fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((fgets(cmdline, MAXLINE, <span class="built_in">stdin</span>) == <span class="literal">NULL</span>) &amp;&amp; ferror(<span class="built_in">stdin</span>))</span><br><span class="line">            app_error(<span class="string">&quot;fgets error&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (feof(<span class="built_in">stdin</span>)) &#123; <span class="comment">/* End of file (ctrl-d) */</span></span><br><span class="line">            fflush(<span class="built_in">stdout</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Evaluate the command line */</span></span><br><span class="line">        eval(cmdline);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">/* control never reaches here */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * eval - Evaluate the command line that the user has just typed in</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If the user has requested a built-in command (quit, jobs, bg or fg)</span></span><br><span class="line"><span class="comment"> * then execute it immediately. Otherwise, fork a child process and</span></span><br><span class="line"><span class="comment"> * run the job in the context of the child. If the job is running in</span></span><br><span class="line"><span class="comment"> * the foreground, wait for it to terminate and then return.  Note:</span></span><br><span class="line"><span class="comment"> * each child process must have a unique process group ID so that our</span></span><br><span class="line"><span class="comment"> * background children don&#x27;t receive SIGINT (SIGTSTP) from the kernel</span></span><br><span class="line"><span class="comment"> * when we type ctrl-c (ctrl-z) at the keyboard.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">eval</span><span class="params">(<span class="type">char</span>* cmdline)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>* argv[MAXARGS]; <span class="comment">/* argv for execve() */</span></span><br><span class="line">    <span class="type">int</span> bg;              <span class="comment">/* Should the job run in bg or fg? */</span></span><br><span class="line">    <span class="type">pid_t</span> pid;           <span class="comment">/* Process id */</span></span><br><span class="line">    <span class="type">sigset_t</span> mask, prev;</span><br><span class="line"></span><br><span class="line">    bg = parseline(cmdline, argv);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (argv[<span class="number">0</span>] == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;   <span class="comment">/* Ignore empty lines */</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 这里参考课本520的方法</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * sigemptyset是设置一个信号集</span></span><br><span class="line"><span class="comment">    * sigaddset是向mask中添加SIGCHLD信号</span></span><br><span class="line"><span class="comment">    * sigprocmask是保存现在的信号集到prev然后根据第一个参数设置信号集为mask</span></span><br><span class="line"><span class="comment">    *	第二个参数设置成当前阻塞信号集合</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    Sigemptyset(&amp;mask);</span><br><span class="line">    Sigaddset(&amp;mask, SIGCHLD);</span><br><span class="line">	</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!builtin_cmd(argv)) &#123;</span><br><span class="line">        Sigprocmask(SIG_BLOCK, &amp;mask, &amp;prev);  <span class="comment">/* 阻塞SIGCHLD */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((pid = fork()) == <span class="number">0</span>) &#123;   <span class="comment">/* Child runs user job */</span></span><br><span class="line">            <span class="comment">/* 给fork出来的子进程设置一个独立的组，</span></span><br><span class="line"><span class="comment">	 		 * 子进程是这个组的组长,组id为子进程的pid */</span></span><br><span class="line">            setpgid(<span class="number">0</span>, <span class="number">0</span>);	</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/* 对于子进程并不需要阻塞SIGCHLD的信号 */</span></span><br><span class="line">            Sigprocmask(SIG_UNBLOCK, &amp;prev, <span class="literal">NULL</span>);  <span class="comment">// unblock SIGCHLD</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">/* </span></span><br><span class="line"><span class="comment">            * 前台执行 </span></span><br><span class="line"><span class="comment">            * 如果没有这个可执行程序，那么直接终止这个子进程</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">if</span> (execve(argv[<span class="number">0</span>], argv, environ) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s: Command not found.\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">                _exit(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        addjob(jobs, pid, bg ? BG : FG, cmdline);</span><br><span class="line">        <span class="comment">/* 已经加到jobs了，解除阻塞 */</span></span><br><span class="line">        Sigprocmask(SIG_SETMASK, &amp;prev, <span class="literal">NULL</span>);  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Parent waits for foreground job to terminate */</span></span><br><span class="line">        <span class="keyword">if</span> (!bg)  <span class="comment">// 前台运行则等待子进程</span></span><br><span class="line">            waitfg(pid);</span><br><span class="line">        <span class="keyword">else</span>      <span class="comment">// background</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[%d] (%d) %s&quot;</span>, pid2jid(pid), pid, cmdline);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * parseline - Parse the command line and build the argv array.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Characters enclosed in single quotes are treated as a single</span></span><br><span class="line"><span class="comment"> * argument.  Return true if the user has requested a BG job, false if</span></span><br><span class="line"><span class="comment"> * the user has requested a FG job.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">parseline</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* cmdline, <span class="type">char</span>** argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> <span class="built_in">array</span>[MAXLINE]; <span class="comment">/* holds local copy of command line */</span></span><br><span class="line">    <span class="type">char</span>* buf = <span class="built_in">array</span>;          <span class="comment">/* ptr that traverses command line */</span></span><br><span class="line">    <span class="type">char</span>* delim;                <span class="comment">/* points to first space delimiter */</span></span><br><span class="line">    <span class="type">int</span> argc;                   <span class="comment">/* number of args */</span></span><br><span class="line">    <span class="type">int</span> bg;                     <span class="comment">/* background job? */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(buf, cmdline);</span><br><span class="line">    buf[<span class="built_in">strlen</span>(buf) - <span class="number">1</span>] = <span class="string">&#x27; &#x27;</span>;  <span class="comment">/* replace trailing &#x27;\n&#x27; with space */</span></span><br><span class="line">    <span class="keyword">while</span> (*buf &amp;&amp; (*buf == <span class="string">&#x27; &#x27;</span>)) <span class="comment">/* ignore leading spaces */</span></span><br><span class="line">        buf++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Build the argv list */</span></span><br><span class="line">    argc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (*buf == <span class="string">&#x27;\&#x27;&#x27;</span>) &#123;</span><br><span class="line">        buf++;</span><br><span class="line">        delim = <span class="built_in">strchr</span>(buf, <span class="string">&#x27;\&#x27;&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        delim = <span class="built_in">strchr</span>(buf, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (delim) &#123;</span><br><span class="line">        argv[argc++] = buf;</span><br><span class="line">        *delim = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        buf = delim + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (*buf &amp;&amp; (*buf == <span class="string">&#x27; &#x27;</span>)) <span class="comment">/* ignore spaces */</span></span><br><span class="line">            buf++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (*buf == <span class="string">&#x27;\&#x27;&#x27;</span>) &#123;</span><br><span class="line">            buf++;</span><br><span class="line">            delim = <span class="built_in">strchr</span>(buf, <span class="string">&#x27;\&#x27;&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            delim = <span class="built_in">strchr</span>(buf, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    argv[argc] = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">0</span>)  <span class="comment">/* ignore blank line */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* should the job run in the background? */</span></span><br><span class="line">    <span class="keyword">if</span> ((bg = (*argv[argc - <span class="number">1</span>] == <span class="string">&#x27;&amp;&#x27;</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">        argv[--argc] = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * builtin_cmd - If the user has typed a built-in command then execute</span></span><br><span class="line"><span class="comment"> *    it immediately.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">builtin_cmd</span><span class="params">(<span class="type">char</span>** argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// quit command</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;quit&quot;</span>))</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// jobs command</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;jobs&quot;</span>)) &#123;</span><br><span class="line">        listjobs(jobs);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bg or fg command</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;bg&quot;</span>) || !<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;fg&quot;</span>)) &#123;</span><br><span class="line">        do_bgfg(argv);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ignore singleton &amp; (不处理单独的 &#x27;&amp;&#x27;)</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;&amp;&quot;</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// not a build-in command</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// check if arg is a string of nums</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">checkNum</span><span class="params">(<span class="type">char</span>* arg)</span> &#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(arg);</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">isdigit</span>(arg[i])) <span class="comment">// not num</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * do_bgfg - Execute the builtin bg and fg commands</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_bgfg</span><span class="params">(<span class="type">char</span>** argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">job_t</span>* <span class="title">job</span>;</span></span><br><span class="line">    <span class="type">char</span>* id = argv[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// no argument for bg/fg</span></span><br><span class="line">    <span class="keyword">if</span> (id == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s command requires PID or %%jobid argument\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 判断输入的是jid还是pid</span></span><br><span class="line">    <span class="keyword">if</span> (id[<span class="number">0</span>] == <span class="string">&#x27;%&#x27;</span>) &#123; <span class="comment">/* jid */</span></span><br><span class="line">        <span class="keyword">if</span> (!checkNum(id + <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s: argument must be a PID or %%jobid\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//去掉&#x27;%&#x27;开始读jid，根据jid返回这个子进程的结构指针</span></span><br><span class="line">        <span class="type">int</span> jid = atoi(id + <span class="number">1</span>);</span><br><span class="line">        job = getjobjid(jobs, jid);</span><br><span class="line">        <span class="keyword">if</span> (job == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%%%d: No such job\n&quot;</span>, jid);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;              <span class="comment">/* pid */</span></span><br><span class="line">        <span class="keyword">if</span> (!checkNum(id)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s: argument must be a PID or %%jobid\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> pid = atoi(id);</span><br><span class="line">        job = getjobpid(jobs, pid);</span><br><span class="line">        <span class="keyword">if</span> (job == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;(%d): No such process\n&quot;</span>, pid);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    * kill不单是杀掉进程，还有发送信号的功能 </span></span><br><span class="line"><span class="comment">    * 这里唤醒job所在的组中的所有进程</span></span><br><span class="line"><span class="comment">    * 就是唤醒这个stopped的子进程，以及它派生的孙子进程</span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">    kill(-(job-&gt;pid), SIGCONT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;fg&quot;</span>)) &#123;  <span class="comment">// fg command</span></span><br><span class="line">        job-&gt;state = FG;</span><br><span class="line">        <span class="comment">// 等待该前台作业终止</span></span><br><span class="line">        waitfg(job-&gt;pid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;                         <span class="comment">// bg command</span></span><br><span class="line">        job-&gt;state = BG;</span><br><span class="line">        <span class="comment">/* 切换到bg后打印作业信息 */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%d] (%d) %s&quot;</span>, pid2jid(job-&gt;pid), job-&gt;pid, job-&gt;cmdline);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * waitfg - Block until process pid is no longer the foreground process</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">waitfg</span><span class="params">(<span class="type">pid_t</span> pid)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (pid == fgpid(jobs))</span><br><span class="line">        sleep(<span class="number">0</span>); <span class="comment">// 这里是主动让出CPU</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*****************</span></span><br><span class="line"><span class="comment"> * Signal handlers</span></span><br><span class="line"><span class="comment"> *****************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sigchld_handler - The kernel sends a SIGCHLD to the shell whenever</span></span><br><span class="line"><span class="comment"> *     a child job terminates (becomes a zombie), or stops because it</span></span><br><span class="line"><span class="comment"> *     received a SIGSTOP or SIGTSTP signal. The handler reaps all</span></span><br><span class="line"><span class="comment"> *     available zombie children, but doesn&#x27;t wait for any other</span></span><br><span class="line"><span class="comment"> *     currently running children to terminate.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sigchld_handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> old_errno = errno;</span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (verbose)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sigchld_handler: entering \n&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* </span></span><br><span class="line"><span class="comment">    * 回收僵尸进程</span></span><br><span class="line"><span class="comment">    * 这里的WNOHANG是非常重要的。</span></span><br><span class="line"><span class="comment">    * 它的本意是如果所有孩子都没有僵尸(终止)状态的，直接退出</span></span><br><span class="line"><span class="comment">    * 这个能够避免在这里等待所有前台的running和stopped程序终止</span></span><br><span class="line"><span class="comment">    * 这样tsh就不能正常接受用户的输入了</span></span><br><span class="line"><span class="comment">    * WUNTRACED是等待直到有一个子进程变成僵尸退出，返回它的pid</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">while</span> ((pid = waitpid(<span class="number">-1</span>, &amp;status, WNOHANG | WUNTRACED)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程正常退出</span></span><br><span class="line">        <span class="keyword">if</span> (WIFEXITED(status)) &#123;</span><br><span class="line">            deletejob(jobs, pid);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 子进程因为ctrl-c退出</span></span><br><span class="line">        <span class="keyword">if</span> (WIFSIGNALED(status)) &#123; <span class="comment">// terminated by ctrl-c</span></span><br><span class="line">            <span class="comment">/* printf(&quot;Job [%d] (%d) terminated by signal %2d\n&quot;, </span></span><br><span class="line"><span class="comment">                   pid2jid(pid), pid, WTERMSIG(status)); */</span> &#123;</span><br><span class="line">            	Sio_puts(<span class="string">&quot;Job [&quot;</span>);</span><br><span class="line">                Sio_putl(pid2jid(pid));</span><br><span class="line">                Sio_puts(<span class="string">&quot;] (&quot;</span>);</span><br><span class="line">                Sio_putl(pid);</span><br><span class="line">                Sio_puts(<span class="string">&quot;) terminated by signal &quot;</span>);</span><br><span class="line">                Sio_putl(WTERMSIG(status));</span><br><span class="line">                Sio_puts(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            deletejob(jobs, pid); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (WIFSTOPPED(status)) &#123; <span class="comment">// stopped by ctrl-z</span></span><br><span class="line">            <span class="comment">/* printf(&quot;Job [%d] (%d) stopped by signal %2d\n&quot;,</span></span><br><span class="line"><span class="comment">                   pid2jid(pid), pid, WSTOPSIG(status)); */</span> &#123;</span><br><span class="line">            	Sio_puts(<span class="string">&quot;Job [&quot;</span>);</span><br><span class="line">                Sio_putl(pid2jid(pid));</span><br><span class="line">                Sio_puts(<span class="string">&quot;] (&quot;</span>);</span><br><span class="line">                Sio_putl(pid);</span><br><span class="line">                Sio_puts(<span class="string">&quot;) stopped by signal &quot;</span>);</span><br><span class="line">                Sio_putl(WSTOPSIG(status));</span><br><span class="line">                Sio_puts(<span class="string">&quot;\n&quot;</span>);           </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 修改子进程状态为ST</span></span><br><span class="line">            getjobpid(jobs, pid)-&gt;state = ST;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    errno = old_errno;</span><br><span class="line">    <span class="keyword">if</span> (verbose) &#123;</span><br><span class="line">        <span class="comment">/* printf(&quot;sigchld_handler: exiting\n&quot;); */</span> &#123;</span><br><span class="line">        	Sio_puts(<span class="string">&quot;sigchld_handler: exiting\n&quot;</span>);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;      </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sigint_handler - The kernel sends a SIGINT to the shell whenver the</span></span><br><span class="line"><span class="comment"> *    user types ctrl-c at the keyboard.  Catch it and send it along</span></span><br><span class="line"><span class="comment"> *    to the foreground job.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sigint_handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> olderrno = errno;</span><br><span class="line">    <span class="comment">// get the foreground job pid</span></span><br><span class="line">    <span class="type">pid_t</span> fg_pid = fgpid(jobs);</span><br><span class="line">    <span class="comment">// kill the group in the foreground</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * int kill(pid_t pid,int signo)</span></span><br><span class="line"><span class="comment"> 	* 功能: 向进程或进程组发送一个信号 （成功返回 0； 否则，返回 -1 ）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    kill(-fg_pid, sig); </span><br><span class="line">    <span class="comment">// -fg_pid表示向进程组号为pid的组中的每个进程发sig信号</span></span><br><span class="line">    <span class="comment">// 在这里就是向前台进程以及它的每一个子进程(子进程都在自己的父进程的pid为组id的组下)</span></span><br><span class="line">    errno = olderrno;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sigtstp_handler - The kernel sends a SIGTSTP to the shell whenever</span></span><br><span class="line"><span class="comment"> *     the user types ctrl-z at the keyboard. Catch it and suspend the</span></span><br><span class="line"><span class="comment"> *     foreground job by sending it a SIGTSTP.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sigtstp_handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 为了异步信号安全防止errno被覆盖</span></span><br><span class="line">    <span class="type">int</span> olderrno = errno;</span><br><span class="line">    <span class="comment">// get the foreground job pid</span></span><br><span class="line">    <span class="type">pid_t</span> fg_pid = fgpid(jobs);</span><br><span class="line">    <span class="comment">// kill the group in the foreground</span></span><br><span class="line">    kill(-fg_pid, sig);</span><br><span class="line">    errno = olderrno;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********************</span></span><br><span class="line"><span class="comment"> * End signal handlers</span></span><br><span class="line"><span class="comment"> *********************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************************************</span></span><br><span class="line"><span class="comment">  * Helper routines that manipulate the job list</span></span><br><span class="line"><span class="comment">  **********************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* clearjob - Clear the entries in a job struct */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">clearjob</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span>* job)</span> &#123;</span><br><span class="line">    job-&gt;pid = <span class="number">0</span>;</span><br><span class="line">    job-&gt;jid = <span class="number">0</span>;</span><br><span class="line">    job-&gt;state = UNDEF;</span><br><span class="line">    job-&gt;cmdline[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* initjobs - Initialize the job list */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">initjobs</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span>* jobs)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++)</span><br><span class="line">        clearjob(&amp;jobs[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* maxjid - Returns largest allocated job ID */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">maxjid</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span>* jobs)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, max = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++)</span><br><span class="line">        <span class="keyword">if</span> (jobs[i].jid &gt; max)</span><br><span class="line">            max = jobs[i].jid;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* addjob - Add a job to the job list */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">addjob</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span>* jobs, <span class="type">pid_t</span> pid, <span class="type">int</span> state, <span class="type">char</span>* cmdline)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++) &#123;</span><br><span class="line">        <span class="comment">/* 如果jobs数组里面有pid等于0等于0的表项，表示这个位置可以用，把这个作业放进去 */</span></span><br><span class="line">        <span class="keyword">if</span> (jobs[i].pid == <span class="number">0</span>) &#123;</span><br><span class="line">            jobs[i].pid = pid;</span><br><span class="line">            jobs[i].state = state;</span><br><span class="line">            jobs[i].jid = nextjid++;</span><br><span class="line">            <span class="keyword">if</span> (nextjid &gt; MAXJOBS)</span><br><span class="line">                nextjid = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">strcpy</span>(jobs[i].cmdline, cmdline);</span><br><span class="line">            <span class="keyword">if</span> (verbose) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Added job [%d] %d %s\n&quot;</span>, jobs[i].jid, jobs[i].pid, jobs[i].cmdline);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Tried to create too many jobs\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* deletejob - Delete a job whose PID=pid from the job list */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">deletejob</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span>* jobs, <span class="type">pid_t</span> pid)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (jobs[i].pid == pid) &#123;</span><br><span class="line">            clearjob(&amp;jobs[i]);</span><br><span class="line">            nextjid = maxjid(jobs) + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* fgpid - Return PID of current foreground job, 0 if no such job */</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fgpid</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span>* jobs)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++)</span><br><span class="line">        <span class="keyword">if</span> (jobs[i].state == FG)</span><br><span class="line">            <span class="keyword">return</span> jobs[i].pid;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* getjobpid  - Find a job (by PID) on the job list */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="type">job_t</span>* <span class="title function_">getjobpid</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span>* jobs, <span class="type">pid_t</span> pid)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++)</span><br><span class="line">        <span class="keyword">if</span> (jobs[i].pid == pid)</span><br><span class="line">            <span class="keyword">return</span> &amp;jobs[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* getjobjid  - Find a job (by JID) on the job list */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="type">job_t</span>* <span class="title function_">getjobjid</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span>* jobs, <span class="type">int</span> jid)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (jid &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++)</span><br><span class="line">        <span class="keyword">if</span> (jobs[i].jid == jid)</span><br><span class="line">            <span class="keyword">return</span> &amp;jobs[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* pid2jid - Map process ID to job ID */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pid2jid</span><span class="params">(<span class="type">pid_t</span> pid)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++)</span><br><span class="line">        <span class="keyword">if</span> (jobs[i].pid == pid) &#123;</span><br><span class="line">            <span class="keyword">return</span> jobs[i].jid;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* listjobs - Print the job list */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">listjobs</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span>* jobs)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (jobs[i].pid != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[%d] (%d) &quot;</span>, jobs[i].jid, jobs[i].pid);</span><br><span class="line">            <span class="keyword">switch</span> (jobs[i].state) &#123;</span><br><span class="line">                <span class="keyword">case</span> BG:</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Running &quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> FG:</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Foreground &quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> ST:</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Stopped &quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;listjobs: Internal error: job[%d].state=%d &quot;</span>,</span><br><span class="line">                           i, jobs[i].state);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, jobs[i].cmdline);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment"> * end job list helper routines</span></span><br><span class="line"><span class="comment"> ******************************/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************</span></span><br><span class="line"><span class="comment">  * Other helper routines</span></span><br><span class="line"><span class="comment">  ***********************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   * usage - print a help message</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">usage</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Usage: shell [-hvp]\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;   -h   print this message\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;   -v   print additional diagnostic information\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;   -p   do not emit a command prompt\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * unix_error - unix-style error routine</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">unix_error</span><span class="params">(<span class="type">char</span>* msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;%s: %s\n&quot;</span>, msg, strerror(errno));</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * app_error - application-style error routine</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">app_error</span><span class="params">(<span class="type">char</span>* msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;%s\n&quot;</span>, msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Signal - wrapper for the sigaction function</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">handler_t</span>* <span class="title function_">Signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">handler_t</span>* handler)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">action</span>, <span class="title">old_action</span>;</span></span><br><span class="line"></span><br><span class="line">    action.sa_handler = handler;</span><br><span class="line">    sigemptyset(&amp;action.sa_mask); <span class="comment">/* block sigs of type being handled */</span></span><br><span class="line">    action.sa_flags = SA_RESTART; <span class="comment">/* restart syscalls if possible */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sigaction(signum, &amp;action, &amp;old_action) &lt; <span class="number">0</span>)</span><br><span class="line">        unix_error(<span class="string">&quot;Signal error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> (old_action.sa_handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sigquit_handler - The driver program can gracefully terminate the</span></span><br><span class="line"><span class="comment"> *    child shell by sending it a SIGQUIT signal.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sigquit_handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Terminating after receipt of SIGQUIT signal\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// The following function are from csapp.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment"> * Wrappers for blocking signals</span></span><br><span class="line"><span class="comment"> *************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Sigemptyset</span><span class="params">(<span class="type">sigset_t</span>* <span class="built_in">set</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (sigemptyset(<span class="built_in">set</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        unix_error(<span class="string">&quot;Sigemptyset error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Sigprocmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span>* <span class="built_in">set</span>, <span class="type">sigset_t</span>* oldset)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (sigprocmask(how, <span class="built_in">set</span>, oldset) &lt; <span class="number">0</span>)</span><br><span class="line">        unix_error(<span class="string">&quot;Sigprocmask error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Sigaddset</span><span class="params">(<span class="type">sigset_t</span>* <span class="built_in">set</span>, <span class="type">int</span> signum)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (sigaddset(<span class="built_in">set</span>, signum) &lt; <span class="number">0</span>)</span><br><span class="line">        unix_error(<span class="string">&quot;Sigaddset error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment"> * The Sio (Signal-safe I/O) package - simple reentrant output</span></span><br><span class="line"><span class="comment"> * functions that are safe for signal handlers.</span></span><br><span class="line"><span class="comment"> *************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Private sio functions */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* $begin sioprivate */</span></span><br><span class="line"><span class="comment">/* sio_reverse - Reverse a string (from K&amp;R) */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sio_reverse</span><span class="params">(<span class="type">char</span> s[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> c, i, j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, j = <span class="built_in">strlen</span>(s) - <span class="number">1</span>; i &lt; j; i++, j--) &#123;</span><br><span class="line">        c = s[i];</span><br><span class="line">        s[i] = s[j];</span><br><span class="line">        s[j] = c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* sio_ltoa - Convert long to base b string (from K&amp;R) */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sio_ltoa</span><span class="params">(<span class="type">long</span> v, <span class="type">char</span> s[], <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> c, i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> neg = v &lt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (neg)</span><br><span class="line">        v = -v;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        s[i++] = ((c = (v % b)) &lt; <span class="number">10</span>) ? c + <span class="string">&#x27;0&#x27;</span> : c - <span class="number">10</span> + <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> ((v /= b) &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (neg)</span><br><span class="line">        s[i++] = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    s[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    sio_reverse(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* sio_strlen - Return length of string (from K&amp;R) */</span></span><br><span class="line"><span class="type">static</span> <span class="type">size_t</span> <span class="title function_">sio_strlen</span><span class="params">(<span class="type">char</span> s[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (s[i] != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">        ++i;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* $end sioprivate */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Public Sio functions */</span></span><br><span class="line"><span class="comment">/* $begin siopublic */</span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">sio_puts</span><span class="params">(<span class="type">char</span> s[])</span> <span class="comment">/* Put string */</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> write(STDOUT_FILENO, s, sio_strlen(s)); <span class="comment">//line:csapp:siostrlen</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">sio_putl</span><span class="params">(<span class="type">long</span> v)</span> <span class="comment">/* Put long */</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> s[<span class="number">128</span>];</span><br><span class="line"></span><br><span class="line">    sio_ltoa(v, s, <span class="number">10</span>); <span class="comment">/* Based on K&amp;R itoa() */</span>  <span class="comment">//line:csapp:sioltoa</span></span><br><span class="line">    <span class="keyword">return</span> sio_puts(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sio_error</span><span class="params">(<span class="type">char</span> s[])</span> <span class="comment">/* Put error message and exit */</span></span><br><span class="line">&#123;</span><br><span class="line">    sio_puts(s);</span><br><span class="line">    _exit(<span class="number">1</span>);                                      <span class="comment">//line:csapp:sioexit</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* $end siopublic */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************************</span></span><br><span class="line"><span class="comment"> * Wrappers for the SIO routines</span></span><br><span class="line"><span class="comment"> ******************************/</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">Sio_putl</span><span class="params">(<span class="type">long</span> v)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">ssize_t</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((n = sio_putl(v)) &lt; <span class="number">0</span>)</span><br><span class="line">        sio_error(<span class="string">&quot;Sio_putl error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">Sio_puts</span><span class="params">(<span class="type">char</span> s[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">ssize_t</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((n = sio_puts(s)) &lt; <span class="number">0</span>)</span><br><span class="line">        sio_error(<span class="string">&quot;Sio_puts error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Sio_error</span><span class="params">(<span class="type">char</span> s[])</span></span><br><span class="line">&#123;</span><br><span class="line">    sio_error(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h2><p>通过这次实验，才算是比较彻底理解了，信号的相关知识。</p>
<ul>
<li>包括信号的发送和捕捉</li>
<li>异步的思考方式</li>
<li>信号的阻塞</li>
<li>拓展：异步安全问题</li>
<li>信号处理程序的编写和使用</li>
<li><code>signal</code>函数和<code>kill</code>以及相关的函数的使用等</li>
</ul>
<p>这个是本课程最后一个实验的，综合难度并不是最大的。但是是知识体系最为复杂的。总的来说非常喜欢这门课的实验。做完之后能够感觉到和知识的紧密连接。感谢陪伴~</p>

    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/CSAPP/" rel="tag"><i class="fa fa-tag"></i> CSAPP</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/05/19/OS-thread-homework/" rel="prev" title="OS-thread-homework">
      <i class="fa fa-chevron-left"></i> OS-thread-homework
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#CSAPP-LAB4-SHELL-LAB-REPORT"><span class="nav-number">1.</span> <span class="nav-text">CSAPP-LAB4-SHELL-LAB-REPORT</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E7%9B%AE%E7%9A%84"><span class="nav-number">1.1.</span> <span class="nav-text">实验目的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E5%B9%B3%E5%8F%B0%E5%87%86%E5%A4%87"><span class="nav-number">1.2.</span> <span class="nav-text">实验平台准备</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Hand-Out-%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.3.</span> <span class="nav-text">Hand Out 介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%99%AE%E9%80%9A%E7%9A%84Unix-Shells%E6%A6%82%E8%BF%B0"><span class="nav-number">1.4.</span> <span class="nav-text">普通的Unix Shells概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tsh%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-number">1.5.</span> <span class="nav-text">tsh的特点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A3%80%E6%9F%A5%E5%B7%A5%E4%BD%9C%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%80%A7"><span class="nav-number">1.6.</span> <span class="nav-text">检查工作的正确性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E6%AD%A5%E9%AA%A4"><span class="nav-number">1.7.</span> <span class="nav-text">实验步骤</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#main%E5%87%BD%E6%95%B0"><span class="nav-number">1.7.1.</span> <span class="nav-text">main函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#test01"><span class="nav-number">1.7.2.</span> <span class="nav-text">test01</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#test02"><span class="nav-number">1.7.3.</span> <span class="nav-text">test02</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#test03-amp-test04"><span class="nav-number">1.7.4.</span> <span class="nav-text">test03 &amp; test04</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#test05"><span class="nav-number">1.7.5.</span> <span class="nav-text">test05</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#test06-amp-test07-amp-test08"><span class="nav-number">1.7.6.</span> <span class="nav-text">test06 &amp; test07 &amp; test08</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#test09-amp-test10"><span class="nav-number">1.7.7.</span> <span class="nav-text">test09 &amp; test10</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#test11-amp-test12-amp-test13"><span class="nav-number">1.7.8.</span> <span class="nav-text">test11 &amp; test12 &amp; test13</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#test14"><span class="nav-number">1.7.9.</span> <span class="nav-text">test14</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#test15-amp-test16"><span class="nav-number">1.7.10.</span> <span class="nav-text">test15 &amp; test16</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tsh-c%E6%96%87%E4%BB%B6%E7%BB%BC%E5%90%88"><span class="nav-number">1.7.11.</span> <span class="nav-text">tsh.c文件综合</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93"><span class="nav-number">1.8.</span> <span class="nav-text">实验总结</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Puitar</p>
  <div class="site-description" itemprop="description">博客萌新时不时送来没什么软用的文章</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">2</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>
  <div class="sidebar-button motion-element"><i class="fa fa-comment"></i>
    Chat
  </a>
  </div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/PUITAR" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;PUITAR" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/1831979740@qq.com" title="E-Mail → 1831979740@qq.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Puitar</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>















  

  

</body>
</html>
