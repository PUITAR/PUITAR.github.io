<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"puitar.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="博客萌新时不时送来没什么软用的文章">
<meta property="og:type" content="website">
<meta property="og:title" content="Puitar&#39;s Blog">
<meta property="og:url" content="https://puitar.github.io/index.html">
<meta property="og:site_name" content="Puitar&#39;s Blog">
<meta property="og:description" content="博客萌新时不时送来没什么软用的文章">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Puitar">
<meta property="article:tag" content="菜鸟菜鸟">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://puitar.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Puitar's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Puitar's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://puitar.github.io/2022/05/26/CSAPP-shlab-report/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Puitar">
      <meta itemprop="description" content="博客萌新时不时送来没什么软用的文章">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Puitar's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/26/CSAPP-shlab-report/" class="post-title-link" itemprop="url">CSAPP:shlab-report</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-05-26 23:31:03" itemprop="dateCreated datePublished" datetime="2022-05-26T23:31:03+08:00">2022-05-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-05-28 10:46:24" itemprop="dateModified" datetime="2022-05-28T10:46:24+08:00">2022-05-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/courses-learning/" itemprop="url" rel="index"><span itemprop="name">courses-learning</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="CSAPP-LAB4-SHELL-LAB-REPORT"><a href="#CSAPP-LAB4-SHELL-LAB-REPORT" class="headerlink" title="CSAPP-LAB4-SHELL-LAB-REPORT"></a>CSAPP-LAB4-SHELL-LAB-REPORT</h1><p>计科2002班</p>
<p>202001130329</p>
<p>杨铭</p>
<h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><p>通过这个实验能够更加深刻理解进程控制和信号控制的相关概念。本次实验我们要写一个自己的类linux&#x2F;unix的shell程序，它能够支持工作的控制。</p>
<h2 id="实验平台准备"><a href="#实验平台准备" class="headerlink" title="实验平台准备"></a>实验平台准备</h2><ul>
<li>Ubuntu-32 VMfare虚拟机</li>
<li>typora编写实验报告(经授课老师许可)</li>
</ul>
<h2 id="Hand-Out-介绍"><a href="#Hand-Out-介绍" class="headerlink" title="Hand Out 介绍"></a>Hand Out 介绍</h2><p>首先解压实验文件，然后做如下工作：</p>
<ul>
<li>使用命令<code>tar xvf shlab-handout.tar</code>解压文件</li>
<li>使用命令<code>make</code>来编译和链接测试程序</li>
<li>输入(你的队员)没有队员，把你的大名写在<code>tsh.c</code>程序的顶部注释中</li>
</ul>
<p>注意到你的<code>tsh.c</code>(<em>tiny shell</em>)文件，你会看到它包含了一个简单Unix的shell的函数框架。为了简化实验，实际上题目已经帮我们实现了一些没那么有趣的函数。我们的任务就是完成剩下的空的函数。</p>
<p><strong>需要实现</strong></p>
<table>
<thead>
<tr>
<th>目标函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>eval</td>
<td>主例程，用以分析和解释命令行（原型在课本8.4节）</td>
</tr>
<tr>
<td>builtin_cmd</td>
<td>执行bg和fg内置命令</td>
</tr>
<tr>
<td>waitfg</td>
<td>等待前台作业执行</td>
</tr>
<tr>
<td>sigchld_handler</td>
<td>响应处理SIGCHILD信号</td>
</tr>
<tr>
<td>sigint_handler</td>
<td>响应处理SIGINT（ctrl-c）信号</td>
</tr>
<tr>
<td>sigtstp_handler</td>
<td>响应处理SIGTP（ctrl-z）信号</td>
</tr>
</tbody></table>
<p>每一次修改<code>tsh.c</code>，都需要输入<code>make</code>来重编译它。运行你的<em>shell</em>，在命令行输入<code>tsh</code>如下</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unix&gt; ./tsh</span><br><span class="line">tsh&gt; [<span class="built_in">type</span> commands to your shell here]</span><br></pre></td></tr></table></figure>



<h2 id="普通的Unix-Shells概述"><a href="#普通的Unix-Shells概述" class="headerlink" title="普通的Unix Shells概述"></a>普通的Unix Shells概述</h2><p>一个<em>shell</em>是一个对于用户层面的交互程序，它能够对用户输入的命令行进行解析。一个<em>shell</em>通常会重复输出一个标识符（通常是’prompt‘），然后等待一个命令行输入或者<code>stdin</code>标准输入。一旦它取得了命令行之后就会用它的内容进行一系列的解析工作。</p>
<p>命令行是一个有序的ASCII字符序列，它们使用空格相隔。命令行的第一个单词通常是一个<em>shell</em>的内部命令或者一个可执行文件的路径名称。剩下的单词是命令行的参数。如果第一个单词是一个命令行的内部命令，<em>shell</em>会立即在当前进程（也就是<em>shell</em>）立即执行。否则的话，它是一个可执行文件的路径。在这个情况之下<em>shell</em>通过<code>fork</code>一个子进程，然后在子进程的上下文中加载并运行程序。由于解析一个命令行而创建的子进程又被称作是<code>job</code>（作业）。总的来说，一个job是由若干子进程组成的，这些子进程通过Unix管道进行连接。</p>
<p>如果一个命令行以“&amp;”符号结尾，那么这个job就会在<em>background</em>运行该程序。也就是在后台运行这个程序，这意味着<em>shell</em>不会等待这个子进程结束后才打印下一个prompt来解析下一条命令行。因此在任何时候，最多只有一个任务能够在前台运行。然而在后台可以运行任意数目的作业。</p>
<p>例如，输入命令行</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br></pre></td></tr></table></figure>

<p>会导致<em>shell</em>执行一个内置的作业命令。输入命令如下</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsh&gt; /bin/ls -l -d</span><br></pre></td></tr></table></figure>

<p>来在前台运行一个<code>ls</code>程序。按照惯例，<em>shell</em>确保当程序开始执行的时候，它的主例程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br></pre></td></tr></table></figure>

<p>这里的<code>argc</code>和<code>argv</code>拥有了如下值：</p>
<ul>
<li>argc &#x3D;&#x3D;  3，</li>
<li>argv[0] &#x3D;&#x3D; “&#x2F;bin&#x2F;ls”,</li>
<li>argv[1] &#x3D;&#x3D; “-l”,</li>
<li>argv[2] &#x3D;&#x3D; “-d”.</li>
</ul>
<p>或者另一方面，我们输入命令行如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsh&gt; /bin/ls -l -d &amp;</span><br></pre></td></tr></table></figure>

<p>就会使得<code>ls</code>程序在后台运行。</p>
<p>Unix shells支持<code>job control</code>，它能够允许用户对将作业在前台和后台之间移动，同时也能够改变进程的状态（running, stopped, or terminated）。输入<code>ctrl-c</code>会导致产生一个SIGINT信号，它被发送到前台的每个作业。类似的，如果你输入一个<code>ctrl-z</code>会导致一个SIGTSTP信号产生，并被发送给每一个前台的工作。对于SIGTSTP的默认行为是设置一个进程为stopped状态，它会保持停止状态直到直到它收到SIGCONT信号后才被唤醒。Unix shells同样提供不同的内置命令来支持这种工作的控制。例如</p>
<ul>
<li><code>jobs</code>：列出正在运行的以及停止的的后台作业</li>
<li><code>bg &lt;job&gt;</code>：改变一个停止的后台作业为一个后台运行态作业</li>
<li><code>fg &lt;job&gt;</code>：改变一个停止或运行的后台作业为一个运行的前台作业</li>
<li><code>kill &lt;job&gt;</code>：终止一个作业</li>
</ul>
<h2 id="tsh的特点"><a href="#tsh的特点" class="headerlink" title="tsh的特点"></a>tsh的特点</h2><p>我们的<code>tsh</code>应该具备以下特点</p>
<ul>
<li>标志符prompt应该是字符串“tsh&gt;”</li>
<li>用户输入的字符串应该由一个可执行的程序或者内嵌的指令开头（<code>name</code>），然后紧跟着0个或者更若干个参数。它们由一个或者更更多的空格隔开。如果<code>name</code>是一个内置指令，tsh直接处理执行，然后等待下一条指令。否则<code>tsh</code>就会把这个<code>name</code>当成是一个可执行文件的路径，然后初始化一个子进程，然后在这个子进程的上下文中加载执行这个程序（在这种情况下，我们所说的作业通常指这个子进程）</li>
<li><code>tsh</code>不需要支持管道符（|）或者I&#x2F;O的重定向（&lt;和&gt;）</li>
<li>输入ctrl-c（ctrl-z）应该导致SIGINT（SIGTSTP）信号产生然后被发送到当前的前台作业那里去，这些信号同样会被发送到这些前台进程的后代进程那里去。（例如它所派生的子进程）。如果没有任何前台进程，那么这个信号将不会有任何的效果</li>
<li>如果这个命令行是以&amp;结尾的，那么<code>tsh</code>应该让这个作业在后台运行。</li>
<li>每一个作业能够唯一的ID（PID）标识或者我们说这是一个作业ID（JID），它是一个<code>tsh</code>所分配的标识符。JIDs应该在命令行上用一个前缀’%‘来表示。例如：“%5”表示的是JID为5。（实验中提供了所有作业列表所需要的例程）</li>
<li><code>tsh</code>应该支持以下内置命令<ul>
<li><code>quit</code>命令用来终止<em>shell</em></li>
<li><code>jobs</code>用来列出所有后台作业</li>
<li><code>bg &lt;job&gt;</code>通过向<code>&lt;job&gt;</code>发送SIGCONT来重启它，然后让它运行在后台中，<code>&lt;job&gt;</code>参数可以用PID或者JID</li>
<li><code>fg &lt;job&gt;</code>命令通过发送SIGCONT信号给进程<code>&lt;job&gt;</code>，然后把它运行在前台中，<code>&lt;job&gt;</code>参数可以用PID或者JID</li>
</ul>
</li>
<li><code>tsh</code>应该回收它的所有僵尸孩子。如果任何作业因为接收到未捕获的信号而终止，则<code>tsh</code>应识别此事件并打印带有作业 PID 的消息和违规信号的描述</li>
</ul>
<h2 id="检查工作的正确性"><a href="#检查工作的正确性" class="headerlink" title="检查工作的正确性"></a>检查工作的正确性</h2><p>实验提供了一些工具来帮助我们检查工作是否正确。</p>
<p><strong>Reference solution.</strong><code>tshref</code>是一个Linux下的可执行文件为我们的<em>shell</em>提供了一个参考解决办法。运行这个程序来解决问题，看看我们的<code>tsh</code>执行的怎么样。你的<em>shell</em>应该提交输出和参考解决办法完全相同。</p>
<p><strong>Shell driver.</strong><code>sdriver.pl</code>程序将我们的<code>tsh</code>作为子进程执行，按照跟踪文件的指令向其发送命令和信号，并捕获显示<em>shell</em>的输出。使用<code>-h</code>。</p>
<p>我们有16个trace文件trace{01-16}.txt，用来和shell driver一起使用，用来测试我们的<em>shell</em>的正确性。那些数字小的trace文件做一些简单的测试，大的数字做的是更加复杂的测试。</p>
<p>可以简单通过</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unix&gt; make test01		<span class="comment">#执行test01</span></span><br><span class="line">unix&gt; make rtest01		<span class="comment">#用reference solution(tshref)执行test01</span></span><br></pre></td></tr></table></figure>

<p>看输出结果是否一致即可。</p>
<h2 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h2><p>为了保证实验的顺利进行，首先阅读课本第八章的内容。</p>
<p>根据实验指导书，这边建议根据trace文件来进行实验，trace给出你要做的事情的提示。</p>
<h3 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * main - The shell&#x27;s main routine </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">char</span> cmdline[MAXLINE];</span><br><span class="line">    <span class="type">int</span> emit_prompt = <span class="number">1</span>; <span class="comment">/* emit prompt (default) */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Redirect stderr to stdout (so that driver will get all output</span></span><br><span class="line"><span class="comment">     * on the pipe connected to stdout) */</span></span><br><span class="line">    dup2(<span class="number">1</span>, <span class="number">2</span>);	<span class="comment">// 把错误信息重定向到标准输出上，也就是输出到屏幕上</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Parse the command line */</span></span><br><span class="line">    <span class="comment">// 处理参数</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * -h 帮助文件</span></span><br><span class="line"><span class="comment">    * -v 发送额外的诊断信息</span></span><br><span class="line"><span class="comment">    * -p 不打印prompt</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">while</span> ((c = getopt(argc, argv, <span class="string">&quot;hvp&quot;</span>)) != EOF) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:             <span class="comment">/* print help message */</span></span><br><span class="line">            usage();</span><br><span class="line">	    <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;v&#x27;</span>:             <span class="comment">/* emit additional diagnostic info */</span></span><br><span class="line">            verbose = <span class="number">1</span>;</span><br><span class="line">	    <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;p&#x27;</span>:             <span class="comment">/* don&#x27;t print a prompt */</span></span><br><span class="line">            emit_prompt = <span class="number">0</span>;  <span class="comment">/* handy for automatic testing */</span></span><br><span class="line">	    <span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">            usage();</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Install the signal handlers */</span></span><br><span class="line">	<span class="comment">// 对各种信号进行处理</span></span><br><span class="line">    <span class="comment">/* These are the ones you will need to implement */</span></span><br><span class="line">    Signal(SIGINT,  sigint_handler);   <span class="comment">/* ctrl-c */</span></span><br><span class="line">    Signal(SIGTSTP, sigtstp_handler);  <span class="comment">/* ctrl-z */</span></span><br><span class="line">    Signal(SIGCHLD, sigchld_handler);  <span class="comment">/* Terminated or stopped child */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This one provides a clean way to kill the shell */</span></span><br><span class="line">    Signal(SIGQUIT, sigquit_handler); </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initialize the job list */</span></span><br><span class="line">    <span class="comment">// 初始化作业列表</span></span><br><span class="line">    initjobs(jobs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Execute the shell&#x27;s read/eval loop */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Read command line */</span></span><br><span class="line">    <span class="comment">// 打印一个prompt符</span></span><br><span class="line">	<span class="keyword">if</span> (emit_prompt) &#123;</span><br><span class="line">	    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, prompt);</span><br><span class="line">	    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 从标准获得命令行</span></span><br><span class="line">	<span class="keyword">if</span> ((fgets(cmdline, MAXLINE, <span class="built_in">stdin</span>) == <span class="literal">NULL</span>) &amp;&amp; ferror(<span class="built_in">stdin</span>))</span><br><span class="line">	    app_error(<span class="string">&quot;fgets error&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// EOF: 当输入ctrl-d的时候表示标准输入(文件)结束，此时直接退出</span></span><br><span class="line">	<span class="keyword">if</span> (feof(<span class="built_in">stdin</span>)) &#123; <span class="comment">/* End of file (ctrl-d) */</span></span><br><span class="line">	    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">	    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Evaluate the command line */</span></span><br><span class="line">	eval(cmdline);		<span class="comment">// 解析命令行</span></span><br><span class="line">	fflush(<span class="built_in">stdout</span>);</span><br><span class="line">	fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">/* control never reaches here */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码我们可以看出，<code>main</code>函数的主要工作就是从标准输出中读出命令行，然后把它交给<code>eval</code>来处理。</p>
<p>参考CSAPP官方网站上给出阉割版本的<em>shell.c</em>，我们可以看到eval主要工作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * eval - evaluate a command line</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">eval</span><span class="params">(<span class="type">char</span> *cmdline)</span> </span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">	<span class="comment">// 通过把argv传递给buildin_command让它判断是不是内置命令并执行</span></span><br><span class="line">    <span class="comment">// 如果不是返回零</span></span><br><span class="line">    <span class="keyword">if</span> (!builtin_command(argv)) &#123; </span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">* buildin_cmd</span></span><br><span class="line"><span class="comment">*/</span>  </span><br><span class="line"><span class="type">int</span> <span class="title function_">builtin_cmd</span><span class="params">(<span class="type">char</span> **argv)</span> </span><br><span class="line">&#123;</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>

<p>我们理清楚主要执行流程如下</p>
<p><img src="/2022/05/26/CSAPP-shlab-report/image-20220525154122346.png" alt="image-20220525154122346"></p>
<h3 id="test01"><a href="#test01" class="headerlink" title="test01"></a>test01</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest01</span><br><span class="line">./sdriver.pl -t trace01.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace01.txt - Properly terminate on EOF.</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure>

<p>我们参考第一个<code>test</code>，对<code>tshref</code>输出了如上结果。这个对于标准输入结束（EOF）的处理。实际上就是对ctrl-d的处理。我们观察到上面<code>main</code>函数中已经有包含对EOF的处理</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// EOF: 当输入ctrl-d的时候表示标准输入(文件)结束，此时直接退出</span></span><br><span class="line">	<span class="keyword">if</span> (feof(<span class="built_in">stdin</span>)) &#123; <span class="comment">/* End of file (ctrl-d) */</span></span><br><span class="line">	    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">	    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>因此我们不许要做什么，可以看到测试结果和参考一致。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make test01</span><br><span class="line">./sdriver.pl -t trace01.txt -s ./tsh -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace01.txt - Properly terminate on EOF.</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure>



<h3 id="test02"><a href="#test02" class="headerlink" title="test02"></a>test02</h3><p>这个一个明显需要做些什么。（不可能又帮你写好）</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest02</span><br><span class="line">./sdriver.pl -t trace02.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace02.txt - Process builtin quit command.</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure>

<p>这个测试要求我们完成对<code>tsh</code>的一条内嵌指令（quit）的处理。它完成的任务就是退出<code>tsh</code>。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ ./tsh</span><br><span class="line">tsh&gt; quit</span><br><span class="line">tsh&gt; </span><br></pre></td></tr></table></figure>

<p>我们可以看到如果什么都不做，是不能够退出的。</p>
<p>现在对这个<code>quit</code>指令的位置有两种思考方向。根据上面<code>main</code>的执行流程，我们说有两个后续处理的方向，一个就是放在eval里面处理，一个就是放在<code>buildin_cmd</code>里面。后者很好理解，这个<code>quit</code>本来就是内嵌指令，所以可以放在后者里面。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">builtin_cmd</span><span class="params">(<span class="type">char</span> **argv)</span>;</span><br></pre></td></tr></table></figure>

<p>可以看到<code>buildin_cmd</code>虽然是对内置指令的处理，这样一条<code>quit</code>非常简单，只要读到这条指令，直接<code>exit(0)</code>，就是它的全部逻辑了。</p>
<p>首先用到<code>parseline</code>来解析命令行，并建立<code>argv</code>，我们可以看到<code>parseline</code>函数的说明如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * parseline - Parse the command line and build the argv array.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Characters enclosed in single quotes are treated as a single</span></span><br><span class="line"><span class="comment"> * argument.  Return true if the user has requested a BG job, false if</span></span><br><span class="line"><span class="comment"> * the user has requested a FG job.  </span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>这个函数主要主要功能就是解析命令行字符串，然后建立<code>argv</code>参数数组，用来给后面execve使用等。</p>
<p>所以代码实现起来就是如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">eval</span><span class="params">(<span class="type">char</span> *cmdline)</span> </span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">// 参数字符串数组</span></span><br><span class="line">	<span class="type">char</span> *argv[MAXARGS]; <span class="comment">/* argv for execve() */</span></span><br><span class="line">	<span class="type">int</span> bg;              <span class="comment">/* should the job run in bg or fg? */</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* parse command line */</span></span><br><span class="line">    <span class="comment">// 解析cmdline获得argv</span></span><br><span class="line">    bg = parseline(cmdline, argv); </span><br><span class="line">	<span class="keyword">if</span> (!builtin_cmd(argv)) &#123; </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * builtin_cmd - If the user has typed a built-in command then execute</span></span><br><span class="line"><span class="comment"> *    it immediately.  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">builtin_cmd</span><span class="params">(<span class="type">char</span> **argv)</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;quit&quot;</span>))</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);  <span class="comment">/* terminate shell */</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>然后我们<code>make</code>编译以下，查看测试情况，</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make test02</span><br><span class="line">./sdriver.pl -t trace02.txt -s ./tsh -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace02.txt - Process builtin quit command.</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure>

<p>和参考一样，通关~</p>
<h3 id="test03-amp-test04"><a href="#test03-amp-test04" class="headerlink" title="test03 &amp; test04"></a>test03 &amp; test04</h3><p>测试3和测试4的内容放在一起讲好了，因为</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest03</span><br><span class="line">./sdriver.pl -t trace03.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace03.txt - Run a foreground job.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; quit</span><br><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest04</span><br><span class="line">./sdriver.pl -t trace04.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace04.txt - Run a background job.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./myspin 1 &amp;</span><br><span class="line">[1] (9950) ./myspin 1 &amp;</span><br></pre></td></tr></table></figure>

<p>可以看到参考程序中，对于测试3，它测试了前台运行<code>quit</code>，测试4在后台运行了<code>myspin</code>，<code>myspin</code>是自旋等待了1秒。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in `parseline`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* should the job run in the background? */</span></span><br><span class="line">    <span class="keyword">if</span> ((bg = (*argv[argc<span class="number">-1</span>] == <span class="string">&#x27;&amp;&#x27;</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">	argv[--argc] = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到在<code>parseline</code>通过上面的步骤解析判断了是否需要讲进程运行在后台。主要是通过检索命令行末尾的字符是否是‘&amp;’</p>
<p><strong>前台工作需要等待工作执行完毕就好了。不论是前台还是后台程序，都需要加入到jobs</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* global variables */</span></span><br><span class="line"><span class="type">int</span> nextjid = <span class="number">1</span>;            <span class="comment">/* next job ID to allocate */</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">/* addjob - Add a job to the job list */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">addjob</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span> *jobs, <span class="type">pid_t</span> pid, <span class="type">int</span> state, <span class="type">char</span> *cmdline)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">1</span>)	<span class="comment">// 无效pid</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++) &#123;	</span><br><span class="line">        <span class="comment">/* 如果jobs数组里面有pid等于0等于0的表项，表示这个位置可以用，把这个作业放进去 */</span></span><br><span class="line">        <span class="keyword">if</span> (jobs[i].pid == <span class="number">0</span>) &#123;</span><br><span class="line">            jobs[i].pid = pid;</span><br><span class="line">            jobs[i].state = state;</span><br><span class="line">            jobs[i].jid = nextjid++;</span><br><span class="line">            <span class="keyword">if</span> (nextjid &gt; MAXJOBS)</span><br><span class="line">                nextjid = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">strcpy</span>(jobs[i].cmdline, cmdline);</span><br><span class="line">            <span class="keyword">if</span>(verbose)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Added job [%d] %d %s\n&quot;</span>, jobs[i].jid, jobs[i].pid, jobs[i].cmdline);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Tried to create too many jobs\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>addjob</code>的工作就是为PID为pid的子进程分配一个jid，然后把jid保存在进程结构中,然后根据全局变量JID来给这个子进程为<code>tsh</code>编写这个子进程的JID。通过是为了防止JID越界的情况，需要额外对的<code>nextjid</code>进行判断。我们对此更加加深了对jid的理解。jid就是现在一共有几个job在<code>tsh</code>下面运行。由于<code>jobs</code>数组是有限的，所以jid超过了MAXJOBS的话是需要重置的。如果发生这种事情的话，只有当一个作业结束，<code>jobs</code>才能让出位置来，这是后才可以再分配工作。值得一提的是，根据课本<em>shell.c</em>的代码，我们可以在这里加一个，如果<code>verbose</code>有效的话，打印详细信息（加入的作业是啥）</p>
<p>我们还需要等待前台运行的子进程运行完，所以我们还要解决<code>waitfg</code>函数的问题。这个函数是需要我们自己编写的。主要功能就是阻塞当前进程也就是<code>tsh</code>，直到我们pid命名的子进程结束。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* fgpid - Return PID of current foreground job, 0 if no such job */</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fgpid</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span> *jobs)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++)</span><br><span class="line">	<span class="keyword">if</span> (jobs[i].state == FG)</span><br><span class="line">	    <span class="keyword">return</span> jobs[i].pid;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这个函数就是循环查看当前前台工作的作业的pid是多少。知道了这个我们就可以写<code>waitfg</code>函数了。当<code>pid</code>对应的进程还是前台进程的时候就一直循环等待。指导书里面说可以用循环<code>sleep(0)</code>进行等待。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">waitfg</span><span class="params">(<span class="type">pid_t</span> pid)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (pid == fgpid(jobs))</span><br><span class="line">        sleep(<span class="number">0</span>); <span class="comment">// 这里是指主动让出CPU的意思</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具备上面的基础，我们可以写出代码如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in `eval`</span></span><br><span class="line">...  </span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> (!builtin_cmd(argv)) &#123; </span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) == <span class="number">0</span>) &#123;  <span class="comment">/* child */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Background jobs should ignore SIGINT (ctrl-c)  */</span></span><br><span class="line">        <span class="comment">/* and SIGTSTP (ctrl-z) */</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        if (bg) &#123;</span></span><br><span class="line"><span class="comment">            // 课本对SIG_IGN有详细解释</span></span><br><span class="line"><span class="comment">            // 如果信号的handler是SIG_IGN，会忽略这个信号</span></span><br><span class="line"><span class="comment">            Signal(SIGINT, SIG_IGN);</span></span><br><span class="line"><span class="comment">            Signal(SIGTSTP, SIG_IGN);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        </span><br><span class="line">		<span class="comment">// 前台执行</span></span><br><span class="line">        <span class="keyword">if</span> (execve(argv[<span class="number">0</span>], argv, environ) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s: Command not found.\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">            fflush(<span class="built_in">stdout</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">// 如果没有这个可执行程序，那么直接终止这个子进程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* parent waits for foreground job to terminate or stop */</span></span><br><span class="line">    addjob(jobs, pid, (bg == <span class="number">1</span> ? BG : FG), cmdline);</span><br><span class="line">    <span class="keyword">if</span> (!bg) <span class="comment">// 前台运行则等待子进程</span></span><br><span class="line">        waitfg(pid);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%d] (%d) %s&quot;</span>, pid2jid(pid), pid, cmdline);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到上面的函数<code>fork</code>出一个子进程，然后<code>execve</code>执行某个可执行程序。对于父进程，父进程把这个进程添加到jobs队列中去。然后如果这是一个前台程序，就调用<code>waitfg</code>等待子进程结束。如果子进程结束了。通过SIGCHLD信号给父进程发信息，唤醒父进程回收自己。</p>
<p>父进程回收处理程序如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * sigchld_handler - The kernel sends a SIGCHLD to the shell whenever</span></span><br><span class="line"><span class="comment"> *     a child job terminates (becomes a zombie), or stops because it</span></span><br><span class="line"><span class="comment"> *     received a SIGSTOP or SIGTSTP signal. The handler reaps all</span></span><br><span class="line"><span class="comment"> *     available zombie children, but doesn&#x27;t wait for any other</span></span><br><span class="line"><span class="comment"> *     currently running children to terminate.  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sigchld_handler</span><span class="params">(<span class="type">int</span> sig)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (verbose)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sigchld_handler: entering \n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    * 回收僵尸进程</span></span><br><span class="line"><span class="comment">    * 这里的WNOHANG是非常重要的。</span></span><br><span class="line"><span class="comment">    * 它的本意是如果所有孩子都没有僵尸(终止)状态的，直接退出</span></span><br><span class="line"><span class="comment">    * 这个能够避免在这里等待所有前台的running和stopped程序终止</span></span><br><span class="line"><span class="comment">    * 这样tsh就不能正常接受用户的输入了</span></span><br><span class="line"><span class="comment">    * WUNTRACED是等待直到有一个子进程变成僵尸退出，返回它的pid</span></span><br><span class="line"><span class="comment">    * 这个选项开启能够检查已终止和被停止的子进程</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">while</span> ((pid = waitpid(<span class="number">-1</span>, &amp;status, WNOHANG | WUNTRACED)) &gt; <span class="number">0</span>) &#123; </span><br><span class="line">        <span class="comment">// 这里不管是不是正常exit或者ctrl-c或者ctrl-z退出的</span></span><br><span class="line">        <span class="comment">// 子进程都结束了，都要回收资源</span></span><br><span class="line">        deletejob(jobs, pid);</span><br><span class="line">        <span class="keyword">if</span> (verbose)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;sigchld_handler: job %d deleted\n&quot;</span>, pid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (verbose)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sigchld_handler: exiting\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>像上面这样写看起来是没有什么问题了。但是课本519中提示了一种苛刻同步问题。如果子进程在父进程将自己加入到<code>jobs</code>之前就执行完毕，然后<code>exit</code>退出，就会触发父进程的回收<code>sigchld_handler</code>程序，实际上，这样的删除显然没有任何意义。后续又将这个工作<code>addjob</code>，这也是没有什么意义的。</p>
<p>因此我们还要对上面的<code>eval</code>进一步修改为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in `eval`</span></span><br><span class="line">...   </span><br><span class="line"><span class="type">sigset_t</span> mask;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> (!builtin_cmd(argv)) &#123;</span><br><span class="line">        Sigprocmask(SIG_BLOCK, &amp;mask, &amp;prev);  <span class="comment">/* 阻塞SIGCHLD */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((pid = fork()) == <span class="number">0</span>) &#123;   <span class="comment">/* Child runs user job */</span></span><br><span class="line">            <span class="comment">/* 给fork出来的子进程设置一个独立的组，</span></span><br><span class="line"><span class="comment">	 		 * 子进程是这个组的组长,组id为子进程的pid */</span></span><br><span class="line">            setpgid(<span class="number">0</span>, <span class="number">0</span>);	</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/* 对于子进程并不需要阻塞SIGCHLD的信号 */</span></span><br><span class="line">            Sigprocmask(SIG_UNBLOCK, &amp;prev, <span class="literal">NULL</span>);  <span class="comment">// unblock SIGCHLD</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">/* </span></span><br><span class="line"><span class="comment">            * 前台执行 </span></span><br><span class="line"><span class="comment">            * 如果没有这个可执行程序，那么直接终止这个子进程</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">if</span> (execve(argv[<span class="number">0</span>], argv, environ) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s: Command not found.\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">                _exit(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        addjob(jobs, pid, bg ? BG : FG, cmdline);</span><br><span class="line">        <span class="comment">/* 已经加到jobs了，解除阻塞 */</span></span><br><span class="line">        Sigprocmask(SIG_SETMASK, &amp;prev, <span class="literal">NULL</span>);  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Parent waits for foreground job to terminate */</span></span><br><span class="line">        <span class="keyword">if</span> (!bg)  <span class="comment">// 前台运行则等待子进程</span></span><br><span class="line">            waitfg(pid);</span><br><span class="line">        <span class="keyword">else</span>      <span class="comment">// background</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[%d] (%d) %s&quot;</span>, pid2jid(pid), pid, cmdline);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>测试以下我们的代码的正确性</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest03</span><br><span class="line">./sdriver.pl -t trace03.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace03.txt - Run a foreground job.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; quit</span><br><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make test03</span><br><span class="line">./sdriver.pl -t trace03.txt -s ./tsh -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace03.txt - Run a foreground job.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; quit</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest04</span><br><span class="line">./sdriver.pl -t trace04.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace04.txt - Run a background job.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./myspin 1 &amp;</span><br><span class="line">[1] (10488) ./myspin 1 &amp;</span><br><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make test04</span><br><span class="line">./sdriver.pl -t trace04.txt -s ./tsh -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace04.txt - Run a background job.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./myspin 1 &amp;</span><br><span class="line">[1] (10494) ./myspin 1 &amp;</span><br></pre></td></tr></table></figure>

<p>测试程序都相同了，成功~</p>
<h3 id="test05"><a href="#test05" class="headerlink" title="test05"></a>test05</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest05</span><br><span class="line">./sdriver.pl -t trace05.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace05.txt - Process jobs builtin command.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./myspin 2 &amp;</span><br><span class="line">[1] (10504) ./myspin 2 &amp;</span><br><span class="line">tsh&gt; ./myspin 3 &amp;</span><br><span class="line">[2] (10506) ./myspin 3 &amp;</span><br><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br><span class="line">[1] (10504) Running ./myspin 2 &amp;</span><br><span class="line">[2] (10506) Running ./myspin 3 &amp;</span><br></pre></td></tr></table></figure>

<p>这里的任务是完成内嵌指令<code>jobs</code>的工作。它能够列出作业列表中的所有作业。</p>
<p>这个很简单，起始只要用一个<code>listjobs</code>就可已完成这个工作了，这个函数是实验已经帮我们实现了的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* listjobs - Print the job list */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">listjobs</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span> *jobs)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (jobs[i].pid != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[%d] (%d) &quot;</span>, jobs[i].jid, jobs[i].pid);</span><br><span class="line">            <span class="keyword">switch</span> (jobs[i].state) &#123;</span><br><span class="line">                <span class="keyword">case</span> BG: </span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Running &quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> FG: </span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Foreground &quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> ST: </span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Stopped &quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;listjobs: Internal error: job[%d].state=%d &quot;</span>, </span><br><span class="line">                           i, jobs[i].state);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, jobs[i].cmdline);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在<code>builtin_cmd</code>中加入<code>jobs</code>命令的入口就好。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">builtin_cmd</span><span class="params">(<span class="type">char</span> **argv)</span> </span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// jobs command    </span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;jobs&quot;</span>)) &#123;        </span><br><span class="line">        listjobs(jobs);        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>我们看看测试结果</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest05</span><br><span class="line">./sdriver.pl -t trace05.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace05.txt - Process jobs builtin command.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./myspin 2 &amp;</span><br><span class="line">[1] (10613) ./myspin 2 &amp;</span><br><span class="line">tsh&gt; ./myspin 3 &amp;</span><br><span class="line">[2] (10615) ./myspin 3 &amp;</span><br><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br><span class="line">[1] (10613) Running ./myspin 2 &amp;</span><br><span class="line">[2] (10615) Running ./myspin 3 &amp;</span><br><span class="line"></span><br><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make test05</span><br><span class="line">./sdriver.pl -t trace05.txt -s ./tsh -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace05.txt - Process jobs builtin command.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./myspin 2 &amp;</span><br><span class="line">[1] (10622) ./myspin 2 &amp;</span><br><span class="line">tsh&gt; ./myspin 3 &amp;</span><br><span class="line">[2] (10624) ./myspin 3 &amp;</span><br><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br><span class="line">[1] (10622) Running ./myspin 2 &amp;</span><br><span class="line">[2] (10624) Running ./myspin 3 &amp;</span><br></pre></td></tr></table></figure>

<p>和参考一致，表示正确。这里你可能会被英文的实验指导书迷惑了，实际上列出的是工作列表的所有工作，而不是后台的所有工作。通关~</p>
<h3 id="test06-amp-test07-amp-test08"><a href="#test06-amp-test07-amp-test08" class="headerlink" title="test06 &amp; test07 &amp; test08"></a>test06 &amp; test07 &amp; test08</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest06</span><br><span class="line">./sdriver.pl -t trace06.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace06.txt - Forward SIGINT to foreground job.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./myspin 4</span><br><span class="line">Job [1] (10840) terminated by signal 2</span><br><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest07</span><br><span class="line">./sdriver.pl -t trace07.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace07.txt - Forward SIGINT only to foreground job.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./myspin 4 &amp;</span><br><span class="line">[1] (10846) ./myspin 4 &amp;</span><br><span class="line">tsh&gt; ./myspin 5</span><br><span class="line">Job [2] (10848) terminated by signal 2</span><br><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br><span class="line">[1] (10846) Running ./myspin 4 &amp;</span><br><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest08</span><br><span class="line">./sdriver.pl -t trace08.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace08.txt - Forward SIGTSTP only to foreground job.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./myspin 4 &amp;</span><br><span class="line">[1] (10856) ./myspin 4 &amp;</span><br><span class="line">tsh&gt; ./myspin 5</span><br><span class="line">Job [2] (10858) stopped by signal 20</span><br><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br><span class="line">[1] (10856) Running ./myspin 4 &amp;</span><br><span class="line">[2] (10858) Stopped ./myspin 5 </span><br></pre></td></tr></table></figure>

<p>测试678要完成的任务是对于SIGINT和SIGTSTP的处理。对于上面的测试，测试6启动一个自旋程序到前台并且发出SIGINT终止它。测试7启动两个自旋，一个在前台一个在后台，然后发出SIGINT，检测到只有前台进程被终止了。测试8类似。</p>
<img src="/2022/05/26/CSAPP-shlab-report/image-20220526003548830.png" alt="image-20220526003548830" style="zoom:67%;">

<p>我们可以从课本上这幅图看到shell会给每一个子进程分配一个和PID一样的组id，这些shell的子进程的孩子都在这些子进程的组内。比如上图中的前台作业就是shell产生的子进程，但是它和shell不是一个组的，他自己独立成组，组id等于自己的pid，然后它的孩子都属于自己这个组。</p>
<p>首先需要完成SIGINT的处理，给前台进程的组的所有进程发送SIGINT信号(这里就是参数sig)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sigint_handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 这一步的保存和下一步的恢复，是由于在下面的kill系统调用中可能会覆盖errno的值</span></span><br><span class="line">    <span class="comment">// 导致现在的errno丢失</span></span><br><span class="line">    <span class="comment">// 而errno在sigchild_handler中还有使用到，为了避免产生这种错误需要在这里保存，在后面恢复</span></span><br><span class="line">    <span class="type">int</span> olderrno = errno;</span><br><span class="line">    <span class="comment">// get the foreground job pid</span></span><br><span class="line">    <span class="type">pid_t</span> fg_pid = fgpid(jobs);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * int kill(pid_t pid,int signo)</span></span><br><span class="line"><span class="comment"> 	* 功能: 向进程或进程组发送一个信号 （成功返回 0； 否则，返回 -1 ）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    kill(-fg_pid, sig); </span><br><span class="line">    <span class="comment">// -fg_pid表示向进程组号为pid的组中的每个进程发sig信号</span></span><br><span class="line">    <span class="comment">// 在这里就是向前台进程以及它的每一个子进程(子进程都在自己的父进程的pid为组id的组下)</span></span><br><span class="line">    errno = olderrno;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相同的原理，可以写出<code>sigtstp_handler</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sigtstp_handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 为了异步信号安全防止errno被覆盖</span></span><br><span class="line">    <span class="type">int</span> olderrno = errno;</span><br><span class="line">    <span class="comment">// get the foreground job pid</span></span><br><span class="line">    <span class="type">pid_t</span> fg_pid = fgpid(jobs);</span><br><span class="line">    <span class="comment">// kill the group in the foreground</span></span><br><span class="line">    kill(-fg_pid, sig);</span><br><span class="line">    errno = olderrno;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的两个函数就是信号处理过程。<code>sigchld_handler</code>里收到子进程终止或停止的消息后给出对应的输出然后改变其状态，对于终止的进程就在jobs里将其删除，对于停止的进程则设置其state为ST。</p>
<img src="/2022/05/26/CSAPP-shlab-report/image-20220526081536379.png" alt="image-20220526081536379" style="zoom:80%;">

<p>主要流程如上图。</p>
<p>然后就是对<code>sigchld_handler</code>的修改。我们需要针对上面的代码进一步进行修改。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sigchld_handler - The kernel sends a SIGCHLD to the shell whenever</span></span><br><span class="line"><span class="comment"> *     a child job terminates (becomes a zombie), or stops because it</span></span><br><span class="line"><span class="comment"> *     received a SIGSTOP or SIGTSTP signal. The handler reaps all</span></span><br><span class="line"><span class="comment"> *     available zombie children, but doesn&#x27;t wait for any other</span></span><br><span class="line"><span class="comment"> *     currently running children to terminate.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sigchld_handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> old_errno = errno;</span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (verbose)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sigchld_handler: entering \n&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* </span></span><br><span class="line"><span class="comment">    * 回收僵尸进程</span></span><br><span class="line"><span class="comment">    * 这里的WNOHANG是非常重要的。</span></span><br><span class="line"><span class="comment">    * 它的本意是如果所有孩子都没有僵尸(终止)状态的，直接退出</span></span><br><span class="line"><span class="comment">    * 这个能够避免在这里等待所有前台的running和stopped程序终止</span></span><br><span class="line"><span class="comment">    * 这样tsh就不能正常接受用户的输入了</span></span><br><span class="line"><span class="comment">    * WUNTRACED是等待直到有一个子进程变成僵尸退出，返回它的pid</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">while</span> ((pid = waitpid(<span class="number">-1</span>, &amp;status, WNOHANG | WUNTRACED)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* 这里实验指导书说不能用while，但是不用会出现错误。他说的while和我的判断条件不一样 */</span></span><br><span class="line">        <span class="comment">// 子进程正常退出</span></span><br><span class="line">        <span class="keyword">if</span> (WIFEXITED(status)) &#123;</span><br><span class="line">            deletejob(jobs, pid);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 子进程因为ctrl-c退出</span></span><br><span class="line">        <span class="keyword">if</span> (WIFSIGNALED(status)) &#123; <span class="comment">// terminated by ctrl-c</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Job [%d] (%d) terminated by signal %2d\n&quot;</span>, </span><br><span class="line">                   pid2jid(pid), pid, WTERMSIG(status));</span><br><span class="line">            deletejob(jobs, pid); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (WIFSTOPPED(status)) &#123; <span class="comment">// stopped by ctrl-z</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Job [%d] (%d) stopped by signal %2d\n&quot;</span>,</span><br><span class="line">                   pid2jid(pid), pid, WSTOPSIG(status));</span><br><span class="line">            <span class="comment">// 修改子进程状态为ST</span></span><br><span class="line">            getjobpid(jobs, pid)-&gt;state = ST;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (verbose) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;sigchld_handler: job %d deleted\n&quot;</span>, pid);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    errno = old_errno;</span><br><span class="line">    <span class="keyword">if</span> (verbose) </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sigchld_handler: exiting\n&quot;</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的程序，在子进程发送SIGCHLD时处于不同状态的子进程，已经有了不同的处理。</p>
<p>但是还存在一个问题，就是<code>printf</code>是异步不安全的。可能出现死锁现象。</p>
<p><strong>死锁（Deadlock）：</strong>当你存在多个逻辑流在等待永远不会发生的场景时就会出现死锁。比如在信号处理程序中使用异步信号不安全的<code>printf</code>函数就可能会出现死锁现象。在主程序中执行了<code>printf</code>函数，则该函数会请求某些资源的一个锁，当该<code>printf</code>函数请求这个锁时它被某个信号处理程序中断了，而在信号处理程序中也要执行一个<code>printf</code>函数，这个<code>printf</code>也试图请求那个锁，但是由于主程序中的<code>printf</code>函数持有那个锁，所以信号处理程序中的<code>printf</code>得不到那个锁，所以这个<code>printf</code>就在等待那个锁被释放的锁，但是主程序只有在信号处理程序返回时才可能释放那个锁，所以这里就造成了死锁。</p>
<p>这里是线程安全但是不可重入的异步安全问题，使用锁是不能够解决的。</p>
<p>所以我们再主线程也就是<code>main</code>里面已经使用过<code>printf</code>了，就要避免在信号处理程序中在使用<code>printf</code>的出现。</p>
<p>我提供下面两种解决手段。</p>
<ul>
<li>一种想法是在这里使用<code>printf</code>的时候屏蔽或者说阻塞SIGCHLD信号，这样主线程在使用<code>printf</code>就不会被中断。但是带来的问题就是这个中断处理信号会被忽略。可能出现处理遗漏的情况。</li>
<li>还有一种处理手段是使用异步信号安全的可重入函数，如下</li>
</ul>
<blockquote>
<p>CSAPP课本实例程序提供了一种线程安全且可重入的函数sio系列函数，使用它，不调用<code>printf</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* private functions */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sio_reverse</span><span class="params">(<span class="type">char</span> s[])</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sio_ltoa</span><span class="params">(<span class="type">long</span> v, <span class="type">char</span> s[], <span class="type">int</span> b)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">size_t</span> <span class="title function_">sio_strlen</span><span class="params">(<span class="type">char</span> s[])</span>;</span><br><span class="line"><span class="comment">/* public functions */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sio_puts</span><span class="params">(<span class="type">char</span> s[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sio_putl</span><span class="params">(<span class="type">long</span> v)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sio_error</span><span class="params">(<span class="type">char</span> s[])</span>;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>查看Linux手册可以知道<code>write</code>是异步信号安全的，使用<code>write</code>就可以实现异步安全的输出了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sio_puts</span><span class="params">(<span class="type">char</span> s[])</span> <span class="comment">/* Put string */</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> write(STDOUT_FILENO, s, <span class="built_in">strlen</span>(s));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我对上面的sio族进行封装形成Sio系列。</p>
<p>我们把<code>sigchld_handler</code>修改以下如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sigchld_handler - The kernel sends a SIGCHLD to the shell whenever</span></span><br><span class="line"><span class="comment"> *     a child job terminates (becomes a zombie), or stops because it</span></span><br><span class="line"><span class="comment"> *     received a SIGSTOP or SIGTSTP signal. The handler reaps all</span></span><br><span class="line"><span class="comment"> *     available zombie children, but doesn&#x27;t wait for any other</span></span><br><span class="line"><span class="comment"> *     currently running children to terminate.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sigchld_handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> old_errno = errno;</span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (verbose)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sigchld_handler: entering \n&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* </span></span><br><span class="line"><span class="comment">    * 回收僵尸进程</span></span><br><span class="line"><span class="comment">    * 这里的WNOHANG是非常重要的。</span></span><br><span class="line"><span class="comment">    * 它的本意是如果所有孩子都没有僵尸(终止)状态的，直接退出</span></span><br><span class="line"><span class="comment">    * 这个能够避免在这里等待所有前台的running和stopped程序终止</span></span><br><span class="line"><span class="comment">    * 这样tsh就不能正常接受用户的输入了</span></span><br><span class="line"><span class="comment">    * WUNTRACED是等待直到有一个子进程变成僵尸退出，返回它的pid</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">while</span> ((pid = waitpid(<span class="number">-1</span>, &amp;status, WNOHANG | WUNTRACED)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程正常退出</span></span><br><span class="line">        <span class="keyword">if</span> (WIFEXITED(status)) &#123;</span><br><span class="line">            deletejob(jobs, pid);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 子进程因为ctrl-c退出</span></span><br><span class="line">        <span class="keyword">if</span> (WIFSIGNALED(status)) &#123; <span class="comment">// terminated by ctrl-c</span></span><br><span class="line">            <span class="comment">/* printf(&quot;Job [%d] (%d) terminated by signal %2d\n&quot;, </span></span><br><span class="line"><span class="comment">                   pid2jid(pid), pid, WTERMSIG(status)); */</span> &#123;</span><br><span class="line">            	Sio_puts(<span class="string">&quot;Job [&quot;</span>);</span><br><span class="line">                Sio_putl(pid2jid(pid));</span><br><span class="line">                Sio_puts(<span class="string">&quot;] (&quot;</span>);</span><br><span class="line">                Sio_putl(pid);</span><br><span class="line">                Sio_puts(<span class="string">&quot;) terminated by signal &quot;</span>);</span><br><span class="line">                Sio_putl(WTERMSIG(status));</span><br><span class="line">                Sio_puts(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            deletejob(jobs, pid); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (WIFSTOPPED(status)) &#123; <span class="comment">// stopped by ctrl-z</span></span><br><span class="line">            <span class="comment">/* printf(&quot;Job [%d] (%d) stopped by signal %2d\n&quot;,</span></span><br><span class="line"><span class="comment">                   pid2jid(pid), pid, WSTOPSIG(status)); */</span> &#123;</span><br><span class="line">            	Sio_puts(<span class="string">&quot;Job [&quot;</span>);</span><br><span class="line">                Sio_putl(pid2jid(pid));</span><br><span class="line">                Sio_puts(<span class="string">&quot;] (&quot;</span>);</span><br><span class="line">                Sio_putl(pid);</span><br><span class="line">                Sio_puts(<span class="string">&quot;) stopped by signal &quot;</span>);</span><br><span class="line">                Sio_putl(WSTOPSIG(status));</span><br><span class="line">                Sio_puts(<span class="string">&quot;\n&quot;</span>);           </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 修改子进程状态为ST</span></span><br><span class="line">            getjobpid(jobs, pid)-&gt;state = ST;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (verbose) &#123;</span><br><span class="line">            <span class="comment">/* printf(&quot;sigchld_handler: job %d deleted\n&quot;, pid); */</span> &#123;</span><br><span class="line">                Sio_puts(<span class="string">&quot;sigchld_handler: job &quot;</span>);</span><br><span class="line">                Sio_putl(pid);</span><br><span class="line">                Sio_puts(<span class="string">&quot; deleted\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    errno = old_errno;</span><br><span class="line">    <span class="keyword">if</span> (verbose) &#123;</span><br><span class="line">        <span class="comment">/* printf(&quot;sigchld_handler: exiting\n&quot;); */</span> &#123;</span><br><span class="line">        	Sio_puts(<span class="string">&quot;sigchld_handler: exiting\n&quot;</span>);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就不会在处理信号程序中使用异步信号不安全的<code>printf</code>了。</p>
<p>然后，<em>shell</em>程序本身是所有子进程的父进程，按照<code>fork</code>函数简单实现，会被分配在一个组中。如果收到了SIGINT，发送给子进程的组，那也会发送给自己，那么<em>shell</em>也被终止了。所以就是给每个子进程单独的组，组的id就是子进程的pid。我们应该把这个操作放在<code>fork</code>之后，修改它的组id，然后执行<code>execve</code>。</p>
<p>修改<code>eval</code>这一部分代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((pid = fork()) == <span class="number">0</span>) &#123;  <span class="comment">/* child */</span></span><br><span class="line">	<span class="comment">/* 给fork出来的子进程设置一个独立的组，</span></span><br><span class="line"><span class="comment">	 * 子进程是这个组的组长,组id为子进程的pid */</span></span><br><span class="line">    setpgid(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>setpgid</code>函数在实验英文指导书有介绍，用于设置进程组id</p>
<p>表头文件 #include&lt;unistd.h&gt;</p>
<p>定义函数 int setpgid(pid_t pid,pid_t pgid);</p>
<p>功能：设置pid所在的进程组的进程组id设置成pgid</p>
<p>setpgid(0, 0)的含义：</p>
<ul>
<li>第一个参数pid是0，则使用当前进程的pid</li>
<li>第二个参数pgid是0，则使用当前进程pid作为pgid</li>
</ul>
</blockquote>
<p>测试结果</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest06</span><br><span class="line">./sdriver.pl -t trace06.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace06.txt - Forward SIGINT to foreground job.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./myspin 4</span><br><span class="line">Job [1] (3427) terminated by signal 2</span><br><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make test06</span><br><span class="line">./sdriver.pl -t trace06.txt -s ./tsh -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace06.txt - Forward SIGINT to foreground job.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./myspin 4</span><br><span class="line">Job [1] (3433) terminated by signal 2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest07</span><br><span class="line">./sdriver.pl -t trace07.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace07.txt - Forward SIGINT only to foreground job.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./myspin 4 &amp;</span><br><span class="line">[1] (3440) ./myspin 4 &amp;</span><br><span class="line">tsh&gt; ./myspin 5</span><br><span class="line">Job [2] (3442) terminated by signal 2</span><br><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br><span class="line">[1] (3440) Running ./myspin 4 &amp;</span><br><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make test07</span><br><span class="line">./sdriver.pl -t trace07.txt -s ./tsh -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace07.txt - Forward SIGINT only to foreground job.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./myspin 4 &amp;</span><br><span class="line">[1] (3449) ./myspin 4 &amp;</span><br><span class="line">tsh&gt; ./myspin 5</span><br><span class="line">Job [2] (3451) terminated by signal 2</span><br><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br><span class="line">[1] (3449) Running ./myspin 4 &amp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest08</span><br><span class="line">./sdriver.pl -t trace08.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace08.txt - Forward SIGTSTP only to foreground job.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./myspin 4 &amp;</span><br><span class="line">[1] (3459) ./myspin 4 &amp;</span><br><span class="line">tsh&gt; ./myspin 5</span><br><span class="line">Job [2] (3461) stopped by signal 20</span><br><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br><span class="line">[1] (3459) Running ./myspin 4 &amp;</span><br><span class="line">[2] (3461) Stopped ./myspin 5 </span><br><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make test08</span><br><span class="line">./sdriver.pl -t trace08.txt -s ./tsh -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace08.txt - Forward SIGTSTP only to foreground job.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./myspin 4 &amp;</span><br><span class="line">[1] (3469) ./myspin 4 &amp;</span><br><span class="line">tsh&gt; ./myspin 5</span><br><span class="line">Job [2] (3471) terminated by signal 20</span><br><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br><span class="line">[1] (3469) Running ./myspin 4 &amp;</span><br><span class="line">[2] (3471) Stopped ./myspin 5 </span><br></pre></td></tr></table></figure>

<p>可以看到与参考输出一致，通关~</p>
<h3 id="test09-amp-test10"><a href="#test09-amp-test10" class="headerlink" title="test09 &amp; test10"></a>test09 &amp; test10</h3><p>第九个和第十个放在一起写。请往下看。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest09</span><br><span class="line">./sdriver.pl -t trace09.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace09.txt - Process bg builtin command</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./myspin 4 &amp;</span><br><span class="line">[1] (3480) ./myspin 4 &amp;</span><br><span class="line">tsh&gt; ./myspin 5</span><br><span class="line">Job [2] (3482) stopped by signal 20</span><br><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br><span class="line">[1] (3480) Running ./myspin 4 &amp;</span><br><span class="line">[2] (3482) Stopped ./myspin 5 </span><br><span class="line">tsh&gt; <span class="built_in">bg</span> %2</span><br><span class="line">[2] (3482) ./myspin 5 </span><br><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br><span class="line">[1] (3480) Running ./myspin 4 &amp;</span><br><span class="line">[2] (3482) Running ./myspin 5 </span><br></pre></td></tr></table></figure>

<p>我们先看看第九个测试的参考输出。我们可以看到我们需要构建的是<code>bg</code>内置命令的相关功能。</p>
<blockquote>
<p><code>bg &lt;job&gt;</code>通过向<code>&lt;job&gt;</code>发送SIGCONT来重启它，然后让它运行在后台中，<code>&lt;job&gt;</code>参数可以用PID或者JID</p>
<ul>
<li>如果参数是PID则直接输入pid即可</li>
<li>如果参数是JID则输入“%jid”</li>
</ul>
</blockquote>
<p>我们看到上面的测试。首先是开启一个后台自旋和一个前台自旋的程序。然后发起ctrl-z终止前台的进程。然后jobs可以看到两个进程以及状态。后台的进程仍然在正常运行，但是前台的进程由于SIGTSTP信号而进入stopped状态。然后使用<code>bg %2</code>指令，把第二个子进程（停止的“.&#x2F;myspin 5”）唤醒，然后放到后台执行。输入<code>jobs</code>指令可以看到两个都在执行，但是后者是后来被切换到后台的，所以没有它的cmdline还没有更新还是显示原来的“.&#x2F;myspin 5”。</p>
<p>再看看<code>rtest10</code>，第十个测试</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest10</span><br><span class="line">./sdriver.pl -t trace10.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace10.txt - Process fg builtin command. </span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./myspin 4 &amp;</span><br><span class="line">[1] (3510) ./myspin 4 &amp;</span><br><span class="line">tsh&gt; <span class="built_in">fg</span> %1</span><br><span class="line">Job [1] (3510) stopped by signal 20</span><br><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br><span class="line">[1] (3510) Stopped ./myspin 4 &amp;</span><br><span class="line">tsh&gt; <span class="built_in">fg</span> %1</span><br><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br></pre></td></tr></table></figure>

<p>它针对的是fg这个内置命令的处理。</p>
<blockquote>
<p><code>fg &lt;job&gt;</code>命令通过发送SIGCONT信号给进程<code>&lt;job&gt;</code>，然后把它运行在前台中，<code>&lt;job&gt;</code>参数可以用PID或者JID</p>
<ul>
<li>如果参数是PID则直接输入pid即可</li>
<li>如果参数是JID则输入“%jid”</li>
</ul>
</blockquote>
<p>可以看到上面的测试样例，一开始，是后台运行一个“.&#x2F;myspin 4”，然后把它放到前台运行，使用“fg %1”命令，切换到前台执行，<em>shell</em>等待它执行完毕。然后<code>jobs</code>查看看到有一个停止的工作，然后把它放到前台并开始运行。最后<code>jobs</code>查看，由于已经运行完了，所以没有输出。</p>
<p>对于这两个功能我们要实现的是<code>do_fgbg</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * do_bgfg - Execute the builtin bg and fg commands</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_bgfg</span><span class="params">(<span class="type">char</span>** argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">job_t</span>* <span class="title">job</span>;</span></span><br><span class="line">    <span class="type">char</span>* id = argv[<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断输入的是jid还是pid</span></span><br><span class="line">    <span class="keyword">if</span> (id[<span class="number">0</span>] == <span class="string">&#x27;%&#x27;</span>) &#123; <span class="comment">/* jid */</span></span><br><span class="line">        <span class="comment">//去掉&#x27;%&#x27;开始读jid，根据jid返回这个子进程的结构指针</span></span><br><span class="line">        <span class="type">int</span> jid = atoi(id + <span class="number">1</span>);</span><br><span class="line">        job = getjobjid(jobs, jid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;              <span class="comment">/* pid */</span></span><br><span class="line">        <span class="type">int</span> pid = atoi(id);</span><br><span class="line">        job = getjobpid(jobs, pid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    * kill不单是杀掉进程，还有发送信号的功能 </span></span><br><span class="line"><span class="comment">    * 这里唤醒job所在的组中的所有进程</span></span><br><span class="line"><span class="comment">    * 就是唤醒这个stopped的子进程，以及它派生的孙子进程</span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">    kill(-(job-&gt;pid), SIGCONT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;fg&quot;</span>)) &#123;  <span class="comment">// fg command</span></span><br><span class="line">        job-&gt;state = FG;</span><br><span class="line">        <span class="comment">// 等待该前台作业终止</span></span><br><span class="line">        waitfg(job-&gt;pid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;                         <span class="comment">// bg command</span></span><br><span class="line">        job-&gt;state = BG;</span><br><span class="line">        <span class="comment">/* 切换到bg后打印作业信息 */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%d] (%d) %s&quot;</span>, pid2jid(job-&gt;pid), job-&gt;pid, job-&gt;cmdline);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们在<code>builtin_cmd</code>中加入函数入口。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in `builtin_cmd`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// bg or fg command</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;bg&quot;</span>) || !<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;fg&quot;</span>)) &#123;</span><br><span class="line">    do_bgfg(argv);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看测试结果</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest09</span><br><span class="line">./sdriver.pl -t trace09.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace09.txt - Process bg builtin command</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./myspin 4 &amp;</span><br><span class="line">[1] (3627) ./myspin 4 &amp;</span><br><span class="line">tsh&gt; ./myspin 5</span><br><span class="line">Job [2] (3629) stopped by signal 20</span><br><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br><span class="line">[1] (3627) Running ./myspin 4 &amp;</span><br><span class="line">[2] (3629) Stopped ./myspin 5 </span><br><span class="line">tsh&gt; <span class="built_in">bg</span> %2</span><br><span class="line">[2] (3629) ./myspin 5 </span><br><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br><span class="line">[1] (3627) Running ./myspin 4 &amp;</span><br><span class="line">[2] (3629) Running ./myspin 5 </span><br><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make test09</span><br><span class="line">./sdriver.pl -t trace09.txt -s ./tsh -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace09.txt - Process bg builtin command</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./myspin 4 &amp;</span><br><span class="line">[1] (3638) ./myspin 4 &amp;</span><br><span class="line">tsh&gt; ./myspin 5</span><br><span class="line">Job [2] (3640) terminated by signal 20</span><br><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br><span class="line">[1] (3638) Running ./myspin 4 &amp;</span><br><span class="line">[2] (3640) Stopped ./myspin 5 </span><br><span class="line">tsh&gt; <span class="built_in">bg</span> %2</span><br><span class="line">[2] (3640) ./myspin 5 </span><br><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br><span class="line">[1] (3638) Running ./myspin 4 &amp;</span><br><span class="line">[2] (3640) Running ./myspin 5 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest10</span><br><span class="line">./sdriver.pl -t trace10.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace10.txt - Process fg builtin command. </span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./myspin 4 &amp;</span><br><span class="line">[1] (7350) ./myspin 4 &amp;</span><br><span class="line">tsh&gt; <span class="built_in">fg</span> %1</span><br><span class="line">Job [1] (7350) stopped by signal 20</span><br><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br><span class="line">[1] (7350) Stopped ./myspin 4 &amp;</span><br><span class="line">tsh&gt; <span class="built_in">fg</span> %1</span><br><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make test10</span><br><span class="line">./sdriver.pl -t trace10.txt -s ./tsh -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace10.txt - Process fg builtin command. </span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./myspin 4 &amp;</span><br><span class="line">[1] (7361) ./myspin 4 &amp;</span><br><span class="line">tsh&gt; <span class="built_in">fg</span> %1</span><br><span class="line">Job [1] (7361) stopped by signal 20</span><br><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br><span class="line">[1] (7361) Stopped ./myspin 4 &amp;</span><br><span class="line">tsh&gt; <span class="built_in">fg</span> %1</span><br><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br></pre></td></tr></table></figure>

<p>与参考一致，通关~</p>
<h3 id="test11-amp-test12-amp-test13"><a href="#test11-amp-test12-amp-test13" class="headerlink" title="test11 &amp; test12 &amp; test13"></a>test11 &amp; test12 &amp; test13</h3><p>先看看test11</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest11</span><br><span class="line">./sdriver.pl -t trace11.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace11.txt - Forward SIGINT to every process in foreground process group</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure>

<p>要求我们接收到SIGINT的时候把它发送给前台进程所处的进程组的所有进程。这个在我们前面的代码中的<code>sigint_handler</code>就已经有所处理了。</p>
<p>然后看看test12</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest12</span><br><span class="line">./sdriver.pl -t trace12.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace12.txt - Forward SIGTSTP to every process in foreground process group</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure>

<p>和测试11类似，我们接受到SIGTSTP的时候要把信号发给前台进程所处的进程组的所有进程。这个在<code>sigtstp_handler</code>就已经处理了。</p>
<p>再看看test13</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest13</span><br><span class="line">./sdriver.pl -t trace13.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace13.txt - Restart every stopped process in process group</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure>

<p>这个测试检测的是能够重启一个进程(原来是stopped状态)，这个功能在对于内置指令<code>fg</code>以及<code>bg</code>的处理上已经实现了。</p>
<blockquote>
<p>对于Linux下的ps命令a参数表示显示所有的进程</p>
<p>状态码：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Here are the different values that the s, <span class="built_in">stat</span> and state output specifiers (header <span class="string">&quot;STAT&quot;</span> or <span class="string">&quot;S&quot;</span>) will display to describe the state of a process:</span><br><span class="line"></span><br><span class="line">        D    uninterruptible <span class="built_in">sleep</span> (usually IO)</span><br><span class="line">        R    running or runnable (on run queue)</span><br><span class="line">        S    interruptible <span class="built_in">sleep</span> (waiting <span class="keyword">for</span> an event to complete)</span><br><span class="line">        T    stopped by job control signal</span><br><span class="line">        t    stopped by debugger during the tracing</span><br><span class="line">        W    paging (not valid since the 2.6.xx kernel)</span><br><span class="line">        X    dead (should never be seen)</span><br><span class="line">        Z    defunct (<span class="string">&quot;zombie&quot;</span>) process, terminated but not reaped by its parent</span><br><span class="line"></span><br><span class="line">For BSD formats and when the <span class="built_in">stat</span> keyword is used, additional characters may be displayed:</span><br><span class="line">        &lt;    high-priority (not <span class="built_in">nice</span> to other <span class="built_in">users</span>)</span><br><span class="line">        N    low-priority (<span class="built_in">nice</span> to other <span class="built_in">users</span>)</span><br><span class="line">        L    has pages locked into memory (<span class="keyword">for</span> real-time and custom IO)</span><br><span class="line">        s    is a session leader</span><br><span class="line">        l    is multi-threaded (using CLONE_THREAD, like NPTL pthreads <span class="keyword">do</span>)</span><br><span class="line">           +    is <span class="keyword">in</span> the foreground process group</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>我们直接对比测试结果</strong></p>
<ul>
<li><strong>test11</strong></li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest11</span><br><span class="line">./sdriver.pl -t trace11.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace11.txt - Forward SIGINT to every process in foreground process group</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./mysplit 4</span><br><span class="line">Job [1] (7419) terminated by signal 2</span><br><span class="line">tsh&gt; /bin/ps a</span><br><span class="line">  PID TTY      STAT   TIME COMMAND</span><br><span class="line"> 1190 tty4     Ss+    0:00 /sbin/getty -8 38400 tty4</span><br><span class="line"> 1197 tty5     Ss+    0:00 /sbin/getty -8 38400 tty5</span><br><span class="line"> 1207 tty2     Ss+    0:00 /sbin/getty -8 38400 tty2</span><br><span class="line"> 1209 tty3     Ss+    0:00 /sbin/getty -8 38400 tty3</span><br><span class="line"> 1230 tty6     Ss+    0:00 /sbin/getty -8 38400 tty6</span><br><span class="line"> 1352 tty7     Ss+   23:36 /usr/bin/X :0 -auth /var/run/lightdm/root/:0 -nolisten tcp vt7 -novtswitch -background none</span><br><span class="line"> 1785 tty1     Ss+    0:00 /sbin/getty -8 38400 tty1</span><br><span class="line"> 6865 pts/0    Ss     0:00 bash</span><br><span class="line"> 6971 pts/1    Ss+    0:00 /bin/bash</span><br><span class="line"> 7255 pts/0    R     39:18 ./tsh -p</span><br><span class="line"> 7256 pts/0    Z      0:00 [<span class="built_in">echo</span>] &lt;defunct&gt;</span><br><span class="line"> 7414 pts/0    S+     0:00 make rtest11</span><br><span class="line"> 7415 pts/0    S+     0:00 /bin/sh -c ./sdriver.pl -t trace11.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"> 7416 pts/0    S+     0:00 /usr/bin/perl ./sdriver.pl -t trace11.txt -s ./tshref -a -p</span><br><span class="line"> 7417 pts/0    S+     0:00 ./tshref -p</span><br><span class="line"> 7422 pts/0    R      0:00 /bin/ps a</span><br><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make test11</span><br><span class="line">./sdriver.pl -t trace11.txt -s ./tsh -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace11.txt - Forward SIGINT to every process in foreground process group</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./mysplit 4</span><br><span class="line">Job [1] (7433) terminated by signal 2</span><br><span class="line">tsh&gt; /bin/ps a</span><br><span class="line">  PID TTY      STAT   TIME COMMAND</span><br><span class="line"> 1190 tty4     Ss+    0:00 /sbin/getty -8 38400 tty4</span><br><span class="line"> 1197 tty5     Ss+    0:00 /sbin/getty -8 38400 tty5</span><br><span class="line"> 1207 tty2     Ss+    0:00 /sbin/getty -8 38400 tty2</span><br><span class="line"> 1209 tty3     Ss+    0:00 /sbin/getty -8 38400 tty3</span><br><span class="line"> 1230 tty6     Ss+    0:00 /sbin/getty -8 38400 tty6</span><br><span class="line"> 1352 tty7     Ss+   23:37 /usr/bin/X :0 -auth /var/run/lightdm/root/:0 -nolisten tcp vt7 -novtswitch -background none</span><br><span class="line"> 1785 tty1     Ss+    0:00 /sbin/getty -8 38400 tty1</span><br><span class="line"> 6865 pts/0    Ss     0:00 bash</span><br><span class="line"> 6971 pts/1    Ss+    0:00 /bin/bash</span><br><span class="line"> 7255 pts/0    R     39:26 ./tsh -p</span><br><span class="line"> 7256 pts/0    Z      0:00 [<span class="built_in">echo</span>] &lt;defunct&gt;</span><br><span class="line"> 7428 pts/0    S+     0:00 make test11</span><br><span class="line"> 7429 pts/0    S+     0:00 /bin/sh -c ./sdriver.pl -t trace11.txt -s ./tsh -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"> 7430 pts/0    S+     0:00 /usr/bin/perl ./sdriver.pl -t trace11.txt -s ./tsh -a -p</span><br><span class="line"> 7431 pts/0    R+     0:02 ./tsh -p</span><br><span class="line"> 7436 pts/0    R      0:00 /bin/ps a</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>test12</strong>和<strong>test13</strong>略（答案太长了）</li>
</ul>
<h3 id="test14"><a href="#test14" class="headerlink" title="test14"></a>test14</h3><p>这个测试需要对<code>fg</code>和<code>bg</code>的输入参数进行一些错误处理。例如没有参数或参数非数值或所选任务或进程不存在等。修改<code>do_bgfg</code>函数如。（&#x2F;* ADD PART *&#x2F;带有这个标签的就是增加的功能）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * do_bgfg - Execute the builtin bg and fg commands</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_bgfg</span><span class="params">(<span class="type">char</span>** argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">job_t</span>* <span class="title">job</span>;</span></span><br><span class="line">    <span class="type">char</span>* id = argv[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ADD PART bg和fg后边不跟任何参数不执行直接返回 */</span></span><br><span class="line">    <span class="comment">// no argument for bg/fg</span></span><br><span class="line">    <span class="keyword">if</span> (id == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s command requires PID or %%jobid argument\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 判断输入的是jid还是pid</span></span><br><span class="line">    <span class="keyword">if</span> (id[<span class="number">0</span>] == <span class="string">&#x27;%&#x27;</span>) &#123; <span class="comment">/* jid */</span></span><br><span class="line">        <span class="comment">/* ADD PART 检查输入的jid是不是数字 */</span></span><br><span class="line">        <span class="keyword">if</span> (!checkNum(id + <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s: argument must be a PID or %%jobid\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//去掉&#x27;%&#x27;开始读jid，根据jid返回这个子进程的结构指针</span></span><br><span class="line">        <span class="type">int</span> jid = atoi(id + <span class="number">1</span>);</span><br><span class="line">        job = getjobjid(jobs, jid);</span><br><span class="line">        <span class="comment">/* ADD PART 找不到输入的这个作业 */</span></span><br><span class="line">        <span class="keyword">if</span> (job == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%%%d: No such job\n&quot;</span>, jid);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;              <span class="comment">/* pid */</span></span><br><span class="line">        <span class="comment">/* ADD PART  检查输入的pid是不是数字 */</span></span><br><span class="line">        <span class="keyword">if</span> (!checkNum(id)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s: argument must be a PID or %%jobid\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> pid = atoi(id);</span><br><span class="line">        job = getjobpid(jobs, pid);</span><br><span class="line">        <span class="comment">/* ADD PART 找不到这个作业 */</span></span><br><span class="line">        <span class="keyword">if</span> (job == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;(%d): No such process\n&quot;</span>, pid);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    * kill不单是杀掉进程，还有发送信号的功能 </span></span><br><span class="line"><span class="comment">    * 这里唤醒job所在的组中的所有进程</span></span><br><span class="line"><span class="comment">    * 就是唤醒这个stopped的子进程，以及它派生的孙子进程</span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">    kill(-(job-&gt;pid), SIGCONT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;fg&quot;</span>)) &#123;  <span class="comment">// fg command</span></span><br><span class="line">        job-&gt;state = FG;</span><br><span class="line">        <span class="comment">// 等待该前台作业终止</span></span><br><span class="line">        waitfg(job-&gt;pid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;                         <span class="comment">// bg command</span></span><br><span class="line">        job-&gt;state = BG;</span><br><span class="line">        <span class="comment">/* 切换到bg后打印作业信息 */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%d] (%d) %s&quot;</span>, pid2jid(job-&gt;pid), job-&gt;pid, job-&gt;cmdline);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看参考输出</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest14</span><br><span class="line">./sdriver.pl -t trace14.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace14.txt - Simple error handling</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./bogus</span><br><span class="line">./bogus: Command not found</span><br><span class="line">tsh&gt; ./myspin 4 &amp;</span><br><span class="line">[1] (7521) ./myspin 4 &amp;</span><br><span class="line">tsh&gt; <span class="built_in">fg</span></span><br><span class="line"><span class="built_in">fg</span> <span class="built_in">command</span> requires PID or %jobid argument</span><br><span class="line">tsh&gt; <span class="built_in">bg</span></span><br><span class="line"><span class="built_in">bg</span> <span class="built_in">command</span> requires PID or %jobid argument</span><br><span class="line">tsh&gt; <span class="built_in">fg</span> a</span><br><span class="line"><span class="built_in">fg</span>: argument must be a PID or %jobid</span><br><span class="line">tsh&gt; <span class="built_in">bg</span> a</span><br><span class="line"><span class="built_in">bg</span>: argument must be a PID or %jobid</span><br><span class="line">tsh&gt; <span class="built_in">fg</span> 9999999</span><br><span class="line">(9999999): No such process</span><br><span class="line">tsh&gt; <span class="built_in">bg</span> 9999999</span><br><span class="line">(9999999): No such process</span><br><span class="line">tsh&gt; <span class="built_in">fg</span> %2</span><br><span class="line">%2: No such job</span><br><span class="line">tsh&gt; <span class="built_in">fg</span> %1</span><br><span class="line">Job [1] (7521) stopped by signal 20</span><br><span class="line">tsh&gt; <span class="built_in">bg</span> %2</span><br><span class="line">%2: No such job</span><br><span class="line">tsh&gt; <span class="built_in">bg</span> %1</span><br><span class="line">[1] (7521) ./myspin 4 &amp;</span><br><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br><span class="line">[1] (7521) Running ./myspin 4 &amp;</span><br><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make test14</span><br><span class="line">./sdriver.pl -t trace14.txt -s ./tsh -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace14.txt - Simple error handling</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./bogus</span><br><span class="line">tsh&gt; ./myspin 4 &amp;</span><br><span class="line">[1] (7540) ./myspin 4 &amp;</span><br><span class="line">tsh&gt; <span class="built_in">fg</span></span><br><span class="line"><span class="built_in">fg</span> <span class="built_in">command</span> requires PID or %jobid argument</span><br><span class="line">tsh&gt; <span class="built_in">bg</span></span><br><span class="line"><span class="built_in">bg</span> <span class="built_in">command</span> requires PID or %jobid argument</span><br><span class="line">tsh&gt; <span class="built_in">fg</span> a</span><br><span class="line"><span class="built_in">fg</span>: argument must be a PID or %jobid</span><br><span class="line">tsh&gt; <span class="built_in">bg</span> a</span><br><span class="line"><span class="built_in">bg</span>: argument must be a PID or %jobid</span><br><span class="line">tsh&gt; <span class="built_in">fg</span> 9999999</span><br><span class="line">(9999999): No such process</span><br><span class="line">tsh&gt; <span class="built_in">bg</span> 9999999</span><br><span class="line">(9999999): No such process</span><br><span class="line">tsh&gt; <span class="built_in">fg</span> %2</span><br><span class="line">%2: No such job</span><br><span class="line">tsh&gt; <span class="built_in">fg</span> %1</span><br><span class="line">Job [1] (7540) stopped by signal 20</span><br><span class="line">tsh&gt; <span class="built_in">bg</span> %2</span><br><span class="line">%2: No such job</span><br><span class="line">tsh&gt; <span class="built_in">bg</span> %1</span><br><span class="line">[1] (7540) ./myspin 4 &amp;</span><br><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br><span class="line">[1] (7540) Running ./myspin 4 &amp;</span><br></pre></td></tr></table></figure>

<p>对于输入的不合法的pid不是数字（例如44行）或者没有没有参数（42行）或者单纯没有这个pid（48行），都会进行处理并返回而不是崩溃。这个功能的晚上增强了<em>shell</em>的鲁棒性。</p>
<p>和参考基本一致，通关~</p>
<h3 id="test15-amp-test16"><a href="#test15-amp-test16" class="headerlink" title="test15 &amp; test16"></a>test15 &amp; test16</h3><p>我们看看测试的要求</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest15</span><br><span class="line">./sdriver.pl -t trace15.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace15.txt - Putting it all together</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure>

<p>测试15是要我们把所有的方法放在一起。这个都不要做，本来就在一个文件<code>tsh.c</code>下写的。。。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest16</span><br><span class="line">./sdriver.pl -t trace16.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace16.txt - Tests whether the shell can handle SIGTSTP and SIGINT</span></span><br><span class="line"><span class="comment">#     signals that come from other processes instead of the terminal.</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure>

<p>这个测试要我们测试<em>shell</em>收到SIGINT或者SIGTSTP的来源不是中断而是其他进程是否仍然能够正常工作。这个也不需要做什么。原因有二</p>
<ul>
<li>我们前面的<code>make testn</code>的时候，就是把我们的<code>tsh</code>作为<code>shell driver</code>的子进程，然后驱动给我们的<code>tsh</code>发送测试指令。其中就有SIGINT和SIGTSTP，我们能过够通过前面的，肯定是对的。</li>
<li>我们的<code>tsh</code>至始至终实现对的都是收到信号，然后对自己的孩子怎么处理。至于如何接受外部信号，是从中断收到还是其他的进程收到，我们实验过程中虽然没有关注到。但是我们在从unix的<em>shell</em>输入“.&#x2F;tsh”之后进入到<em>tsh</em>。<ul>
<li>这个过程是内核捕捉到SIGINT等信号发送给我们的unix shell，然后unix shell会把这些信号有发送给tsh，然后tsh又把它发送给子进程们。</li>
<li>关系如下图。</li>
</ul>
</li>
</ul>
<img src="/2022/05/26/CSAPP-shlab-report/image-20220526221432408.png" alt="image-20220526221432408" style="zoom:80%;">

<p>还有一个小知识点：参考<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/5422831/what-is-the-difference-between-using-exit-exit-in-a-conventional-linux-fo">exit与_exit的区别</a>，可以知道<strong>在fork出的child中要用_exit来退出</strong>，否则exit会调用用atexit注册的函数并刷新父进程的缓冲区。一般来说在一个main函数中只调用一次exit或return。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in `eval`</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">/* </span></span><br><span class="line"><span class="comment">            * 前台执行 </span></span><br><span class="line"><span class="comment">            * 如果没有这个可执行程序，那么直接终止这个子进程</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">if</span> (execve(argv[<span class="number">0</span>], argv, environ) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s: Command not found.\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">                _exit(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>





<h3 id="tsh-c文件综合"><a href="#tsh-c文件综合" class="headerlink" title="tsh.c文件综合"></a>tsh.c文件综合</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * tsh - A tiny shell program with job control</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;Puitar&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Misc manifest constants */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLINE    1024   <span class="comment">/* max line size */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXARGS     128   <span class="comment">/* max args on a command line */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXJOBS      16   <span class="comment">/* max jobs at any point in time */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXJID    1&lt;&lt;16   <span class="comment">/* max job ID */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Job states */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNDEF 0 <span class="comment">/* undefined */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FG 1    <span class="comment">/* running in foreground */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BG 2    <span class="comment">/* running in background */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ST 3    <span class="comment">/* stopped */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Jobs states: FG (foreground), BG (background), ST (stopped)</span></span><br><span class="line"><span class="comment"> * Job state transitions and enabling actions:</span></span><br><span class="line"><span class="comment"> *     FG -&gt; ST  : ctrl-z</span></span><br><span class="line"><span class="comment"> *     ST -&gt; FG  : fg command</span></span><br><span class="line"><span class="comment"> *     ST -&gt; BG  : bg command</span></span><br><span class="line"><span class="comment"> *     BG -&gt; FG  : fg command</span></span><br><span class="line"><span class="comment"> * At most 1 job can be in the FG state.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Global variables */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span>** environ;      <span class="comment">/* defined in libc */</span></span><br><span class="line"><span class="type">char</span> prompt[] = <span class="string">&quot;tsh&gt; &quot;</span>;    <span class="comment">/* command line prompt (DO NOT CHANGE) */</span></span><br><span class="line"><span class="type">int</span> verbose = <span class="number">0</span>;            <span class="comment">/* if true, print additional output */</span></span><br><span class="line"><span class="type">int</span> nextjid = <span class="number">1</span>;            <span class="comment">/* next job ID to allocate */</span></span><br><span class="line"><span class="type">char</span> sbuf[MAXLINE];         <span class="comment">/* for composing sprintf messages */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> &#123;</span>              <span class="comment">/* The job struct */</span></span><br><span class="line">    <span class="type">pid_t</span> pid;              <span class="comment">/* job PID */</span></span><br><span class="line">    <span class="type">int</span> jid;                <span class="comment">/* job ID [1, 2, ...] */</span></span><br><span class="line">    <span class="type">int</span> state;              <span class="comment">/* UNDEF, BG, FG, or ST */</span></span><br><span class="line">    <span class="type">char</span> cmdline[MAXLINE];  <span class="comment">/* command line */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> <span class="title">jobs</span>[<span class="title">MAXJOBS</span>];</span> <span class="comment">/* The job list */</span></span><br><span class="line"><span class="comment">/* End global variables */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Function prototypes */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Here are the functions that you will implement */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">eval</span><span class="params">(<span class="type">char</span>* cmdline)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">builtin_cmd</span><span class="params">(<span class="type">char</span>** argv)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">do_bgfg</span><span class="params">(<span class="type">char</span>** argv)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">waitfg</span><span class="params">(<span class="type">pid_t</span> pid)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sigchld_handler</span><span class="params">(<span class="type">int</span> sig)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sigtstp_handler</span><span class="params">(<span class="type">int</span> sig)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sigint_handler</span><span class="params">(<span class="type">int</span> sig)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Here are helper routines that we&#x27;ve provided for you */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">parseline</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* cmdline, <span class="type">char</span>** argv)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sigquit_handler</span><span class="params">(<span class="type">int</span> sig)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">clearjob</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span>* job)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">initjobs</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span>* jobs)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">maxjid</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span>* jobs)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">addjob</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span>* jobs, <span class="type">pid_t</span> pid, <span class="type">int</span> state, <span class="type">char</span>* cmdline)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">deletejob</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span>* jobs, <span class="type">pid_t</span> pid)</span>;</span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fgpid</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span>* jobs)</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="type">job_t</span>* <span class="title function_">getjobpid</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span>* jobs, <span class="type">pid_t</span> pid)</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="type">job_t</span>* <span class="title function_">getjobjid</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span>* jobs, <span class="type">int</span> jid)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pid2jid</span><span class="params">(<span class="type">pid_t</span> pid)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">listjobs</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span>* jobs)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">usage</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">unix_error</span><span class="params">(<span class="type">char</span>* msg)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">app_error</span><span class="params">(<span class="type">char</span>* msg)</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> <span class="title function_">handler_t</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">handler_t</span>* <span class="title function_">Signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">handler_t</span>* handler)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// wrapper functions get from csapp.h</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Sigprocmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span>* <span class="built_in">set</span>, <span class="type">sigset_t</span>* oldset)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Sigemptyset</span><span class="params">(<span class="type">sigset_t</span>* <span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Sigaddset</span><span class="params">(<span class="type">sigset_t</span>* <span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sio package declaration from csapp.h</span></span><br><span class="line"><span class="comment">/* Sio (Signal-safe I/O) routines */</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">sio_puts</span><span class="params">(<span class="type">char</span> s[])</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">sio_putl</span><span class="params">(<span class="type">long</span> v)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sio_error</span><span class="params">(<span class="type">char</span> s[])</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Sio wrappers */</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">Sio_puts</span><span class="params">(<span class="type">char</span> s[])</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">Sio_putl</span><span class="params">(<span class="type">long</span> v)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Sio_error</span><span class="params">(<span class="type">char</span> s[])</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * main - The shell&#x27;s main routine</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">char</span> cmdline[MAXLINE];</span><br><span class="line">    <span class="type">int</span> emit_prompt = <span class="number">1</span>; <span class="comment">/* emit prompt (default) */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Redirect stderr to stdout (so that driver will get all output</span></span><br><span class="line"><span class="comment">     * on the pipe connected to stdout) */</span></span><br><span class="line">    dup2(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Parse the command line */</span></span><br><span class="line">    <span class="keyword">while</span> ((c = getopt(argc, argv, <span class="string">&quot;hvp&quot;</span>)) != EOF) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:             <span class="comment">/* print help message */</span></span><br><span class="line">                usage();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;v&#x27;</span>:             <span class="comment">/* emit additional diagnostic info */</span></span><br><span class="line">                verbose = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;p&#x27;</span>:             <span class="comment">/* don&#x27;t print a prompt */</span></span><br><span class="line">                emit_prompt = <span class="number">0</span>;  <span class="comment">/* handy for automatic testing */</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                usage();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Install the signal handlers */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* These are the ones you will need to implement */</span></span><br><span class="line">    Signal(SIGINT, sigint_handler);   <span class="comment">/* ctrl-c */</span></span><br><span class="line">    Signal(SIGTSTP, sigtstp_handler);  <span class="comment">/* ctrl-z */</span></span><br><span class="line">    Signal(SIGCHLD, sigchld_handler);  <span class="comment">/* Terminated or stopped child */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This one provides a clean way to kill the shell */</span></span><br><span class="line">    Signal(SIGQUIT, sigquit_handler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initialize the job list */</span></span><br><span class="line">    initjobs(jobs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Execute the shell&#x27;s read/eval loop */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Read command line */</span></span><br><span class="line">        <span class="keyword">if</span> (emit_prompt) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, prompt);</span><br><span class="line">            fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((fgets(cmdline, MAXLINE, <span class="built_in">stdin</span>) == <span class="literal">NULL</span>) &amp;&amp; ferror(<span class="built_in">stdin</span>))</span><br><span class="line">            app_error(<span class="string">&quot;fgets error&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (feof(<span class="built_in">stdin</span>)) &#123; <span class="comment">/* End of file (ctrl-d) */</span></span><br><span class="line">            fflush(<span class="built_in">stdout</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Evaluate the command line */</span></span><br><span class="line">        eval(cmdline);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">/* control never reaches here */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * eval - Evaluate the command line that the user has just typed in</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If the user has requested a built-in command (quit, jobs, bg or fg)</span></span><br><span class="line"><span class="comment"> * then execute it immediately. Otherwise, fork a child process and</span></span><br><span class="line"><span class="comment"> * run the job in the context of the child. If the job is running in</span></span><br><span class="line"><span class="comment"> * the foreground, wait for it to terminate and then return.  Note:</span></span><br><span class="line"><span class="comment"> * each child process must have a unique process group ID so that our</span></span><br><span class="line"><span class="comment"> * background children don&#x27;t receive SIGINT (SIGTSTP) from the kernel</span></span><br><span class="line"><span class="comment"> * when we type ctrl-c (ctrl-z) at the keyboard.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">eval</span><span class="params">(<span class="type">char</span>* cmdline)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>* argv[MAXARGS]; <span class="comment">/* argv for execve() */</span></span><br><span class="line">    <span class="type">int</span> bg;              <span class="comment">/* Should the job run in bg or fg? */</span></span><br><span class="line">    <span class="type">pid_t</span> pid;           <span class="comment">/* Process id */</span></span><br><span class="line">    <span class="type">sigset_t</span> mask, prev;</span><br><span class="line"></span><br><span class="line">    bg = parseline(cmdline, argv);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (argv[<span class="number">0</span>] == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;   <span class="comment">/* Ignore empty lines */</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 这里参考课本520的方法</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * sigemptyset是设置一个信号集</span></span><br><span class="line"><span class="comment">    * sigaddset是向mask中添加SIGCHLD信号</span></span><br><span class="line"><span class="comment">    * sigprocmask是保存现在的信号集到prev然后根据第一个参数设置信号集为mask</span></span><br><span class="line"><span class="comment">    *	第二个参数设置成当前阻塞信号集合</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    Sigemptyset(&amp;mask);</span><br><span class="line">    Sigaddset(&amp;mask, SIGCHLD);</span><br><span class="line">	</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!builtin_cmd(argv)) &#123;</span><br><span class="line">        Sigprocmask(SIG_BLOCK, &amp;mask, &amp;prev);  <span class="comment">/* 阻塞SIGCHLD */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((pid = fork()) == <span class="number">0</span>) &#123;   <span class="comment">/* Child runs user job */</span></span><br><span class="line">            <span class="comment">/* 给fork出来的子进程设置一个独立的组，</span></span><br><span class="line"><span class="comment">	 		 * 子进程是这个组的组长,组id为子进程的pid */</span></span><br><span class="line">            setpgid(<span class="number">0</span>, <span class="number">0</span>);	</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/* 对于子进程并不需要阻塞SIGCHLD的信号 */</span></span><br><span class="line">            Sigprocmask(SIG_UNBLOCK, &amp;prev, <span class="literal">NULL</span>);  <span class="comment">// unblock SIGCHLD</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">/* </span></span><br><span class="line"><span class="comment">            * 前台执行 </span></span><br><span class="line"><span class="comment">            * 如果没有这个可执行程序，那么直接终止这个子进程</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">if</span> (execve(argv[<span class="number">0</span>], argv, environ) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s: Command not found.\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">                _exit(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        addjob(jobs, pid, bg ? BG : FG, cmdline);</span><br><span class="line">        <span class="comment">/* 已经加到jobs了，解除阻塞 */</span></span><br><span class="line">        Sigprocmask(SIG_SETMASK, &amp;prev, <span class="literal">NULL</span>);  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Parent waits for foreground job to terminate */</span></span><br><span class="line">        <span class="keyword">if</span> (!bg)  <span class="comment">// 前台运行则等待子进程</span></span><br><span class="line">            waitfg(pid);</span><br><span class="line">        <span class="keyword">else</span>      <span class="comment">// background</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[%d] (%d) %s&quot;</span>, pid2jid(pid), pid, cmdline);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * parseline - Parse the command line and build the argv array.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Characters enclosed in single quotes are treated as a single</span></span><br><span class="line"><span class="comment"> * argument.  Return true if the user has requested a BG job, false if</span></span><br><span class="line"><span class="comment"> * the user has requested a FG job.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">parseline</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* cmdline, <span class="type">char</span>** argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> <span class="built_in">array</span>[MAXLINE]; <span class="comment">/* holds local copy of command line */</span></span><br><span class="line">    <span class="type">char</span>* buf = <span class="built_in">array</span>;          <span class="comment">/* ptr that traverses command line */</span></span><br><span class="line">    <span class="type">char</span>* delim;                <span class="comment">/* points to first space delimiter */</span></span><br><span class="line">    <span class="type">int</span> argc;                   <span class="comment">/* number of args */</span></span><br><span class="line">    <span class="type">int</span> bg;                     <span class="comment">/* background job? */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(buf, cmdline);</span><br><span class="line">    buf[<span class="built_in">strlen</span>(buf) - <span class="number">1</span>] = <span class="string">&#x27; &#x27;</span>;  <span class="comment">/* replace trailing &#x27;\n&#x27; with space */</span></span><br><span class="line">    <span class="keyword">while</span> (*buf &amp;&amp; (*buf == <span class="string">&#x27; &#x27;</span>)) <span class="comment">/* ignore leading spaces */</span></span><br><span class="line">        buf++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Build the argv list */</span></span><br><span class="line">    argc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (*buf == <span class="string">&#x27;\&#x27;&#x27;</span>) &#123;</span><br><span class="line">        buf++;</span><br><span class="line">        delim = <span class="built_in">strchr</span>(buf, <span class="string">&#x27;\&#x27;&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        delim = <span class="built_in">strchr</span>(buf, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (delim) &#123;</span><br><span class="line">        argv[argc++] = buf;</span><br><span class="line">        *delim = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        buf = delim + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (*buf &amp;&amp; (*buf == <span class="string">&#x27; &#x27;</span>)) <span class="comment">/* ignore spaces */</span></span><br><span class="line">            buf++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (*buf == <span class="string">&#x27;\&#x27;&#x27;</span>) &#123;</span><br><span class="line">            buf++;</span><br><span class="line">            delim = <span class="built_in">strchr</span>(buf, <span class="string">&#x27;\&#x27;&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            delim = <span class="built_in">strchr</span>(buf, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    argv[argc] = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">0</span>)  <span class="comment">/* ignore blank line */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* should the job run in the background? */</span></span><br><span class="line">    <span class="keyword">if</span> ((bg = (*argv[argc - <span class="number">1</span>] == <span class="string">&#x27;&amp;&#x27;</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">        argv[--argc] = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * builtin_cmd - If the user has typed a built-in command then execute</span></span><br><span class="line"><span class="comment"> *    it immediately.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">builtin_cmd</span><span class="params">(<span class="type">char</span>** argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// quit command</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;quit&quot;</span>))</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// jobs command</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;jobs&quot;</span>)) &#123;</span><br><span class="line">        listjobs(jobs);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bg or fg command</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;bg&quot;</span>) || !<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;fg&quot;</span>)) &#123;</span><br><span class="line">        do_bgfg(argv);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ignore singleton &amp; (不处理单独的 &#x27;&amp;&#x27;)</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;&amp;&quot;</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// not a build-in command</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// check if arg is a string of nums</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">checkNum</span><span class="params">(<span class="type">char</span>* arg)</span> &#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(arg);</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">isdigit</span>(arg[i])) <span class="comment">// not num</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * do_bgfg - Execute the builtin bg and fg commands</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_bgfg</span><span class="params">(<span class="type">char</span>** argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">job_t</span>* <span class="title">job</span>;</span></span><br><span class="line">    <span class="type">char</span>* id = argv[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// no argument for bg/fg</span></span><br><span class="line">    <span class="keyword">if</span> (id == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s command requires PID or %%jobid argument\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 判断输入的是jid还是pid</span></span><br><span class="line">    <span class="keyword">if</span> (id[<span class="number">0</span>] == <span class="string">&#x27;%&#x27;</span>) &#123; <span class="comment">/* jid */</span></span><br><span class="line">        <span class="keyword">if</span> (!checkNum(id + <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s: argument must be a PID or %%jobid\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//去掉&#x27;%&#x27;开始读jid，根据jid返回这个子进程的结构指针</span></span><br><span class="line">        <span class="type">int</span> jid = atoi(id + <span class="number">1</span>);</span><br><span class="line">        job = getjobjid(jobs, jid);</span><br><span class="line">        <span class="keyword">if</span> (job == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%%%d: No such job\n&quot;</span>, jid);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;              <span class="comment">/* pid */</span></span><br><span class="line">        <span class="keyword">if</span> (!checkNum(id)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s: argument must be a PID or %%jobid\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> pid = atoi(id);</span><br><span class="line">        job = getjobpid(jobs, pid);</span><br><span class="line">        <span class="keyword">if</span> (job == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;(%d): No such process\n&quot;</span>, pid);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    * kill不单是杀掉进程，还有发送信号的功能 </span></span><br><span class="line"><span class="comment">    * 这里唤醒job所在的组中的所有进程</span></span><br><span class="line"><span class="comment">    * 就是唤醒这个stopped的子进程，以及它派生的孙子进程</span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">    kill(-(job-&gt;pid), SIGCONT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;fg&quot;</span>)) &#123;  <span class="comment">// fg command</span></span><br><span class="line">        job-&gt;state = FG;</span><br><span class="line">        <span class="comment">// 等待该前台作业终止</span></span><br><span class="line">        waitfg(job-&gt;pid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;                         <span class="comment">// bg command</span></span><br><span class="line">        job-&gt;state = BG;</span><br><span class="line">        <span class="comment">/* 切换到bg后打印作业信息 */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%d] (%d) %s&quot;</span>, pid2jid(job-&gt;pid), job-&gt;pid, job-&gt;cmdline);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * waitfg - Block until process pid is no longer the foreground process</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">waitfg</span><span class="params">(<span class="type">pid_t</span> pid)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (pid == fgpid(jobs))</span><br><span class="line">        sleep(<span class="number">0</span>); <span class="comment">// 这里是主动让出CPU</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*****************</span></span><br><span class="line"><span class="comment"> * Signal handlers</span></span><br><span class="line"><span class="comment"> *****************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sigchld_handler - The kernel sends a SIGCHLD to the shell whenever</span></span><br><span class="line"><span class="comment"> *     a child job terminates (becomes a zombie), or stops because it</span></span><br><span class="line"><span class="comment"> *     received a SIGSTOP or SIGTSTP signal. The handler reaps all</span></span><br><span class="line"><span class="comment"> *     available zombie children, but doesn&#x27;t wait for any other</span></span><br><span class="line"><span class="comment"> *     currently running children to terminate.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sigchld_handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> old_errno = errno;</span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (verbose)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sigchld_handler: entering \n&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* </span></span><br><span class="line"><span class="comment">    * 回收僵尸进程</span></span><br><span class="line"><span class="comment">    * 这里的WNOHANG是非常重要的。</span></span><br><span class="line"><span class="comment">    * 它的本意是如果所有孩子都没有僵尸(终止)状态的，直接退出</span></span><br><span class="line"><span class="comment">    * 这个能够避免在这里等待所有前台的running和stopped程序终止</span></span><br><span class="line"><span class="comment">    * 这样tsh就不能正常接受用户的输入了</span></span><br><span class="line"><span class="comment">    * WUNTRACED是等待直到有一个子进程变成僵尸退出，返回它的pid</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">while</span> ((pid = waitpid(<span class="number">-1</span>, &amp;status, WNOHANG | WUNTRACED)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程正常退出</span></span><br><span class="line">        <span class="keyword">if</span> (WIFEXITED(status)) &#123;</span><br><span class="line">            deletejob(jobs, pid);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 子进程因为ctrl-c退出</span></span><br><span class="line">        <span class="keyword">if</span> (WIFSIGNALED(status)) &#123; <span class="comment">// terminated by ctrl-c</span></span><br><span class="line">            <span class="comment">/* printf(&quot;Job [%d] (%d) terminated by signal %2d\n&quot;, </span></span><br><span class="line"><span class="comment">                   pid2jid(pid), pid, WTERMSIG(status)); */</span> &#123;</span><br><span class="line">            	Sio_puts(<span class="string">&quot;Job [&quot;</span>);</span><br><span class="line">                Sio_putl(pid2jid(pid));</span><br><span class="line">                Sio_puts(<span class="string">&quot;] (&quot;</span>);</span><br><span class="line">                Sio_putl(pid);</span><br><span class="line">                Sio_puts(<span class="string">&quot;) terminated by signal &quot;</span>);</span><br><span class="line">                Sio_putl(WTERMSIG(status));</span><br><span class="line">                Sio_puts(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            deletejob(jobs, pid); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (WIFSTOPPED(status)) &#123; <span class="comment">// stopped by ctrl-z</span></span><br><span class="line">            <span class="comment">/* printf(&quot;Job [%d] (%d) stopped by signal %2d\n&quot;,</span></span><br><span class="line"><span class="comment">                   pid2jid(pid), pid, WSTOPSIG(status)); */</span> &#123;</span><br><span class="line">            	Sio_puts(<span class="string">&quot;Job [&quot;</span>);</span><br><span class="line">                Sio_putl(pid2jid(pid));</span><br><span class="line">                Sio_puts(<span class="string">&quot;] (&quot;</span>);</span><br><span class="line">                Sio_putl(pid);</span><br><span class="line">                Sio_puts(<span class="string">&quot;) stopped by signal &quot;</span>);</span><br><span class="line">                Sio_putl(WSTOPSIG(status));</span><br><span class="line">                Sio_puts(<span class="string">&quot;\n&quot;</span>);           </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 修改子进程状态为ST</span></span><br><span class="line">            getjobpid(jobs, pid)-&gt;state = ST;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (verbose) &#123;</span><br><span class="line">            <span class="comment">/* printf(&quot;sigchld_handler: job %d deleted\n&quot;, pid); */</span> &#123;</span><br><span class="line">                Sio_puts(<span class="string">&quot;sigchld_handler: job &quot;</span>);</span><br><span class="line">                Sio_putl(pid);</span><br><span class="line">                Sio_puts(<span class="string">&quot; deleted\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    errno = old_errno;</span><br><span class="line">    <span class="keyword">if</span> (verbose) &#123;</span><br><span class="line">        <span class="comment">/* printf(&quot;sigchld_handler: exiting\n&quot;); */</span> &#123;</span><br><span class="line">        	Sio_puts(<span class="string">&quot;sigchld_handler: exiting\n&quot;</span>);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;      </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sigint_handler - The kernel sends a SIGINT to the shell whenver the</span></span><br><span class="line"><span class="comment"> *    user types ctrl-c at the keyboard.  Catch it and send it along</span></span><br><span class="line"><span class="comment"> *    to the foreground job.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sigint_handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> olderrno = errno;</span><br><span class="line">    <span class="comment">// get the foreground job pid</span></span><br><span class="line">    <span class="type">pid_t</span> fg_pid = fgpid(jobs);</span><br><span class="line">    <span class="comment">// kill the group in the foreground</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * int kill(pid_t pid,int signo)</span></span><br><span class="line"><span class="comment"> 	* 功能: 向进程或进程组发送一个信号 （成功返回 0； 否则，返回 -1 ）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    kill(-fg_pid, sig); </span><br><span class="line">    <span class="comment">// -fg_pid表示向进程组号为pid的组中的每个进程发sig信号</span></span><br><span class="line">    <span class="comment">// 在这里就是向前台进程以及它的每一个子进程(子进程都在自己的父进程的pid为组id的组下)</span></span><br><span class="line">    errno = olderrno;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sigtstp_handler - The kernel sends a SIGTSTP to the shell whenever</span></span><br><span class="line"><span class="comment"> *     the user types ctrl-z at the keyboard. Catch it and suspend the</span></span><br><span class="line"><span class="comment"> *     foreground job by sending it a SIGTSTP.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sigtstp_handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 为了异步信号安全防止errno被覆盖</span></span><br><span class="line">    <span class="type">int</span> olderrno = errno;</span><br><span class="line">    <span class="comment">// get the foreground job pid</span></span><br><span class="line">    <span class="type">pid_t</span> fg_pid = fgpid(jobs);</span><br><span class="line">    <span class="comment">// kill the group in the foreground</span></span><br><span class="line">    kill(-fg_pid, sig);</span><br><span class="line">    errno = olderrno;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********************</span></span><br><span class="line"><span class="comment"> * End signal handlers</span></span><br><span class="line"><span class="comment"> *********************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************************************</span></span><br><span class="line"><span class="comment">  * Helper routines that manipulate the job list</span></span><br><span class="line"><span class="comment">  **********************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* clearjob - Clear the entries in a job struct */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">clearjob</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span>* job)</span> &#123;</span><br><span class="line">    job-&gt;pid = <span class="number">0</span>;</span><br><span class="line">    job-&gt;jid = <span class="number">0</span>;</span><br><span class="line">    job-&gt;state = UNDEF;</span><br><span class="line">    job-&gt;cmdline[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* initjobs - Initialize the job list */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">initjobs</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span>* jobs)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++)</span><br><span class="line">        clearjob(&amp;jobs[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* maxjid - Returns largest allocated job ID */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">maxjid</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span>* jobs)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, max = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++)</span><br><span class="line">        <span class="keyword">if</span> (jobs[i].jid &gt; max)</span><br><span class="line">            max = jobs[i].jid;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* addjob - Add a job to the job list */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">addjob</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span>* jobs, <span class="type">pid_t</span> pid, <span class="type">int</span> state, <span class="type">char</span>* cmdline)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++) &#123;</span><br><span class="line">        <span class="comment">/* 如果jobs数组里面有pid等于0等于0的表项，表示这个位置可以用，把这个作业放进去 */</span></span><br><span class="line">        <span class="keyword">if</span> (jobs[i].pid == <span class="number">0</span>) &#123;</span><br><span class="line">            jobs[i].pid = pid;</span><br><span class="line">            jobs[i].state = state;</span><br><span class="line">            jobs[i].jid = nextjid++;</span><br><span class="line">            <span class="keyword">if</span> (nextjid &gt; MAXJOBS)</span><br><span class="line">                nextjid = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">strcpy</span>(jobs[i].cmdline, cmdline);</span><br><span class="line">            <span class="keyword">if</span> (verbose) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Added job [%d] %d %s\n&quot;</span>, jobs[i].jid, jobs[i].pid, jobs[i].cmdline);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Tried to create too many jobs\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* deletejob - Delete a job whose PID=pid from the job list */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">deletejob</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span>* jobs, <span class="type">pid_t</span> pid)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (jobs[i].pid == pid) &#123;</span><br><span class="line">            clearjob(&amp;jobs[i]);</span><br><span class="line">            nextjid = maxjid(jobs) + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* fgpid - Return PID of current foreground job, 0 if no such job */</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fgpid</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span>* jobs)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++)</span><br><span class="line">        <span class="keyword">if</span> (jobs[i].state == FG)</span><br><span class="line">            <span class="keyword">return</span> jobs[i].pid;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* getjobpid  - Find a job (by PID) on the job list */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="type">job_t</span>* <span class="title function_">getjobpid</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span>* jobs, <span class="type">pid_t</span> pid)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++)</span><br><span class="line">        <span class="keyword">if</span> (jobs[i].pid == pid)</span><br><span class="line">            <span class="keyword">return</span> &amp;jobs[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* getjobjid  - Find a job (by JID) on the job list */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="type">job_t</span>* <span class="title function_">getjobjid</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span>* jobs, <span class="type">int</span> jid)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (jid &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++)</span><br><span class="line">        <span class="keyword">if</span> (jobs[i].jid == jid)</span><br><span class="line">            <span class="keyword">return</span> &amp;jobs[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* pid2jid - Map process ID to job ID */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pid2jid</span><span class="params">(<span class="type">pid_t</span> pid)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++)</span><br><span class="line">        <span class="keyword">if</span> (jobs[i].pid == pid) &#123;</span><br><span class="line">            <span class="keyword">return</span> jobs[i].jid;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* listjobs - Print the job list */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">listjobs</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span>* jobs)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (jobs[i].pid != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[%d] (%d) &quot;</span>, jobs[i].jid, jobs[i].pid);</span><br><span class="line">            <span class="keyword">switch</span> (jobs[i].state) &#123;</span><br><span class="line">                <span class="keyword">case</span> BG:</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Running &quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> FG:</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Foreground &quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> ST:</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Stopped &quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;listjobs: Internal error: job[%d].state=%d &quot;</span>,</span><br><span class="line">                           i, jobs[i].state);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, jobs[i].cmdline);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment"> * end job list helper routines</span></span><br><span class="line"><span class="comment"> ******************************/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************</span></span><br><span class="line"><span class="comment">  * Other helper routines</span></span><br><span class="line"><span class="comment">  ***********************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   * usage - print a help message</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">usage</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Usage: shell [-hvp]\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;   -h   print this message\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;   -v   print additional diagnostic information\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;   -p   do not emit a command prompt\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * unix_error - unix-style error routine</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">unix_error</span><span class="params">(<span class="type">char</span>* msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;%s: %s\n&quot;</span>, msg, strerror(errno));</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * app_error - application-style error routine</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">app_error</span><span class="params">(<span class="type">char</span>* msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;%s\n&quot;</span>, msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Signal - wrapper for the sigaction function</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">handler_t</span>* <span class="title function_">Signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">handler_t</span>* handler)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">action</span>, <span class="title">old_action</span>;</span></span><br><span class="line"></span><br><span class="line">    action.sa_handler = handler;</span><br><span class="line">    sigemptyset(&amp;action.sa_mask); <span class="comment">/* block sigs of type being handled */</span></span><br><span class="line">    action.sa_flags = SA_RESTART; <span class="comment">/* restart syscalls if possible */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sigaction(signum, &amp;action, &amp;old_action) &lt; <span class="number">0</span>)</span><br><span class="line">        unix_error(<span class="string">&quot;Signal error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> (old_action.sa_handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sigquit_handler - The driver program can gracefully terminate the</span></span><br><span class="line"><span class="comment"> *    child shell by sending it a SIGQUIT signal.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sigquit_handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Terminating after receipt of SIGQUIT signal\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// The following function are from csapp.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment"> * Wrappers for blocking signals</span></span><br><span class="line"><span class="comment"> *************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Sigemptyset</span><span class="params">(<span class="type">sigset_t</span>* <span class="built_in">set</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (sigemptyset(<span class="built_in">set</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        unix_error(<span class="string">&quot;Sigemptyset error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Sigprocmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span>* <span class="built_in">set</span>, <span class="type">sigset_t</span>* oldset)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (sigprocmask(how, <span class="built_in">set</span>, oldset) &lt; <span class="number">0</span>)</span><br><span class="line">        unix_error(<span class="string">&quot;Sigprocmask error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Sigaddset</span><span class="params">(<span class="type">sigset_t</span>* <span class="built_in">set</span>, <span class="type">int</span> signum)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (sigaddset(<span class="built_in">set</span>, signum) &lt; <span class="number">0</span>)</span><br><span class="line">        unix_error(<span class="string">&quot;Sigaddset error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment"> * The Sio (Signal-safe I/O) package - simple reentrant output</span></span><br><span class="line"><span class="comment"> * functions that are safe for signal handlers.</span></span><br><span class="line"><span class="comment"> *************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Private sio functions */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* $begin sioprivate */</span></span><br><span class="line"><span class="comment">/* sio_reverse - Reverse a string (from K&amp;R) */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sio_reverse</span><span class="params">(<span class="type">char</span> s[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> c, i, j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, j = <span class="built_in">strlen</span>(s) - <span class="number">1</span>; i &lt; j; i++, j--) &#123;</span><br><span class="line">        c = s[i];</span><br><span class="line">        s[i] = s[j];</span><br><span class="line">        s[j] = c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* sio_ltoa - Convert long to base b string (from K&amp;R) */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sio_ltoa</span><span class="params">(<span class="type">long</span> v, <span class="type">char</span> s[], <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> c, i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> neg = v &lt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (neg)</span><br><span class="line">        v = -v;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        s[i++] = ((c = (v % b)) &lt; <span class="number">10</span>) ? c + <span class="string">&#x27;0&#x27;</span> : c - <span class="number">10</span> + <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> ((v /= b) &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (neg)</span><br><span class="line">        s[i++] = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    s[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    sio_reverse(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* sio_strlen - Return length of string (from K&amp;R) */</span></span><br><span class="line"><span class="type">static</span> <span class="type">size_t</span> <span class="title function_">sio_strlen</span><span class="params">(<span class="type">char</span> s[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (s[i] != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">        ++i;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* $end sioprivate */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Public Sio functions */</span></span><br><span class="line"><span class="comment">/* $begin siopublic */</span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">sio_puts</span><span class="params">(<span class="type">char</span> s[])</span> <span class="comment">/* Put string */</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> write(STDOUT_FILENO, s, sio_strlen(s)); <span class="comment">//line:csapp:siostrlen</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">sio_putl</span><span class="params">(<span class="type">long</span> v)</span> <span class="comment">/* Put long */</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> s[<span class="number">128</span>];</span><br><span class="line"></span><br><span class="line">    sio_ltoa(v, s, <span class="number">10</span>); <span class="comment">/* Based on K&amp;R itoa() */</span>  <span class="comment">//line:csapp:sioltoa</span></span><br><span class="line">    <span class="keyword">return</span> sio_puts(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sio_error</span><span class="params">(<span class="type">char</span> s[])</span> <span class="comment">/* Put error message and exit */</span></span><br><span class="line">&#123;</span><br><span class="line">    sio_puts(s);</span><br><span class="line">    _exit(<span class="number">1</span>);                                      <span class="comment">//line:csapp:sioexit</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* $end siopublic */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************************</span></span><br><span class="line"><span class="comment"> * Wrappers for the SIO routines</span></span><br><span class="line"><span class="comment"> ******************************/</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">Sio_putl</span><span class="params">(<span class="type">long</span> v)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">ssize_t</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((n = sio_putl(v)) &lt; <span class="number">0</span>)</span><br><span class="line">        sio_error(<span class="string">&quot;Sio_putl error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">Sio_puts</span><span class="params">(<span class="type">char</span> s[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">ssize_t</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((n = sio_puts(s)) &lt; <span class="number">0</span>)</span><br><span class="line">        sio_error(<span class="string">&quot;Sio_puts error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Sio_error</span><span class="params">(<span class="type">char</span> s[])</span></span><br><span class="line">&#123;</span><br><span class="line">    sio_error(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h2><p>通过这次实验，才算是比较彻底理解了，信号的相关知识。</p>
<ul>
<li>包括信号的发送和捕捉</li>
<li>异步的思考方式</li>
<li>信号的阻塞</li>
<li>拓展：异步安全问题</li>
<li>信号处理程序的编写和使用</li>
<li><code>signal</code>函数和<code>kill</code>以及相关的函数的使用等</li>
</ul>
<p>这个是本课程最后一个实验的，综合难度并不是最大的。但是是知识体系最为复杂的。总的来说非常喜欢这门课的实验。做完之后能够感觉到和知识的紧密连接。感谢陪伴~</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://puitar.github.io/2022/05/19/OS-thread-homework/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Puitar">
      <meta itemprop="description" content="博客萌新时不时送来没什么软用的文章">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Puitar's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/19/OS-thread-homework/" class="post-title-link" itemprop="url">OS-thread-homework</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-05-19 22:26:30" itemprop="dateCreated datePublished" datetime="2022-05-19T22:26:30+08:00">2022-05-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-05-27 00:25:05" itemprop="dateModified" datetime="2022-05-27T00:25:05+08:00">2022-05-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/courses-learning/" itemprop="url" rel="index"><span itemprop="name">courses-learning</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="操作系统第三部分作业"><a href="#操作系统第三部分作业" class="headerlink" title="操作系统第三部分作业"></a>操作系统第三部分作业</h1><h2 id="作业范围"><a href="#作业范围" class="headerlink" title="作业范围"></a>作业范围</h2><ul>
<li>第26章1、2、3、4题</li>
<li>第28章1、2、3、4、5、6、7题</li>
<li>第30章1、2、4、8、9、10、11题</li>
<li>第31章1、2、4、5、6题</li>
</ul>
<h2 id="第26章"><a href="#第26章" class="headerlink" title="第26章"></a>第26章</h2><h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3><p>首先查看这个程序，得到结果如下</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sh&gt; <span class="built_in">cat</span> loop.s</span><br><span class="line"><span class="comment"># 段符号</span></span><br><span class="line">.main</span><br><span class="line">.top</span><br><span class="line"><span class="comment"># 重点看下面这4句</span></span><br><span class="line">sub  <span class="variable">$1</span>,%dx		<span class="comment"># %dx = %dx - 1</span></span><br><span class="line"><span class="built_in">test</span> <span class="variable">$0</span>,%dx		<span class="comment"># %dx &amp; $0 不改变%dx的值，仅仅改变标志位</span></span><br><span class="line">jgte .top		<span class="comment"># 表示如果大于等于就跳到.top</span></span><br><span class="line">halt			<span class="comment"># 停机</span></span><br></pre></td></tr></table></figure>

<p>现在我们理解了<code>loop.s</code>句子的含义。现在我们看看题目，假设dx的初始值是0，很快就可以计算出每个指令执行的时候dx的值。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ./x86.py -p loop.s -t 1 -i 100 -R dx</span><br><span class="line">...</span><br><span class="line">   dx          Thread 0</span><br><span class="line">    0</span><br><span class="line">   -1   1000 sub  <span class="variable">$1</span>,%dx</span><br><span class="line">   -1   1001 <span class="built_in">test</span> <span class="variable">$0</span>,%dx</span><br><span class="line">   -1   1002 jgte .top</span><br><span class="line">   -1   1003 halt</span><br></pre></td></tr></table></figure>

<p>dx作为循环变量判断是否跳出循环，上述语句可以写成c语言的语句如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = n;</span><br><span class="line"><span class="keyword">while</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">	i--;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以它的价值就在于循环递减变量以及循环变量判断是否跳出循环。</p>
<h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h3><p>现在运行相同的代码，但是使用如下标志，但是设定了寄存器的初始值如<code>-a</code>后面所赋值。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">$ ./x86.py -p loop.s -t 2 -i 100 -a dx=3,dx=3 -R dx</span><br><span class="line">...</span><br><span class="line">   dx          Thread 0                Thread 1</span><br><span class="line">    3</span><br><span class="line">    2   1000 sub  <span class="variable">$1</span>,%dx</span><br><span class="line">    2   1001 <span class="built_in">test</span> <span class="variable">$0</span>,%dx</span><br><span class="line">    2   1002 jgte .top</span><br><span class="line">    1   1000 sub  <span class="variable">$1</span>,%dx</span><br><span class="line">    1   1001 <span class="built_in">test</span> <span class="variable">$0</span>,%dx</span><br><span class="line">    1   1002 jgte .top</span><br><span class="line">    0   1000 sub  <span class="variable">$1</span>,%dx</span><br><span class="line">    0   1001 <span class="built_in">test</span> <span class="variable">$0</span>,%dx</span><br><span class="line">    0   1002 jgte .top</span><br><span class="line">   -1   1000 sub  <span class="variable">$1</span>,%dx</span><br><span class="line">   -1   1001 <span class="built_in">test</span> <span class="variable">$0</span>,%dx</span><br><span class="line">   -1   1002 jgte .top</span><br><span class="line">   -1   1003 halt</span><br><span class="line">    3   ----- Halt;Switch -----  ----- Halt;Switch -----</span><br><span class="line">    2                            1000 sub  <span class="variable">$1</span>,%dx</span><br><span class="line">    2                            1001 <span class="built_in">test</span> <span class="variable">$0</span>,%dx</span><br><span class="line">    2                            1002 jgte .top</span><br><span class="line">    1                            1000 sub  <span class="variable">$1</span>,%dx</span><br><span class="line">    1                            1001 <span class="built_in">test</span> <span class="variable">$0</span>,%dx</span><br><span class="line">    1                            1002 jgte .top</span><br><span class="line">    0                            1000 sub  <span class="variable">$1</span>,%dx</span><br><span class="line">    0                            1001 <span class="built_in">test</span> <span class="variable">$0</span>,%dx</span><br><span class="line">    0                            1002 jgte .top</span><br><span class="line">   -1                            1000 sub  <span class="variable">$1</span>,%dx</span><br><span class="line">   -1                            1001 <span class="built_in">test</span> <span class="variable">$0</span>,%dx</span><br><span class="line">   -1                            1002 jgte .top</span><br><span class="line">   -1                            1003 halt</span><br></pre></td></tr></table></figure>

<p>在这种情况下，多线程不会影响结果的运行，因为两个线程执行的时候不是共享同一个<code>edx</code>的。这种情况下，两个线程只使用自己的dx的值，dx在每个线程从3到-1。并且在中断前halt跳出循环。</p>
<p>至于这段代码是否有竞态条件？首先要弄清楚什么叫竞态条件等两个基本概念。</p>
<blockquote>
<ul>
<li>临界区：访问共享资源的一段代码，资源通常是一个变量或数据结构。</li>
<li>竞态条件：出现在多个执行线程同时进入临界区时，他们都试图更新共享的数据结构导致了不确定结果</li>
</ul>
</blockquote>
<p>这一段<code>loop.s</code>中对共享资源更新的部分的代码就是<code>sub</code>指令这一条。因此因此我们可以看临界区就是这一段<code>loop.s</code>或者就是<code>sub</code>这一句。很明显从在这种情况下，线程每100条指令中断1次，而还没到100条指令就已经跳出循环了。这种情况下可以看出来，两段代码是没有竞态条件的。</p>
<h3 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h3><p>这一组测试使得中断间隔非常小而且随机，使用不同的种子<code>-s</code>查看不同的交替。中断频率是否会改变这个程序的行为。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">$ ./x86.py -p loop.s -t 2 -i 3 -r -a dx=3,dx=3 -R dx</span><br><span class="line">...</span><br><span class="line">   dx          Thread 0                Thread 1</span><br><span class="line">    3</span><br><span class="line">    2   1000 sub  <span class="variable">$1</span>,%dx</span><br><span class="line">    2   1001 <span class="built_in">test</span> <span class="variable">$0</span>,%dx</span><br><span class="line">    2   1002 jgte .top</span><br><span class="line">    3   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    2                            1000 sub  <span class="variable">$1</span>,%dx</span><br><span class="line">    2                            1001 <span class="built_in">test</span> <span class="variable">$0</span>,%dx</span><br><span class="line">    2                            1002 jgte .top</span><br><span class="line">    2   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    1   1000 sub  <span class="variable">$1</span>,%dx</span><br><span class="line">    1   1001 <span class="built_in">test</span> <span class="variable">$0</span>,%dx</span><br><span class="line">    2   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    1                            1000 sub  <span class="variable">$1</span>,%dx</span><br><span class="line">    1   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    1   1002 jgte .top</span><br><span class="line">    0   1000 sub  <span class="variable">$1</span>,%dx</span><br><span class="line">    1   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    1                            1001 <span class="built_in">test</span> <span class="variable">$0</span>,%dx</span><br><span class="line">    1                            1002 jgte .top</span><br><span class="line">    0   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    0   1001 <span class="built_in">test</span> <span class="variable">$0</span>,%dx</span><br><span class="line">    0   1002 jgte .top</span><br><span class="line">   -1   1000 sub  <span class="variable">$1</span>,%dx</span><br><span class="line">    1   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    0                            1000 sub  <span class="variable">$1</span>,%dx</span><br><span class="line">   -1   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">   -1   1001 <span class="built_in">test</span> <span class="variable">$0</span>,%dx</span><br><span class="line">   -1   1002 jgte .top</span><br><span class="line">    0   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    0                            1001 <span class="built_in">test</span> <span class="variable">$0</span>,%dx</span><br><span class="line">    0                            1002 jgte .top</span><br><span class="line">   -1   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">   -1   1003 halt</span><br><span class="line">    0   ----- Halt;Switch -----  ----- Halt;Switch -----</span><br><span class="line">   -1                            1000 sub  <span class="variable">$1</span>,%dx</span><br><span class="line">   -1                            1001 <span class="built_in">test</span> <span class="variable">$0</span>,%dx</span><br><span class="line">   -1   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">   -1                            1002 jgte .top</span><br><span class="line">   -1                            1003 halt</span><br></pre></td></tr></table></figure>

<p>再看看不同的随机种子下是什么样的结果。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">$ ./x86.py -p loop.s -t 2 -i 3 -r -a dx=3,dx=3 -R dx -c -s 1</span><br><span class="line">...</span><br><span class="line">   dx          Thread 0                Thread 1</span><br><span class="line">    3</span><br><span class="line">    2   1000 sub  <span class="variable">$1</span>,%dx</span><br><span class="line">    3   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    2                            1000 sub  <span class="variable">$1</span>,%dx</span><br><span class="line">    2                            1001 <span class="built_in">test</span> <span class="variable">$0</span>,%dx</span><br><span class="line">    2                            1002 jgte .top</span><br><span class="line">    2   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    2   1001 <span class="built_in">test</span> <span class="variable">$0</span>,%dx</span><br><span class="line">    2   1002 jgte .top</span><br><span class="line">    1   1000 sub  <span class="variable">$1</span>,%dx</span><br><span class="line">    2   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    1                            1000 sub  <span class="variable">$1</span>,%dx</span><br><span class="line">    1   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    1   1001 <span class="built_in">test</span> <span class="variable">$0</span>,%dx</span><br><span class="line">    1   1002 jgte .top</span><br><span class="line">    1   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    1                            1001 <span class="built_in">test</span> <span class="variable">$0</span>,%dx</span><br><span class="line">    1                            1002 jgte .top</span><br><span class="line">    1   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    0   1000 sub  <span class="variable">$1</span>,%dx</span><br><span class="line">    0   1001 <span class="built_in">test</span> <span class="variable">$0</span>,%dx</span><br><span class="line">    1   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    0                            1000 sub  <span class="variable">$1</span>,%dx</span><br><span class="line">    0                            1001 <span class="built_in">test</span> <span class="variable">$0</span>,%dx</span><br><span class="line">    0                            1002 jgte .top</span><br><span class="line">    0   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    0   1002 jgte .top</span><br><span class="line">    0   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">   -1                            1000 sub  <span class="variable">$1</span>,%dx</span><br><span class="line">    0   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">   -1   1000 sub  <span class="variable">$1</span>,%dx</span><br><span class="line">   -1   1001 <span class="built_in">test</span> <span class="variable">$0</span>,%dx</span><br><span class="line">   -1   1002 jgte .top</span><br><span class="line">   -1   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">   -1                            1001 <span class="built_in">test</span> <span class="variable">$0</span>,%dx</span><br><span class="line">   -1                            1002 jgte .top</span><br><span class="line">   -1   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">   -1   1003 halt</span><br><span class="line">   -1   ----- Halt;Switch -----  ----- Halt;Switch -----</span><br><span class="line">   -1                            1003 halt</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">./x86.py -p loop.s -t 2 -i 3 -r -a dx=3,dx=3 -R dx -c -s 2</span><br><span class="line">...</span><br><span class="line">   dx          Thread 0                Thread 1</span><br><span class="line">    3</span><br><span class="line">    2   1000 sub  <span class="variable">$1</span>,%dx</span><br><span class="line">    2   1001 <span class="built_in">test</span> <span class="variable">$0</span>,%dx</span><br><span class="line">    2   1002 jgte .top</span><br><span class="line">    3   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    2                            1000 sub  <span class="variable">$1</span>,%dx</span><br><span class="line">    2                            1001 <span class="built_in">test</span> <span class="variable">$0</span>,%dx</span><br><span class="line">    2                            1002 jgte .top</span><br><span class="line">    2   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    1   1000 sub  <span class="variable">$1</span>,%dx</span><br><span class="line">    2   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    1                            1000 sub  <span class="variable">$1</span>,%dx</span><br><span class="line">    1   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    1   1001 <span class="built_in">test</span> <span class="variable">$0</span>,%dx</span><br><span class="line">    1   1002 jgte .top</span><br><span class="line">    0   1000 sub  <span class="variable">$1</span>,%dx</span><br><span class="line">    1   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    1                            1001 <span class="built_in">test</span> <span class="variable">$0</span>,%dx</span><br><span class="line">    1                            1002 jgte .top</span><br><span class="line">    0                            1000 sub  <span class="variable">$1</span>,%dx</span><br><span class="line">    0   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    0   1001 <span class="built_in">test</span> <span class="variable">$0</span>,%dx</span><br><span class="line">    0   1002 jgte .top</span><br><span class="line">   -1   1000 sub  <span class="variable">$1</span>,%dx</span><br><span class="line">    0   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    0                            1001 <span class="built_in">test</span> <span class="variable">$0</span>,%dx</span><br><span class="line">   -1   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">   -1   1001 <span class="built_in">test</span> <span class="variable">$0</span>,%dx</span><br><span class="line">   -1   1002 jgte .top</span><br><span class="line">    0   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    0                            1002 jgte .top</span><br><span class="line">   -1                            1000 sub  <span class="variable">$1</span>,%dx</span><br><span class="line">   -1   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">   -1   1003 halt</span><br><span class="line">   -1   ----- Halt;Switch -----  ----- Halt;Switch -----</span><br><span class="line">   -1                            1001 <span class="built_in">test</span> <span class="variable">$0</span>,%dx</span><br><span class="line">   -1   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">   -1                            1002 jgte .top</span><br><span class="line">   -1   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">   -1                            1003 halt</span><br></pre></td></tr></table></figure>

<p>总体看来，两个线程仍然是执行了从3到-1的循环操作，但是由于中断具有随机性，因此也就不能够确定什么时候执行完毕。从工作执行总量上看没有发生改变，但就工作执行的先后以及连续性上，改变了行为。</p>
<h3 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h3><p>第四题是访问一个公共变量而不是寄存器，在前面3题中，每个线程都有自己的专属寄存器。在中断的时候，线程的寄存器会保存，在恢复中断恢复的时候寄存器的值会被恢复。因此在循环上不会被破坏。但是现在的公共资源是一个变量，这可能引起某些变化。具体见下面。</p>
<p>首先看看这个程序<code>looping-race-nolock.s</code>是什么意思</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ cat looping-race-nolock.s</span><br><span class="line"># assumes %bx has loop count in it</span><br><span class="line"></span><br><span class="line">.main</span><br><span class="line">.top</span><br><span class="line"># critical section 临界区</span><br><span class="line">mov 2000, %ax  # get &#x27;value&#x27; at address 2000</span><br><span class="line">add $1, %ax    # increment it: ax += 1</span><br><span class="line">mov %ax, 2000  # store it back</span><br><span class="line"></span><br><span class="line"># see if we&#x27;re still looping</span><br><span class="line">sub  $1, %bx</span><br><span class="line">test $0, %bx</span><br><span class="line">jgt .top</span><br><span class="line"></span><br><span class="line">halt</span><br></pre></td></tr></table></figure>

<p>可以看出来bx是循环变量，要对ax进行加一操作，可以写出程序的c语言表达如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = n;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> *p;</span><br><span class="line"><span class="keyword">while</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    *p = x;</span><br><span class="line">    *p--;</span><br><span class="line">    i--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>然后我们再来看看下面这段执行情况。显然除了<code>mov %ax 2000</code>这个语句会更新2000地址的变量x的值，其余时刻都不会更新。因此结果如下。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ ./x86.py -p looping-race-nolock.s -t 1 -M 2000</span><br><span class="line">...</span><br><span class="line"> 2000          Thread 0</span><br><span class="line">    0</span><br><span class="line">    0   1000 mov 2000, %ax</span><br><span class="line">    0   1001 add <span class="variable">$1</span>, %ax</span><br><span class="line">    1   1002 mov %ax, 2000</span><br><span class="line">    1   1003 sub  <span class="variable">$1</span>, %bx</span><br><span class="line">    1   1004 <span class="built_in">test</span> <span class="variable">$0</span>, %bx</span><br><span class="line">    1   1005 jgt .top</span><br><span class="line">    1   1006 halt</span><br></pre></td></tr></table></figure>



<h2 id="第28章"><a href="#第28章" class="headerlink" title="第28章"></a>第28章</h2><p>这一章的习题同样是一个用python写的x86模拟器，它能够运行<code>.s</code>格式的文件。</p>
<p>在这里，我们有四个常用的寄存器ax、bx、cx、dx，还有一个程序计数器PC。还有足够小但是能够满足我们需求的汇编指令。我们也加了一些额外的寄存器，例如ex和fx，这不见得能够与x86是对应的。但是这并没有什么问题。</p>
<h3 id="1-1"><a href="#1-1" class="headerlink" title="1."></a>1.</h3><p>这题要我们用.&#x2F;x86运行<code>flag.s</code>文件。首先理解一下<code>flag.s</code>到底说了什么。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> flag.s</span><br><span class="line">.var flag</span><br><span class="line">.var count</span><br><span class="line"></span><br><span class="line">.main</span><br><span class="line">.top</span><br><span class="line"></span><br><span class="line">.acquire</span><br><span class="line">mov  flag, %ax      <span class="comment"># get flag</span></span><br><span class="line"><span class="built_in">test</span> <span class="variable">$0</span>, %ax        <span class="comment"># if we get 0 back: lock is free!</span></span><br><span class="line">jne  .acquire       <span class="comment"># if not, try again</span></span><br><span class="line">mov  <span class="variable">$1</span>, flag       <span class="comment"># store 1 into flag</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># critical section</span></span><br><span class="line">mov  count, %ax     <span class="comment"># get the value at the address</span></span><br><span class="line">add  <span class="variable">$1</span>, %ax        <span class="comment"># increment it</span></span><br><span class="line">mov  %ax, count     <span class="comment"># store it back</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># release lock</span></span><br><span class="line">mov  <span class="variable">$0</span>, flag       <span class="comment"># clear the flag now</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># see if we&#x27;re still looping</span></span><br><span class="line">sub  <span class="variable">$1</span>, %bx</span><br><span class="line"><span class="built_in">test</span> <span class="variable">$0</span>, %bx</span><br><span class="line">jgt .top</span><br><span class="line"></span><br><span class="line">halt</span><br></pre></td></tr></table></figure>

<p>上面这部分汇编代码其实很好理解，根据上面的注释，我们可以写出c语言版本</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> <span class="type">mutex_t</span>;</span><br><span class="line"><span class="type">mutex_t</span> flag = <span class="number">0x0</span>;</span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> i = n;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">mian</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">/* 上锁 */</span></span><br><span class="line">        <span class="keyword">while</span> (flag != <span class="number">0x0</span>)</span><br><span class="line">            ; <span class="comment">// 自选等待锁空闲</span></span><br><span class="line">        <span class="comment">/* lock */</span></span><br><span class="line">        flag = <span class="number">0x1</span>;</span><br><span class="line">        <span class="comment">/* 临界区代码 */</span></span><br><span class="line">        count++;</span><br><span class="line">        <span class="comment">/* unlock */</span></span><br><span class="line">        flag = <span class="number">0x0</span>;</span><br><span class="line">        <span class="comment">/* 判断是否继续循环 */</span></span><br><span class="line">        i--;	</span><br><span class="line">    &#125; <span class="keyword">while</span> (i &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="comment">/* halt */</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以<code>flag.s</code>的功能就是在循环变量被减到0之前不断申请上锁，然后对公共资源count++，然后释放锁的过程。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">$./x86.py -p flag.s</span><br><span class="line">...</span><br><span class="line">       Thread 0                Thread 1</span><br><span class="line"></span><br><span class="line">1000 mov  flag, %ax</span><br><span class="line">1001 <span class="built_in">test</span> <span class="variable">$0</span>, %ax</span><br><span class="line">1002 jne  .acquire</span><br><span class="line">1003 mov  <span class="variable">$1</span>, flag</span><br><span class="line">1004 mov  count, %ax</span><br><span class="line">1005 add  <span class="variable">$1</span>, %ax</span><br><span class="line">1006 mov  %ax, count</span><br><span class="line">1007 mov  <span class="variable">$0</span>, flag</span><br><span class="line">1008 sub  <span class="variable">$1</span>, %bx</span><br><span class="line">1009 <span class="built_in">test</span> <span class="variable">$0</span>, %bx</span><br><span class="line">1010 jgt .top</span><br><span class="line">1011 halt</span><br><span class="line">----- Halt;Switch -----  ----- Halt;Switch -----</span><br><span class="line">                         1000 mov  flag, %ax</span><br><span class="line">                         1001 <span class="built_in">test</span> <span class="variable">$0</span>, %ax</span><br><span class="line">                         1002 jne  .acquire</span><br><span class="line">                         1003 mov  <span class="variable">$1</span>, flag</span><br><span class="line">                         1004 mov  count, %ax</span><br><span class="line">                         1005 add  <span class="variable">$1</span>, %ax</span><br><span class="line">                         1006 mov  %ax, count</span><br><span class="line">                         1007 mov  <span class="variable">$0</span>, flag</span><br><span class="line">                         1008 sub  <span class="variable">$1</span>, %bx</span><br><span class="line">                         1009 <span class="built_in">test</span> <span class="variable">$0</span>, %bx</span><br><span class="line">                         1010 jgt .top</span><br><span class="line">                         1011 halt</span><br></pre></td></tr></table></figure>

<p>和上面的26的作业类似，在中断时间片较短的时候，两个线程都能够完成各自的工作。这个时候，count能够获得两个线程的累加工作，并获得确定的答案。既能够获得某个线程两倍的累加量。</p>
<h3 id="2-1"><a href="#2-1" class="headerlink" title="2."></a>2.</h3><p>上面其实已经解释了。答案是会的，能够按照预期工作。我们可以详细跟踪各个变量和寄存器的值看看</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">$./x86.py -p flag.s -R ax,bx -M flag,count -c</span><br><span class="line">...</span><br><span class="line"> flag count      ax    bx          Thread 0                Thread 1</span><br><span class="line"></span><br><span class="line">    0     0       0     0</span><br><span class="line">    0     0       0     0   1000 mov  flag, %ax</span><br><span class="line">    0     0       0     0   1001 <span class="built_in">test</span> <span class="variable">$0</span>, %ax</span><br><span class="line">    0     0       0     0   1002 jne  .acquire</span><br><span class="line">    1     0       0     0   1003 mov  <span class="variable">$1</span>, flag</span><br><span class="line">    1     0       0     0   1004 mov  count, %ax</span><br><span class="line">    1     0       1     0   1005 add  <span class="variable">$1</span>, %ax</span><br><span class="line">    1     1       1     0   1006 mov  %ax, count</span><br><span class="line">    0     1       1     0   1007 mov  <span class="variable">$0</span>, flag</span><br><span class="line">    0     1       1    -1   1008 sub  <span class="variable">$1</span>, %bx</span><br><span class="line">    0     1       1    -1   1009 <span class="built_in">test</span> <span class="variable">$0</span>, %bx</span><br><span class="line">    0     1       1    -1   1010 jgt .top</span><br><span class="line">    0     1       1    -1   1011 halt</span><br><span class="line">    0     1       0     0   ----- Halt;Switch -----  ----- Halt;Switch -----</span><br><span class="line">    0     1       0     0                            1000 mov  flag, %ax</span><br><span class="line">    0     1       0     0                            1001 <span class="built_in">test</span> <span class="variable">$0</span>, %ax</span><br><span class="line">    0     1       0     0                            1002 jne  .acquire</span><br><span class="line">    1     1       0     0                            1003 mov  <span class="variable">$1</span>, flag</span><br><span class="line">    1     1       1     0                            1004 mov  count, %ax</span><br><span class="line">    1     1       2     0                            1005 add  <span class="variable">$1</span>, %ax</span><br><span class="line">    1     2       2     0                            1006 mov  %ax, count</span><br><span class="line">    0     2       2     0                            1007 mov  <span class="variable">$0</span>, flag</span><br><span class="line">    0     2       2    -1                            1008 sub  <span class="variable">$1</span>, %bx</span><br><span class="line">    0     2       2    -1                            1009 <span class="built_in">test</span> <span class="variable">$0</span>, %bx</span><br><span class="line">    0     2       2    -1                            1010 jgt .top</span><br><span class="line">    0     2       2    -1                            1011 halt</span><br></pre></td></tr></table></figure>

<p>可以看到两个线程的循环变量寄存器都是bx，它们都是1，说明可以各自累加一次。count的初始值是0，所以最终各自累加一次，可以看到最后count的值恰好是2，证明了可以按照预期工作。</p>
<h3 id="3-1"><a href="#3-1" class="headerlink" title="3."></a>3.</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">$./x86.py -p flag.s -R ax,bx -M flag,count -c -a bx=2,bx=2</span><br><span class="line">...</span><br><span class="line"> flag count      ax    bx          Thread 0                Thread 1</span><br><span class="line"></span><br><span class="line">    0     0       0     2</span><br><span class="line">    0     0       0     2   1000 mov  flag, %ax</span><br><span class="line">    0     0       0     2   1001 <span class="built_in">test</span> <span class="variable">$0</span>, %ax</span><br><span class="line">    0     0       0     2   1002 jne  .acquire</span><br><span class="line">    1     0       0     2   1003 mov  <span class="variable">$1</span>, flag</span><br><span class="line">    1     0       0     2   1004 mov  count, %ax</span><br><span class="line">    1     0       1     2   1005 add  <span class="variable">$1</span>, %ax</span><br><span class="line">    1     1       1     2   1006 mov  %ax, count</span><br><span class="line">    0     1       1     2   1007 mov  <span class="variable">$0</span>, flag</span><br><span class="line">    0     1       1     1   1008 sub  <span class="variable">$1</span>, %bx</span><br><span class="line">    0     1       1     1   1009 <span class="built_in">test</span> <span class="variable">$0</span>, %bx</span><br><span class="line">    0     1       1     1   1010 jgt .top</span><br><span class="line">    0     1       0     1   1000 mov  flag, %ax</span><br><span class="line">    0     1       0     1   1001 <span class="built_in">test</span> <span class="variable">$0</span>, %ax</span><br><span class="line">    0     1       0     1   1002 jne  .acquire</span><br><span class="line">    1     1       0     1   1003 mov  <span class="variable">$1</span>, flag</span><br><span class="line">    1     1       1     1   1004 mov  count, %ax</span><br><span class="line">    1     1       2     1   1005 add  <span class="variable">$1</span>, %ax</span><br><span class="line">    1     2       2     1   1006 mov  %ax, count</span><br><span class="line">    0     2       2     1   1007 mov  <span class="variable">$0</span>, flag</span><br><span class="line">    0     2       2     0   1008 sub  <span class="variable">$1</span>, %bx</span><br><span class="line">    0     2       2     0   1009 <span class="built_in">test</span> <span class="variable">$0</span>, %bx</span><br><span class="line">    0     2       2     0   1010 jgt .top</span><br><span class="line">    0     2       2     0   1011 halt</span><br><span class="line">    0     2       0     2   ----- Halt;Switch -----  ----- Halt;Switch -----</span><br><span class="line">    0     2       0     2                            1000 mov  flag, %ax</span><br><span class="line">    0     2       0     2                            1001 <span class="built_in">test</span> <span class="variable">$0</span>, %ax</span><br><span class="line">    0     2       0     2                            1002 jne  .acquire</span><br><span class="line">    1     2       0     2                            1003 mov  <span class="variable">$1</span>, flag</span><br><span class="line">    1     2       2     2                            1004 mov  count, %ax</span><br><span class="line">    1     2       3     2                            1005 add  <span class="variable">$1</span>, %ax</span><br><span class="line">    1     3       3     2                            1006 mov  %ax, count</span><br><span class="line">    0     3       3     2                            1007 mov  <span class="variable">$0</span>, flag</span><br><span class="line">    0     3       3     1                            1008 sub  <span class="variable">$1</span>, %bx</span><br><span class="line">    0     3       3     1                            1009 <span class="built_in">test</span> <span class="variable">$0</span>, %bx</span><br><span class="line">    0     3       3     1                            1010 jgt .top</span><br><span class="line">    0     3       0     1                            1000 mov  flag, %ax</span><br><span class="line">    0     3       0     1                            1001 <span class="built_in">test</span> <span class="variable">$0</span>, %ax</span><br><span class="line">    0     3       0     1                            1002 jne  .acquire</span><br><span class="line">    1     3       0     1                            1003 mov  <span class="variable">$1</span>, flag</span><br><span class="line">    1     3       3     1                            1004 mov  count, %ax</span><br><span class="line">    1     3       4     1                            1005 add  <span class="variable">$1</span>, %ax</span><br><span class="line">    1     4       4     1                            1006 mov  %ax, count</span><br><span class="line">    0     4       4     1                            1007 mov  <span class="variable">$0</span>, flag</span><br><span class="line">    0     4       4     0                            1008 sub  <span class="variable">$1</span>, %bx</span><br><span class="line">    0     4       4     0                            1009 <span class="built_in">test</span> <span class="variable">$0</span>, %bx</span><br><span class="line">    0     4       4     0                            1010 jgt .top</span><br><span class="line">    0     4       4     0                            1011 halt</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>和前面的题目一样，实际就是两个线程分别进行两次累加，可以看到到目前为止，都能够正确完成累加。原因是中断切换线程执行的时候，两个线程都能够完成所有的累加，就不会出现存在竞态条件的情况。</p>
<h3 id="4-1"><a href="#4-1" class="headerlink" title="4."></a>4.</h3><p>这里我让循环为50次</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$./x86.py -p flag.s -R ax,bx -M flag,count -c -a bx=50,bx=50 -i 3</span><br><span class="line">...</span><br><span class="line"> flag count      ax    bx          Thread 0                Thread 1</span><br><span class="line"></span><br><span class="line">    0     0       0     2</span><br><span class="line">    0     0       0     2   1000 mov  flag, %ax</span><br><span class="line">    0     0       0     2   1001 <span class="built_in">test</span> <span class="variable">$0</span>, %ax</span><br><span class="line">    0     0       0     2   1002 jne  .acquire</span><br><span class="line">    1     0       0     2   1003 mov  <span class="variable">$1</span>, flag</span><br><span class="line">    1     0       0     2   1004 mov  count, %ax</span><br><span class="line">    1     0       1     2   1005 add  <span class="variable">$1</span>, %ax</span><br><span class="line">    1     1       1     2   1006 mov  %ax, count</span><br><span class="line">    0     1       1     2   1007 mov  <span class="variable">$0</span>, flag</span><br><span class="line">...</span><br><span class="line">  	1    57      57     1   1006 mov  %ax, count</span><br><span class="line">    0    57      57     1   1007 mov  <span class="variable">$0</span>, flag</span><br><span class="line">    0    57      57     1   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    0    57      57     0   1008 sub  <span class="variable">$1</span>, %bx</span><br><span class="line">    0    57      57     0   1009 <span class="built_in">test</span> <span class="variable">$0</span>, %bx</span><br><span class="line">    0    57      57     0   1010 jgt .top</span><br><span class="line">    0    57      57     0   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    0    57      57     0   1011 halt</span><br></pre></td></tr></table></figure>

<p>你能够看到两个线程循环50次，应该要能够累加100次，但是最后的结果是只累加了57次。此时我们说出现了不确定现象。</p>
<p>由于以flag作为锁，它的加锁和解锁本身没有原子性，所以并不能够起到保护共享资源的作用。所以随着<code>bx</code>增大，<code>i</code>减小，越容易产生不好的结果。反过来<code>bx</code>减小，<code>i</code>增大越趋向于产生确定的好的结果。</p>
<h3 id="5"><a href="#5" class="headerlink" title="5."></a>5.</h3><p>现在我们研究另外一个文件，它是个使用硬件原语<code>test-and-set</code>的指令，详细看看：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> test-and-set.s</span><br><span class="line">.var mutex</span><br><span class="line">.var count</span><br><span class="line"></span><br><span class="line">.main</span><br><span class="line">.top</span><br><span class="line"></span><br><span class="line">.acquire</span><br><span class="line">mov  <span class="variable">$1</span>, %ax</span><br><span class="line">xchg %ax, mutex     <span class="comment"># atomic swap of 1 and mutex</span></span><br><span class="line"><span class="built_in">test</span> <span class="variable">$0</span>, %ax        <span class="comment"># if we get 0 back: lock is free!</span></span><br><span class="line">jne  .acquire       <span class="comment"># if not, try again</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># critical section</span></span><br><span class="line">mov  count, %ax     <span class="comment"># get the value at the address</span></span><br><span class="line">add  <span class="variable">$1</span>, %ax        <span class="comment"># increment it</span></span><br><span class="line">mov  %ax, count     <span class="comment"># store it back</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># release lock</span></span><br><span class="line">mov  <span class="variable">$0</span>, mutex</span><br><span class="line"></span><br><span class="line"><span class="comment"># see if we&#x27;re still looping</span></span><br><span class="line">sub  <span class="variable">$1</span>, %bx</span><br><span class="line"><span class="built_in">test</span> <span class="variable">$0</span>, %bx</span><br><span class="line">jgt .top</span><br><span class="line"></span><br><span class="line">halt</span><br></pre></td></tr></table></figure>

<p>同样针对上面的汇编代码我们写出c语言版本</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> <span class="type">mutex_t</span>;</span><br><span class="line"><span class="type">mutex_t</span> mutex;</span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> i = n;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">/* 等待锁空闲，如果有空闲锁就上锁 */</span></span><br><span class="line">        <span class="keyword">while</span> (test_and_set(&amp;mutex, <span class="number">0x1</span>) != <span class="number">0x0</span>)</span><br><span class="line">            ; <span class="comment">// spin</span></span><br><span class="line">        <span class="comment">/* 临界区 */</span></span><br><span class="line">        count++;</span><br><span class="line">        <span class="comment">/* 解锁 */</span></span><br><span class="line">        mutex = <span class="number">0x0</span>;</span><br><span class="line">        i--;</span><br><span class="line">    &#125; <span class="keyword">while</span> (i &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="comment">/* halt */</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中获取锁部分：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 等待锁空闲，如果有空闲锁就上锁 */</span></span><br><span class="line"><span class="keyword">while</span> (test_and_set(&amp;mutex, <span class="number">0x1</span>) != <span class="number">0x0</span>)</span><br><span class="line">    ; <span class="comment">// spin</span></span><br><span class="line">=&gt;</span><br><span class="line">.acquire</span><br><span class="line">mov  $<span class="number">1</span>, %ax</span><br><span class="line">xchg %ax, mutex     <span class="meta"># atomic swap of 1 and mutex</span></span><br><span class="line">test $<span class="number">0</span>, %ax        <span class="meta"># <span class="keyword">if</span> we get 0 back: lock is free!</span></span><br><span class="line">jne  .acquire       <span class="meta"># <span class="keyword">if</span> not, try again</span></span><br></pre></td></tr></table></figure>

<p>释放锁部分：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 解锁 */</span></span><br><span class="line">mutex = <span class="number">0x0</span>;</span><br><span class="line">=&gt;</span><br><span class="line">mov  $<span class="number">0</span>, mutex</span><br></pre></td></tr></table></figure>



<h3 id="6"><a href="#6" class="headerlink" title="6."></a>6.</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ ./x86.py -p test-and-set.s -i 3 -a bx=50,bx=50 -M mutex,count -R ax,bx -c</span><br><span class="line">...</span><br><span class="line">mutex count      ax    bx          Thread 0                Thread 1</span><br><span class="line"></span><br><span class="line">    0     0       0    50</span><br><span class="line">    0     0       1    50   1000 mov  <span class="variable">$1</span>, %ax</span><br><span class="line">    1     0       0    50   1001 xchg %ax, mutex</span><br><span class="line">    1     0       0    50   1002 <span class="built_in">test</span> <span class="variable">$0</span>, %ax</span><br><span class="line">    1     0       0    50   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    1     0       1    50                            1000 mov  <span class="variable">$1</span>, %ax</span><br><span class="line">    1     0       1    50                            1001 xchg %ax, mutex</span><br><span class="line">    1     0       1    50                            1002 <span class="built_in">test</span> <span class="variable">$0</span>, %ax</span><br><span class="line">    1     0       0    50   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">... </span><br><span class="line">   	0   100     100     0                            1008 sub  <span class="variable">$1</span>, %bx</span><br><span class="line">    0   100     100     0   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    0   100     100     0                            1009 <span class="built_in">test</span> <span class="variable">$0</span>, %bx</span><br><span class="line">    0   100     100     0                            1010 jgt .top</span><br><span class="line">    0   100     100     0                            1011 halt</span><br></pre></td></tr></table></figure>

<p>可以看到在这种<code>test-and-set</code>的硬件原语支持下，能够保证原子性。所以最后计算的结果能够满足预期。但是可以从上面的代码中的看出，虽然保证了加锁的原子性，进而控制了了每次只能有一个线程在临界区。但是，由于当线程没有抢占到锁，就会在while中自旋等待，倘若拥有锁定的线程迟迟不释放锁，其他大量的线程就可能都处于自选等待的状态。而如果线程间调度采用的是类似轮转这样的算法，那么就会有大量的CPU资源用来自选。这种自选显然不是我们想要的，因此由于分时共享CPU的存在，CPU的使用率虽然比较高，但是做的有用功却不是很高，大部分时间在做自选等待。</p>
<p>现在考虑如何量化这样的CPU使用率的描述。就比如上面的示例代码两个线程一共做了100次累加，每次累加只有下面3条指令是经行累加的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># critical section</span><br><span class="line">mov  count, %ax     # get the value at the address</span><br><span class="line">add  $1, %ax        # increment it</span><br><span class="line">mov  %ax, count     # store it back</span><br></pre></td></tr></table></figure>

<p>因此也就只有3*100 &#x3D; 300条指令做有用功，剩下的通通是无用功。可以统计上面的计算共有2010行。由于整个计算过程CPU都处于工作状态。因此使用率100%。但是有效使用率仅有300&#x2F;2010 &#x3D; 14.93%</p>
<h3 id="7"><a href="#7" class="headerlink" title="7."></a>7.</h3><p>首先我们需要通过增加<code>-P</code>属性来规定执行的顺序。例如：<code>-P 1100111000111000111000</code>就会依次按照t1，t1，t0，t0，t1，…，t0，t0，t0的顺序执行线程</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ ./x86.py -p test-and-set.s -i 10 -R ax,bx -M mutex,count -a bx=5 -P 1100111000111000111000 -c</span><br><span class="line">...</span><br><span class="line">mutex count      ax    bx          Thread 0                Thread 1</span><br><span class="line"></span><br><span class="line">    0     0       0     5</span><br><span class="line">    0     0       1     5                            1000 mov  <span class="variable">$1</span>, %ax</span><br><span class="line">    1     0       0     5                            1001 xchg %ax, mutex</span><br><span class="line">    1     0       0     5   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    1     0       1     5   1000 mov  <span class="variable">$1</span>, %ax</span><br><span class="line">    1     0       1     5   1001 xchg %ax, mutex</span><br><span class="line">    1     0       0     5   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    1     0       0     5                            1002 <span class="built_in">test</span> <span class="variable">$0</span>, %ax</span><br><span class="line">    1     0       0     5                            1003 jne  .acquire</span><br><span class="line">...</span><br><span class="line">    1    10      10     1   1006 mov  %ax, count</span><br><span class="line">    0    10      10     1   1007 mov  <span class="variable">$0</span>, mutex</span><br><span class="line">    0    10      10     0   1008 sub  <span class="variable">$1</span>, %bx</span><br><span class="line">    0    10      10     0   1009 <span class="built_in">test</span> <span class="variable">$0</span>, %bx</span><br><span class="line">    0    10      10     0   1010 jgt .top</span><br><span class="line">    0    10      10     0   1011 halt</span><br></pre></td></tr></table></figure>

<p>可以看到最后结果是正确的，由于上面的获取锁过程是具有原子性的，也就是说每一次只能有一个线程执行成功(成功把flag从0变成1)获得锁。因此也就保证了正确性。</p>
<h2 id="第30章"><a href="#第30章" class="headerlink" title="第30章"></a>第30章</h2><p>由于第30章中文版课本上没有题目，因此在这里放出英文课本原题。</p>
<h3 id="1-2"><a href="#1-2" class="headerlink" title="1."></a>1.</h3><p><img src="/2022/05/19/OS-thread-homework/image-20220516082241930.png" alt="image-20220516082241930"></p>
<p>这个题目要我们专注于文件<code>main-two-cvs-while.c</code>。首先需要先了解代码的含义，理解代码运行会发生什么。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* src: main-two-cvs-while.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common_threads.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pc-header.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是用于生产者消费者的信号量</span></span><br><span class="line"><span class="comment">// empty 用于通知生产者复工</span></span><br><span class="line"><span class="comment">// fill  用于通知消费者消费</span></span><br><span class="line"><span class="comment">// m     锁</span></span><br><span class="line"><span class="type">pthread_cond_t</span> empty  = PTHREAD_COND_INITIALIZER;</span><br><span class="line"><span class="type">pthread_cond_t</span> fill   = PTHREAD_COND_INITIALIZER;</span><br><span class="line"><span class="type">pthread_mutex_t</span> m     = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main-header.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 填充函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_fill</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="comment">// 确保在这个函数使用前buffer[fill_ptr]是空的</span></span><br><span class="line">    <span class="comment">// 否则打印错误讯息</span></span><br><span class="line">    ensure(buffer[fill_ptr] == EMPTY, <span class="string">&quot;error: tried to fill a non-empty buffer&quot;</span>);</span><br><span class="line">    <span class="comment">// 填充缓冲区特定位置</span></span><br><span class="line">    buffer[fill_ptr] = value;</span><br><span class="line">    <span class="comment">// 填充指针指向下一位置</span></span><br><span class="line">    fill_ptr = (fill_ptr + <span class="number">1</span>) % max;</span><br><span class="line">    <span class="comment">// 已经填充数量加一</span></span><br><span class="line">    num_full++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">do_get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取特定位置的值</span></span><br><span class="line">    <span class="type">int</span> tmp = buffer[use_ptr];</span><br><span class="line">    <span class="comment">// 确保缓冲区有值</span></span><br><span class="line">    <span class="comment">// 否则打印错误讯息</span></span><br><span class="line">    ensure(tmp != EMPTY, <span class="string">&quot;error: tried to get an empty buffer&quot;</span>);</span><br><span class="line">    <span class="comment">// 取完商品把这个位置置空</span></span><br><span class="line">    buffer[use_ptr] = EMPTY;</span><br><span class="line">    <span class="comment">// 使用指针指向下一位置</span></span><br><span class="line">    use_ptr = (use_ptr + <span class="number">1</span>) % max;</span><br><span class="line">    <span class="comment">// 已经填充数量减一</span></span><br><span class="line">    num_full--;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者函数</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">producer</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="comment">// 根据arg所指的数值设置生产者的id</span></span><br><span class="line">    <span class="type">int</span> id = (<span class="type">int</span>) arg;</span><br><span class="line">    <span class="comment">// 确保每一个生产者能够生产自己专属的值(与id关联)</span></span><br><span class="line">    <span class="type">int</span> base = id * loops;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loops; i++) &#123;   p0;	<span class="comment">// 循环生产商品</span></span><br><span class="line">        Mutex_lock(&amp;m);             p1;	<span class="comment">// 获取锁</span></span><br><span class="line">        <span class="keyword">while</span> (num_full == max) &#123;   p2;	<span class="comment">// 如果货架满了</span></span><br><span class="line">            Cond_wait(&amp;empty, &amp;m);  p3;	<span class="comment">// 则睡眠等待货架再次为空时复工</span></span><br><span class="line">        &#125;</span><br><span class="line">        do_fill(base + i);          p4;	<span class="comment">// 进行一次货架填充</span></span><br><span class="line">        Cond_signal(&amp;fill);         p5;	<span class="comment">// 通知消费者可消费</span></span><br><span class="line">        Mutex_unlock(&amp;m);           p6;	<span class="comment">// 释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">consumer</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="comment">// 消费者根据arg产生唯一id</span></span><br><span class="line">    <span class="type">int</span> id = (<span class="type">int</span>) arg;					</span><br><span class="line">    <span class="type">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> consumed_count = <span class="number">0</span>;			   <span class="comment">// 消费数量</span></span><br><span class="line">    <span class="keyword">while</span> (tmp != END_OF_STREAM) &#123; c0; <span class="comment">// 循环直到生产商品流的最后元素</span></span><br><span class="line">        Mutex_lock(&amp;m);            c1; <span class="comment">// 获取锁</span></span><br><span class="line">        <span class="keyword">while</span> (num_full == <span class="number">0</span>) &#123;    c2; <span class="comment">// 如果货架空了</span></span><br><span class="line">            Cond_wait(&amp;fill, &amp;m);  c3; <span class="comment">// 等待生产者填充货架</span></span><br><span class="line">        &#125;</span><br><span class="line">        tmp = do_get();            c4; <span class="comment">// 获取货物</span></span><br><span class="line">        Cond_signal(&amp;empty);       c5; <span class="comment">// </span></span><br><span class="line">        Mutex_unlock(&amp;m);          c6; <span class="comment">// 释放锁</span></span><br><span class="line">        consumed_count++;			   <span class="comment">// 消费数量加一</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回consumer_count-1是因为END_OF_STREAM并不是有效商品</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span> *) (<span class="type">long</span> <span class="type">long</span>) (consumed_count - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置控制信号</span></span><br><span class="line"><span class="type">pthread_cond_t</span> *fill_cv = &amp;fill;</span><br><span class="line"><span class="type">pthread_cond_t</span> *empty_cv = &amp;empty;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有代码使用这个文件里的东西</span></span><br><span class="line"><span class="comment">// 包括主函数等启动问题程序</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main-common.c&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>对上面的代码我们做出了解析，如注释所示。我们的生产者会调用<code>do_fill</code>进行生产活动，一次只生产一个货物到空货架上。消费者会调用<code>do_get</code>获取货物，一次只获得一个商品。货架是一个数组，上面依次存取商品，由<code>fill_ptr</code>指明放入位置，由<code>use_ptr</code>知名从哪个位置取商品。</p>
<h3 id="2-2"><a href="#2-2" class="headerlink" title="2."></a>2.</h3><p><img src="/2022/05/19/OS-thread-homework/image-20220516085555854.png" alt="image-20220516085555854"></p>
<p>运行一个生产者一个消费者程序，然后让生产者生产一些特定的值。一开始我们只是使用一个长度大小只有1的buffer，然后慢慢增长它。当货架增大，程序代码会做和行为？你认为<code>num_full</code>会随着buffer的容量变大有什么不同（例如可以设成-<code>l 100</code>），当你改变消费者字符串，从默认的不睡眠到<code>-C 0,0,0,0,0,0,1</code>会发生什么？</p>
<p>这是一个项目程序，我们应该先编译他们：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh&gt; make</span><br></pre></td></tr></table></figure>

<p>编译完成生成了几个可执行的程序，现在我们让buffer长度为1，然后仅仅看看一个生产者和一个消费者的情况</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/ostep-homework/threads-cv</span><br><span class="line">$ ./main-two-cvs-while -p 1 -c1 -m 1 -v</span><br><span class="line"> NF         P0 C0 </span><br><span class="line">  0 [*--- ]    c0</span><br><span class="line">  0 [*--- ] p0</span><br><span class="line">  0 [*--- ]    c1</span><br><span class="line">  0 [*--- ]    c2</span><br><span class="line">  0 [*--- ] p1</span><br><span class="line">  1 [*  0 ] p4</span><br><span class="line">  1 [*  0 ] p5</span><br><span class="line">  1 [*  0 ] p6</span><br><span class="line">  1 [*  0 ]    c3</span><br><span class="line">  0 [*--- ]    c4</span><br><span class="line">  0 [*--- ]    c5</span><br><span class="line">  1 [*EOS ] [main: added end-of-stream marker]</span><br><span class="line">  1 [*EOS ]    c6</span><br><span class="line">  1 [*EOS ]    c0</span><br><span class="line">  1 [*EOS ]    c1</span><br><span class="line">  0 [*--- ]    c4</span><br><span class="line">  0 [*--- ]    c5</span><br><span class="line">  0 [*--- ]    c6</span><br><span class="line"></span><br><span class="line">Consumer consumption:</span><br><span class="line">  C0 -&gt; 1</span><br></pre></td></tr></table></figure>

<p>上面的数码做了一件事：[]中放的是buffer的内容，再往左是buffer的<code>full_num</code>。然后是对应的生产者消费者执行的步骤。（具体请见上面c代码）首先消费者执行c0，然后是消费者执行p0。然后消费者执行c1获取锁。然后while判断货架为空准备进入等待并释放锁。然后生产者获取锁，while判断货架为空跳过等待进行生产，然后唤醒消费者并释放锁。然后消费者苏醒获取锁，进行消费。此时以达到生产线最后元素（EOS）。然后消费者退出循环并返回。最后我们可以看到消费者C0消费了一个商品。上面过程没有出现什么问题。</p>
<p>接下来我们增大buffer尺寸。比如加到10</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/ostep-homework/threads-cv</span><br><span class="line">$ ./main-two-cvs-while -p 1 -c1 -m 10 -v</span><br><span class="line"> NF                                                      P0 C0 </span><br><span class="line">  0 [*---  ---  ---  ---  ---  ---  ---  ---  ---  --- ]    c0</span><br><span class="line">  0 [*---  ---  ---  ---  ---  ---  ---  ---  ---  --- ] p0</span><br><span class="line">  0 [*---  ---  ---  ---  ---  ---  ---  ---  ---  --- ] p1</span><br><span class="line">  1 [u  0 f---  ---  ---  ---  ---  ---  ---  ---  --- ] p4</span><br><span class="line">  1 [u  0 f---  ---  ---  ---  ---  ---  ---  ---  --- ] p5</span><br><span class="line">  1 [u  0 f---  ---  ---  ---  ---  ---  ---  ---  --- ] p6</span><br><span class="line">  1 [u  0 f---  ---  ---  ---  ---  ---  ---  ---  --- ]    c1</span><br><span class="line">  0 [ --- *---  ---  ---  ---  ---  ---  ---  ---  --- ]    c4</span><br><span class="line">  0 [ --- *---  ---  ---  ---  ---  ---  ---  ---  --- ]    c5</span><br><span class="line">  1 [ --- uEOS f---  ---  ---  ---  ---  ---  ---  --- ] [main: added end-of-stream marker]</span><br><span class="line">  1 [ --- uEOS f---  ---  ---  ---  ---  ---  ---  --- ]    c6</span><br><span class="line">  1 [ --- uEOS f---  ---  ---  ---  ---  ---  ---  --- ]    c0</span><br><span class="line">  1 [ --- uEOS f---  ---  ---  ---  ---  ---  ---  --- ]    c1</span><br><span class="line">  0 [ ---  --- *---  ---  ---  ---  ---  ---  ---  --- ]    c4</span><br><span class="line">  0 [ ---  --- *---  ---  ---  ---  ---  ---  ---  --- ]    c5</span><br><span class="line">  0 [ ---  --- *---  ---  ---  ---  ---  ---  ---  --- ]    c6</span><br><span class="line"></span><br><span class="line">Consumer consumption:</span><br><span class="line">  C0 -&gt; 1</span><br></pre></td></tr></table></figure>

<p>可以看到<code>-l</code>不发生变化，实际上和前面差不多，都没有什么问题。</p>
<p>然后我们现在增加生产次数</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/ostep-homework/threads-cv$ ./main-two-cvs-while -p 1 -c1 -m 10 -l 100  -v</span><br><span class="line"> NF                                                      P0 C0 </span><br><span class="line">  0 [*---  ---  ---  ---  ---  ---  ---  ---  ---  --- ] p0</span><br><span class="line">  0 [*---  ---  ---  ---  ---  ---  ---  ---  ---  --- ]    c0</span><br><span class="line">  0 [*---  ---  ---  ---  ---  ---  ---  ---  ---  --- ] p1</span><br><span class="line">  1 [u  0 f---  ---  ---  ---  ---  ---  ---  ---  --- ] p4</span><br><span class="line">  1 [u  0 f---  ---  ---  ---  ---  ---  ---  ---  --- ] p5</span><br><span class="line">  1 [u  0 f---  ---  ---  ---  ---  ---  ---  ---  --- ] p6</span><br><span class="line">...</span><br><span class="line">  1 [f---  ---  ---  ---  ---  ---  ---  ---  --- u 99 ] p5</span><br><span class="line">  1 [f---  ---  ---  ---  ---  ---  ---  ---  --- u 99 ] p6</span><br><span class="line">  1 [f---  ---  ---  ---  ---  ---  ---  ---  --- u 99 ]    c1</span><br><span class="line">  0 [*---  ---  ---  ---  ---  ---  ---  ---  ---  --- ]    c4</span><br><span class="line">  0 [*---  ---  ---  ---  ---  ---  ---  ---  ---  --- ]    c5</span><br><span class="line">  1 [uEOS f---  ---  ---  ---  ---  ---  ---  ---  --- ] [main: added end-of-stream marker]</span><br><span class="line">  1 [uEOS f---  ---  ---  ---  ---  ---  ---  ---  --- ]    c6</span><br><span class="line">  1 [uEOS f---  ---  ---  ---  ---  ---  ---  ---  --- ]    c0</span><br><span class="line">  1 [uEOS f---  ---  ---  ---  ---  ---  ---  ---  --- ]    c1</span><br><span class="line">  0 [ --- *---  ---  ---  ---  ---  ---  ---  ---  --- ]    c4</span><br><span class="line">  0 [ --- *---  ---  ---  ---  ---  ---  ---  ---  --- ]    c5</span><br><span class="line">  0 [ --- *---  ---  ---  ---  ---  ---  ---  ---  --- ]    c6</span><br><span class="line"></span><br><span class="line">Consumer consumption:</span><br><span class="line">  C0 -&gt; 100</span><br></pre></td></tr></table></figure>

<p>可以看到消费者都能够正常获得商品。</p>
<p>现在改变消费者睡眠字符串</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/ostep-homework/threads-cv$ ./main-two-cvs-while -p 1 -c1 -m 10 -l 100  -v</span><br><span class="line"> NF                                                      P0 C0 </span><br><span class="line">  0 [*---  ---  ---  ---  ---  ---  ---  ---  ---  --- ] p0</span><br><span class="line">  0 [*---  ---  ---  ---  ---  ---  ---  ---  ---  --- ]    c0</span><br><span class="line">  0 [*---  ---  ---  ---  ---  ---  ---  ---  ---  --- ] p1</span><br><span class="line">  1 [u  0 f---  ---  ---  ---  ---  ---  ---  ---  --- ] p4</span><br><span class="line">  1 [u  0 f---  ---  ---  ---  ---  ---  ---  ---  --- ] p5</span><br><span class="line">  1 [u  0 f---  ---  ---  ---  ---  ---  ---  ---  --- ] p6</span><br><span class="line">  1 [u  0 f---  ---  ---  ---  ---  ---  ---  ---  --- ]    c1</span><br><span class="line">  0 [ --- *---  ---  ---  ---  ---  ---  ---  ---  --- ]    c4</span><br><span class="line">  0 [ --- *---  ---  ---  ---  ---  ---  ---  ---  --- ] p0</span><br><span class="line">  0 [ --- *---  ---  ---  ---  ---  ---  ---  ---  --- ]    c5</span><br><span class="line">  0 [ --- *---  ---  ---  ---  ---  ---  ---  ---  --- ]    c6</span><br><span class="line">  0 [ --- *---  ---  ---  ---  ---  ---  ---  ---  --- ] p1</span><br><span class="line">  0 [ --- *---  ---  ---  ---  ---  ---  ---  ---  --- ]    c0</span><br><span class="line">  1 [ --- u  1 f---  ---  ---  ---  ---  ---  ---  --- ] p4</span><br><span class="line">  1 [ --- u  1 f---  ---  ---  ---  ---  ---  ---  --- ] p5</span><br><span class="line">...</span><br><span class="line"> 0 [ ---  ---  ---  ---  --- *---  ---  ---  ---  --- ] p1</span><br><span class="line">  1 [ ---  ---  ---  ---  --- u 25 f---  ---  ---  --- ] p4</span><br><span class="line">  1 [ ---  ---  ---  ---  --- u 25 f---  ---  ---  --- ]    c0</span><br><span class="line">  1 [ ---  ---  ---  ---  --- u 25 f---  ---  ---  --- ] p5</span><br><span class="line">  1 [ ---  ---  ---  ---  --- u 25 f---  ---  ---  --- ] p6</span><br><span class="line">  1 [ ---  ---  ---  ---  --- u 25 f---  ---  ---  --- ]    c1</span><br><span class="line">  1 [ ---  ---  ---  ---  --- u 25 f---  ---  ---  --- ] p0</span><br><span class="line">  0 [ ---  ---  ---  ---  ---  --- *---  ---  ---  --- ]    c4</span><br><span class="line">  0 [ ---  ---  ---  ---  ---  --- *---  ---  ---  --- ]    c5</span><br><span class="line">  0 [ ---  ---  ---  ---  ---  --- *---  ---  ---  --- ]    c6</span><br><span class="line">  0 [ ---  ---  ---  ---  ---  --- *---  ---  ---  --- ] p1</span><br><span class="line">  1 [ ---  ---  ---  ---  ---  --- u 26 f---  ---  --- ] p4</span><br><span class="line">  1 [ ---  ---  ---  ---  ---  --- u 26 f---  ---  --- ]    c0</span><br><span class="line">  1 [ ---  ---  ---  ---  ---  --- u 26 f---  ---  --- ] p5</span><br><span class="line">  1 [ ---  ---  ---  ---  ---  --- u 26 f---  ---  --- ] p6</span><br><span class="line">  1 [ ---  ---  ---  ---  ---  --- u 26 f---  ---  --- ] p0</span><br><span class="line">  1 [ ---  ---  ---  ---  ---  --- u 26 f---  ---  --- ]    c1</span><br><span class="line">  0 [ ---  ---  ---  ---  ---  ---  --- *---  ---  --- ]    c4</span><br><span class="line">  0 [ ---  ---  ---  ---  ---  ---  --- *---  ---  --- ]    c5</span><br><span class="line">  0 [ ---  ---  ---  ---  ---  ---  --- *---  ---  --- ]    c6</span><br><span class="line">  0 [ ---  ---  ---  ---  ---  ---  --- *---  ---  --- ] p1</span><br><span class="line">  0 [ ---  ---  ---  ---  ---  ---  --- *---  ---  --- ]    c0</span><br><span class="line">  1 [ ---  ---  ---  ---  ---  ---  --- u 27 f---  --- ] p4</span><br><span class="line">  1 [ ---  ---  ---  ---  ---  ---  --- u 27 f---  --- ] p5</span><br><span class="line">  1 [ ---  ---  ---  ---  ---  ---  --- u 27 f---  --- ] p6</span><br><span class="line">  1 [ ---  ---  ---  ---  ---  ---  --- u 27 f---  --- ]    c1</span><br><span class="line">  1 [ ---  ---  ---  ---  ---  ---  --- u 27 f---  --- ] p0</span><br><span class="line">  0 [ ---  ---  ---  ---  ---  ---  ---  --- *---  --- ]    c4</span><br><span class="line">...</span><br><span class="line">  9 [f--- u  1    2    3    4    5    6    7    8    9 ] p0</span><br><span class="line">  9 [f--- u  1    2    3    4    5    6    7    8    9 ] p1</span><br><span class="line"> 10 [  10 *  1    2    3    4    5    6    7    8    9 ] p4</span><br><span class="line"> 10 [  10 *  1    2    3    4    5    6    7    8    9 ] p5</span><br><span class="line"> 10 [  10 *  1    2    3    4    5    6    7    8    9 ] p6</span><br><span class="line"> 10 [  10 *  1    2    3    4    5    6    7    8    9 ] p0</span><br><span class="line"> 10 [  10 *  1    2    3    4    5    6    7    8    9 ] p1</span><br><span class="line"> 10 [  10 *  1    2    3    4    5    6    7    8    9 ] p2</span><br><span class="line"> 10 [  10 *  1    2    3    4    5    6    7    8    9 ]    c0</span><br><span class="line"> 10 [  10 *  1    2    3    4    5    6    7    8    9 ]    c1</span><br><span class="line">  9 [  10 f--- u  2    3    4    5    6    7    8    9 ]    c4</span><br><span class="line">  9 [  10 f--- u  2    3    4    5    6    7    8    9 ]    c5</span><br><span class="line">  9 [  10 f--- u  2    3    4    5    6    7    8    9 ]    c6</span><br><span class="line">  9 [  10 f--- u  2    3    4    5    6    7    8    9 ] p3</span><br><span class="line">...</span><br><span class="line">  1 [uEOS f---  ---  ---  ---  ---  ---  ---  ---  --- ]    c0</span><br><span class="line">  1 [uEOS f---  ---  ---  ---  ---  ---  ---  ---  --- ]    c1</span><br><span class="line">  0 [ --- *---  ---  ---  ---  ---  ---  ---  ---  --- ]    c4</span><br><span class="line">  0 [ --- *---  ---  ---  ---  ---  ---  ---  ---  --- ]    c5</span><br><span class="line">  0 [ --- *---  ---  ---  ---  ---  ---  ---  ---  --- ]    c6</span><br><span class="line"></span><br><span class="line">Consumer consumption:</span><br><span class="line">  C0 -&gt; 100</span><br></pre></td></tr></table></figure>

<p>看到上面的代码，生产f总是在使用u之前。</p>
<p>同时消费者总是等到缓冲区满了才开始消费。然后消费一个就通知生产者生产直到生产完毕。</p>
<p>此时一切生产消费活动都处于正常状态。</p>
<h3 id="4-2"><a href="#4-2" class="headerlink" title="4."></a>4.</h3><p><img src="/2022/05/19/OS-thread-homework/image-20220516100021157.png" alt="image-20220516100021157"></p>
<p>如果只有一个生产者，三个消费者，只有一个单一入口的buffer，每个消费者在c3指令执行的时候入睡要一秒钟（-C 0,0,0,1,0,0,0）</p>
<p>我们输入指令看看情况发生了什么？</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/ostep-homework/threads-cv</span><br><span class="line">$ ./main-two-cvs-while -p 1 -c 3 -m 1 -C 0,0,0,1,0,0,0:0,0,0,1,0,0,0:0,0,0,1,0,0,0 -l 10 -v -t</span><br><span class="line"> NF         P0 C0 C1 C2 </span><br><span class="line">  0 [*--- ]    c0</span><br><span class="line">  0 [*--- ] p0</span><br><span class="line">  0 [*--- ]       c0</span><br><span class="line">  0 [*--- ]          c0</span><br><span class="line">  0 [*--- ]    c1</span><br><span class="line">  0 [*--- ]    c2</span><br><span class="line">  0 [*--- ] p1</span><br><span class="line">  1 [*  0 ] p4</span><br><span class="line">  1 [*  0 ] p5</span><br><span class="line">  1 [*  0 ] p6</span><br><span class="line">  1 [*  0 ]       c1</span><br><span class="line">...</span><br><span class="line">Consumer consumption:</span><br><span class="line">  C0 -&gt; 0</span><br><span class="line">  C1 -&gt; 10</span><br><span class="line">  C2 -&gt; 0</span><br><span class="line"></span><br><span class="line">Total time: 13.07 seconds</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Consumer consumption:</span><br><span class="line">  C0 -&gt; 9</span><br><span class="line">  C1 -&gt; 0</span><br><span class="line">  C2 -&gt; 1</span><br><span class="line"></span><br><span class="line">Total time: 12.08 seconds</span><br></pre></td></tr></table></figure>

<p>不同次运行同样的命令，每次的运行时间不一致。但至少10s，因为消费者会取出10个数据。每取一个都会有1s的休眠。</p>
<p>可以看到上面的代码能够保证生产10个消费10个，但是存在消费者会被饿死的情况。</p>
<h3 id="8"><a href="#8" class="headerlink" title="8."></a>8.</h3><p><img src="/2022/05/19/OS-thread-homework/image-20220516101427280.png" alt="image-20220516101427280"></p>
<p>现在看看<code>main-one-cv-while.c</code>，现在我们要写一个睡眠字符串，在只有一个生产者和一个消费者和一个缓冲区只有1大小的情况下产生问题。</p>
<p>一个生产者一个消费者不会产生什么问题，因为通信的只有生产者和消费者。但是如果出现两个生产者或者两个消费者的时候，一个条件变量就会不清楚通知的是生产者还是消费者。</p>
<h3 id="9"><a href="#9" class="headerlink" title="9."></a>9.</h3><p><img src="/2022/05/19/OS-thread-homework/image-20220516103344533.png" alt="image-20220516103344533"></p>
<p>这个问题是课本257页表格表示的只有一个条件变量的问题。因为条件变量只有一个，所以所以可能存在一个消费者消费完试图唤醒生产者，但是不是唤醒生产者而是唤醒另外一个消费者，最终造成发出信号的消费者睡着，生产者没有醒过来，另外一个消费者醒过来发现没有东西消费，然后又睡着的情况。最终三个人都睡着了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生产者</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loops; i++) &#123;   p0;	<span class="comment">// 循环生产商品</span></span><br><span class="line">        Mutex_lock(&amp;m);             p1;	<span class="comment">// 获取锁</span></span><br><span class="line">        <span class="keyword">while</span> (num_full == max) &#123;   p2;	<span class="comment">// 如果货架满了</span></span><br><span class="line">            Cond_wait(&amp;empty, &amp;m);  p3;	<span class="comment">// 则睡眠等待货架再次为空时复工</span></span><br><span class="line">        &#125;</span><br><span class="line">        do_fill(base + i);          p4;	<span class="comment">// 进行一次货架填充</span></span><br><span class="line">        Cond_signal(&amp;fill);         p5;	<span class="comment">// 通知消费者可消费</span></span><br><span class="line">        Mutex_unlock(&amp;m);           p6;	<span class="comment">// 释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 消费者</span></span><br><span class="line"><span class="keyword">while</span> (tmp != END_OF_STREAM) &#123; c0; <span class="comment">// 循环直到生产商品流的最后元素</span></span><br><span class="line">        Mutex_lock(&amp;m);            c1; <span class="comment">// 获取锁</span></span><br><span class="line">        <span class="keyword">while</span> (num_full == <span class="number">0</span>) &#123;    c2; <span class="comment">// 如果货架空了</span></span><br><span class="line">            Cond_wait(&amp;fill, &amp;m);  c3; <span class="comment">// 等待生产者填充货架</span></span><br><span class="line">        &#125;</span><br><span class="line">        tmp = do_get();            c4; <span class="comment">// 获取货物</span></span><br><span class="line">        Cond_signal(&amp;empty);       c5; <span class="comment">// </span></span><br><span class="line">        Mutex_unlock(&amp;m);          c6; <span class="comment">// 释放锁</span></span><br></pre></td></tr></table></figure>

<p>我们可以看到p3是进行苏醒的，我们让它睡久一点，就能够触发问题了。比如这里我们让他睡五秒。</p>
<p>得到结果如下</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/ostep-homework/threads-cv</span><br><span class="line">$ ./main-one-cv-while -m 1 -l 5 -c 2 -p 1 -P 0,0,0,10,0,0,0 -v -t</span><br><span class="line"> NF         P0 C0 C1 </span><br><span class="line">  0 [*--- ]       c0</span><br><span class="line">  0 [*--- ] p0</span><br><span class="line">  0 [*--- ]    c0</span><br><span class="line">  0 [*--- ] p1</span><br><span class="line">  1 [*  0 ] p4</span><br><span class="line">...</span><br><span class="line">  0 [*--- ]       c5</span><br><span class="line">  0 [*--- ]       c6</span><br><span class="line"></span><br><span class="line">Consumer consumption:</span><br><span class="line">  C0 -&gt; 5</span><br><span class="line">  C1 -&gt; 0</span><br></pre></td></tr></table></figure>

<p><img src="/2022/05/19/OS-thread-homework/image-20220516105426143.png" alt="image-20220516105426143"></p>
<p>可以看到上面蓝色框框的部分C0消费完，不是唤醒P0，而是唤醒C1。</p>
<p>但是由于它编写的调度器总会在所有程序睡眠后调用生产者进行生产。所以可以看到蓝色框框下面又出现了生产者进行生产。但是实际上如果它的调度程序不这么智慧的话，三个线程都会进入睡眠状态。</p>
<h3 id="10"><a href="#10" class="headerlink" title="10."></a>10.</h3><p><img src="/2022/05/19/OS-thread-homework/image-20220516105828890.png" alt="image-20220516105828890"></p>
<p>这个题目要我们运行<code>main-two-cvs-if.c</code>文件。这个文件对等待函数是用<code>if</code>，也就是说仅仅进行一次判定。要我们考虑一个生产者一个消费者的情况，然后增加消费者的数量。试图产生问题。</p>
<p>我们说一个生产者一个消费者是不会有任何问题的。</p>
<p>但是如果有一个消费者或者以上，那么问题就出现了。这个问题其实就是书本255页介绍的问题。就是说只是进行一次等待判断，但是在两个消费者的时候，可能一个消费者判断有货物可取，然后再在它取之前发生中断，然后另外一个消费者也看到了这个货物，然后它一口气取完了。然后前面一个消费者还蒙在鼓里，以为自己还有货物，实际上已经没有货物了。</p>
<p>所以我们在其中一个消费者的去货物之前让它睡久一点就好，可以看到到c4是去货物所以试着构造这样的字符串</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-C 0,0,0,0,5,0,0:0,0,0,0,0,0,0</span><br></pre></td></tr></table></figure>

<p>执行结果如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/ostep-homework/threads-cv</span><br><span class="line">$ ./main-two-cvs-if -m 1 -l 5 -c 2 -p 1 -C 0,0,0,0,5,0,0:0,0,0,0,0,0,0 -v -t</span><br><span class="line"> NF        P0 C0 C1 </span><br><span class="line">  0 [*--- ]    c0</span><br><span class="line">  0 [*--- ] p0</span><br><span class="line">  0 [*--- ]    c1</span><br><span class="line">  0 [*--- ]       c0</span><br><span class="line">  0 [*--- ]    c2</span><br><span class="line">  0 [*--- ] p1</span><br><span class="line">  1 [*  0 ] p4</span><br><span class="line">  1 [*  0 ] p5</span><br><span class="line">  1 [*  0 ] p6</span><br><span class="line">  1 [*  0 ]       c1</span><br><span class="line">  1 [*  0 ] p0</span><br><span class="line">  0 [*--- ]       c4</span><br><span class="line">  0 [*--- ]       c5</span><br><span class="line">  0 [*--- ]       c6</span><br><span class="line">  0 [*--- ]    c3</span><br><span class="line">  0 [*--- ]       c0</span><br><span class="line">error: tried to get an empty buffer</span><br></pre></td></tr></table></figure>

<p>我们很容易就出发了这个错误。问题就是消费者2消费的速度明显更快，然后在15行的地方很快消费了货物，但是消费者1在c3的地方苏醒过来，没有再次判断是不是“假唤醒”（课本260页提示，所谓假唤醒就是唤醒你，但是你但是你没有货物），然后它认为它是有货物取得，所以在20行本来应该是消费者1进行取货c4操作，但是没有货物引起报错。</p>
<h3 id="11"><a href="#11" class="headerlink" title="11."></a>11.</h3><p><img src="/2022/05/19/OS-thread-homework/image-20220516112113947.png" alt="image-20220516112113947"></p>
<p>我们最后考察一个这样的程序<code>main-two-cvs-while-extra-unlock.c</code>。考察它会发生什么样的问题。如果你在放一个货物或者取一个货物之前就释放锁会发生什么。你可依托这一点给出一个睡眠字符串吗？分析发生了什么不好的事情。</p>
<p>和前面的代码不同的地方就在于它的生产者和消费者函数，是在释放锁之后才取资源。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">do_fill</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="comment">// ensure empty before usage</span></span><br><span class="line">    ensure(buffer[fill_ptr] == EMPTY, <span class="string">&quot;error: tried to fill a non-empty buffer&quot;</span>);</span><br><span class="line">    buffer[fill_ptr] = value;</span><br><span class="line">    fill_ptr = (fill_ptr + <span class="number">1</span>) % max;</span><br><span class="line">    num_full++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">do_get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> tmp = buffer[use_ptr];</span><br><span class="line">    ensure(tmp != EMPTY, <span class="string">&quot;error: tried to get an empty buffer&quot;</span>);</span><br><span class="line">    buffer[use_ptr] = EMPTY; </span><br><span class="line">    use_ptr = (use_ptr + <span class="number">1</span>) % max;</span><br><span class="line">    num_full--;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">producer</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="type">int</span> id = (<span class="type">int</span>) arg;</span><br><span class="line">    <span class="comment">// make sure each producer produces unique values</span></span><br><span class="line">    <span class="type">int</span> base = id * loops; </span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loops; i++) &#123;   p0;</span><br><span class="line">        Mutex_lock(&amp;m);             p1;</span><br><span class="line">        <span class="keyword">while</span> (num_full == max) &#123;   p2;</span><br><span class="line">            Cond_wait(&amp;empty, &amp;m);  p3;</span><br><span class="line">        &#125;</span><br><span class="line">        Mutex_unlock(&amp;m);</span><br><span class="line">        do_fill(base + i);          p4;</span><br><span class="line">        Mutex_lock(&amp;m);</span><br><span class="line">        Cond_signal(&amp;fill);         p5;</span><br><span class="line">        Mutex_unlock(&amp;m);           p6;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">                                                                               </span><br><span class="line"><span class="type">void</span> *<span class="title function_">consumer</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="type">int</span> id = (<span class="type">int</span>) arg;</span><br><span class="line">    <span class="type">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> consumed_count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (tmp != END_OF_STREAM) &#123; c0;</span><br><span class="line">        Mutex_lock(&amp;m);            c1;</span><br><span class="line">        <span class="keyword">while</span> (num_full == <span class="number">0</span>) &#123;    c2;</span><br><span class="line">            Cond_wait(&amp;fill, &amp;m);  c3;</span><br><span class="line">        &#125;</span><br><span class="line">        Mutex_unlock(&amp;m);</span><br><span class="line">        tmp = do_get();            c4;</span><br><span class="line">        Mutex_lock(&amp;m);</span><br><span class="line">        Cond_signal(&amp;empty);       c5;</span><br><span class="line">        Mutex_unlock(&amp;m);          c6;</span><br><span class="line">        consumed_count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// return consumer_count-1 because END_OF_STREAM does not count</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span> *) (<span class="type">long</span> <span class="type">long</span>) (consumed_count - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们的公共资源就是buffer，但是把<code>do_fill</code>和<code>do_get</code>放在锁的外面，这个锁就不起作用了。</p>
<p>如果只有一个消费者和生产者由于条件变量和full_num的共同作用，能够保证生产时消费者在睡，消费时生产者在睡。但是，如果有多个生产者和多个消费者的情况下，由于只能保证一个生产者和一个消费者互斥。所以其他的就可以对公共资源进行改写。比如在一个消费者取货物之前可能另外一个生产者覆盖了这个货物。</p>
<p><img src="/2022/05/19/OS-thread-homework/image-20220516114048979.png" alt="image-20220516114048979"></p>
<p>比如这里的2是被消费者0消费了，但是它很可能在c4消费之前，他消费的东西就被别的消费者覆盖了。</p>
<p>我们可以让c4执行慢一点，刚好让别的生产者抢占锁</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-C 0,0,0,0,5,0,0:0,0,0,0,5,0,0</span><br></pre></td></tr></table></figure>



<h2 id="第31章"><a href="#第31章" class="headerlink" title="第31章"></a>第31章</h2><h3 id="1-3"><a href="#1-3" class="headerlink" title="1."></a>1.</h3><p><img src="/2022/05/19/OS-thread-homework/image-20220517094824131.png" alt="image-20220517094824131"></p>
<p>第一题要我们实现fork&#x2F;join问题，要求自己写一个线程fork-join的程序，你要工作的是作业目录下的<code>fork-join.c</code>文件。同时在<code>child</code>添加<code>sleep(1)</code>试着确定他的正确性。</p>
<p>和课本266页一致，但是要注意几点：</p>
<ul>
<li><code>child</code>释放<code>post</code>信号量应该在孩子已经工作完的情况下</li>
<li>创建完子线程之后，主线程等待子线程完毕</li>
</ul>
<p>下面书写代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common_threads.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">sem_t</span> s; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">child</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child\n&quot;</span>);</span><br><span class="line">    sleep(<span class="number">1</span>); <span class="comment">// 验证父线程是否等待子线程完成</span></span><br><span class="line">    <span class="comment">// use semaphore here</span></span><br><span class="line">    Sem_post(&amp;s)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;parent: begin\n&quot;</span>);</span><br><span class="line">    <span class="comment">// init semaphore here</span></span><br><span class="line">    Sem_init(&amp;s, <span class="number">0</span>)</span><br><span class="line">    Pthread_create(&amp;p, <span class="literal">NULL</span>, child, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// use semaphore here</span></span><br><span class="line">    Sem_wait(&amp;s)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;parent: end\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于上述代码有几点说明：</p>
<ul>
<li>这里关于信号量的使用用的是宏定义函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> Sem_init(sem, value)                             assert(sem_init(sem, 0, value) == 0);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Sem_wait(sem)                                    assert(sem_wait(sem) == 0);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Sem_post(sem)                                    assert(sem_post(sem) == 0);</span></span><br></pre></td></tr></table></figure>

<ul>
<li>运行编译时，需要加上<code>-pthread</code>的<code>tag</code>运行结果如下</li>
</ul>
<p>​    <img src="/2022/05/19/OS-thread-homework/image-20220517114856648.png" alt="image-20220517114856648"></p>
<ul>
<li>当加入<code>sleep(1)</code>的时候同样运行正确，验证代码正确性。</li>
</ul>
<h3 id="2-3"><a href="#2-3" class="headerlink" title="2."></a>2.</h3><p><img src="/2022/05/19/OS-thread-homework/image-20220517115033332.png" alt="image-20220517115033332"></p>
<p>现在看看<code>rendezvous</code>问题。这个问题表述如下：你有两个线程，每一个线程都将要进入到<code>rendezvous</code>点执行代码。每一部分都不会在其他线程进入这个代码的时候退出，而是等待。思考使用两个信号量实现这个过程。详见<code>rendezvous.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common_threads.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果编写的代码正确，每一个子线程会打印各自的before信息，然后再打印各自的after信息</span></span><br><span class="line"><span class="comment">// 加入sleep(1)测试程序正确性</span></span><br><span class="line"></span><br><span class="line"><span class="type">sem_t</span> s1, s2;</span><br><span class="line"><span class="comment">// 两个信号量用于分别管理child1和child2的等待和继续</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">child_1</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child 1: before\n&quot;</span>);</span><br><span class="line">    <span class="comment">// what goes here?</span></span><br><span class="line">    Sem_wait(&amp;s1)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child 1: after\n&quot;</span>);</span><br><span class="line">    Sem_post(&amp;s2)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">child_2</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">	sleep(<span class="number">1</span>);	<span class="comment">// 先睡一会在工作</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child 2: before\n&quot;</span>);</span><br><span class="line">    <span class="comment">// what goes here?</span></span><br><span class="line">    Sem_post(&amp;s1)</span><br><span class="line">    Sem_wait(&amp;s2)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child 2: after\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> p1, p2;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;parent: begin\n&quot;</span>);</span><br><span class="line">    <span class="comment">// init semaphores here</span></span><br><span class="line">    Sem_init(&amp;s1, <span class="number">0</span>)</span><br><span class="line">    Sem_init(&amp;s2, <span class="number">0</span>)</span><br><span class="line">    Pthread_create(&amp;p1, <span class="literal">NULL</span>, child_1, <span class="literal">NULL</span>);</span><br><span class="line">    Pthread_create(&amp;p2, <span class="literal">NULL</span>, child_2, <span class="literal">NULL</span>);</span><br><span class="line">    Pthread_join(p1, <span class="literal">NULL</span>);</span><br><span class="line">    Pthread_join(p2, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;parent: end\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一点说明：这里把信号量作为条件变量使用，当条件变量发生变化，可以继续执行。可以看到如果<code>child1</code>先工作，它打印完它的before信息之后，会等待s1的讯息。然后<code>child2</code>输出它的before信息，然后它唤醒<code>child1</code>，然后自己进入睡眠等待<code>child1</code>打印它的after信息，然后<code>child1</code>打印完会唤醒<code>child2</code>，<code>child2</code>打印after讯息。最终实现次序打印。</p>
<p>结果如下：</p>
<p><img src="/2022/05/19/OS-thread-homework/image-20220517121316512.png" alt="image-20220517121316512"></p>
<h3 id="4-3"><a href="#4-3" class="headerlink" title="4."></a>4.</h3><p><img src="/2022/05/19/OS-thread-homework/image-20220517123707241.png" alt="image-20220517123707241"></p>
<p>这道题要求我们自己编写读写锁的详细代码。在这里我们不需要考虑饿死的问题。</p>
<p>代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common_threads.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Your code goes in the structure and functions below</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">rwlock_t</span> &#123;</span></span><br><span class="line">    <span class="type">sem_t</span> lock;						<span class="comment">// 二值信号量，用作基础锁，保证对readers操作的原子性</span></span><br><span class="line">    <span class="type">sem_t</span> writelock;				<span class="comment">// 写锁</span></span><br><span class="line">    <span class="type">int</span> readers;					<span class="comment">// 读者的数量</span></span><br><span class="line">&#125; <span class="type">rwlock_t</span>;</span><br><span class="line"></span><br><span class="line">			</span><br><span class="line"><span class="type">void</span> <span class="title function_">rwlock_init</span><span class="params">(<span class="type">rwlock_t</span> *rw)</span> &#123;</span><br><span class="line">    rw-&gt;readers = <span class="number">0</span>;				<span class="comment">// 读者的数量</span></span><br><span class="line">    Sem_init(&amp;rw-&gt;lock, <span class="number">1</span>)			<span class="comment">// 基础锁初始化</span></span><br><span class="line">    Sem_init(&amp;rw-&gt;writelock, <span class="number">1</span>)		<span class="comment">// 写锁初始化</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rwlock_acquire_readlock</span><span class="params">(<span class="type">rwlock_t</span> *rw)</span> &#123;</span><br><span class="line">    Sem_wait(&amp;rw-&gt;lock)</span><br><span class="line">    rw-&gt;readers++;</span><br><span class="line">    <span class="keyword">if</span> (rw-&gt;readers == <span class="number">1</span>)</span><br><span class="line">        Sem_wait(&amp;rw-&gt;writelock)</span><br><span class="line">    Sem_post(&amp;rw-&gt;lock)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rwlock_release_readlock</span><span class="params">(<span class="type">rwlock_t</span> *rw)</span> &#123;</span><br><span class="line">    Sem_wait(&amp;rw-&gt;lock)</span><br><span class="line">    rw-&gt;readers--;</span><br><span class="line">    <span class="keyword">if</span> (rw-&gt;readers == <span class="number">0</span>)</span><br><span class="line">        Sem_post(&amp;rw-&gt;writelock)</span><br><span class="line">    Sem_post(&amp;rw-&gt;lock)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rwlock_acquire_writelock</span><span class="params">(<span class="type">rwlock_t</span> *rw)</span> &#123;</span><br><span class="line">    Sem_wait(&amp;rw-&gt;writelock)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rwlock_release_writelock</span><span class="params">(<span class="type">rwlock_t</span> *rw)</span> &#123;</span><br><span class="line">    Sem_post(&amp;rw-&gt;writelock)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Don&#x27;t change the code below (just use it!)</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> loops;</span><br><span class="line"><span class="type">int</span> value = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">rwlock_t</span> lock;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">reader</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loops; i++) &#123;</span><br><span class="line">        rwlock_acquire_readlock(&amp;lock);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;read %d\n&quot;</span>, value);</span><br><span class="line">        rwlock_release_readlock(&amp;lock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">writer</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loops; i++) &#123;</span><br><span class="line">        rwlock_acquire_writelock(&amp;lock);</span><br><span class="line">        value++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;write %d\n&quot;</span>, value);</span><br><span class="line">        rwlock_release_writelock(&amp;lock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="comment">// 获取参数</span></span><br><span class="line">    assert(argc == <span class="number">4</span>);</span><br><span class="line">    <span class="type">int</span> num_readers = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="type">int</span> num_writers = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">    loops = atoi(argv[<span class="number">3</span>]);</span><br><span class="line">    <span class="comment">// 创建进程池</span></span><br><span class="line">    <span class="type">pthread_t</span> pr[num_readers], pw[num_writers];</span><br><span class="line">    <span class="comment">// 读写锁初始化</span></span><br><span class="line">    rwlock_init(&amp;lock);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;begin\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 创建所有读者和写着</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_readers; i++)</span><br><span class="line">        Pthread_create(&amp;pr[i], <span class="literal">NULL</span>, reader, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_writers; i++)</span><br><span class="line">        Pthread_create(&amp;pw[i], <span class="literal">NULL</span>, writer, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 主线程等待所有读者写者完成任务</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_readers; i++)</span><br><span class="line">        Pthread_join(pr[i], <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_writers; i++)</span><br><span class="line">        Pthread_join(pw[i], <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;end: value %d\n&quot;</span>, value);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下</p>
<p><img src="/2022/05/19/OS-thread-homework/image-20220517131624836.png" alt="image-20220517131624836"></p>
<p>存在读者饿死写着的问题。看到上面的实验结果显示只有读者全部读完了才开始写。根据代码我们也可以看出来。第一个读者获取写锁，所以任何写者都不可以写，而在第一个读者获得写锁后，其他的读者是可以获得读锁的。一旦某一个读者抢到了写锁，其他的读者都会蜂拥而入（它们不受任何阻碍）然后执行读操作。而写者呢？它们很不幸，如果它们没有任何一个读者快抢到<code>writelock</code>，则它们不能够执行写，因为<code>writelock</code>还在第一个读者手上(<code>writelock</code>移交到最后一个读者手上了才释放)，所以这些读者只能够等待几乎所有读者读完才能够进行写操作。同时还要保证在它们被最后一个读者唤醒之后没有其他读者和他们竞争，才能够安稳进行写操作。</p>
<h3 id="5-1"><a href="#5-1" class="headerlink" title="5."></a>5.</h3><p><img src="/2022/05/19/OS-thread-homework/image-20220517133750012.png" alt="image-20220517133750012"></p>
<p>现在我们要写一个没有上面描述到的饥饿问题的程序。实际上我们需要做到的是：如何能够在有写者等待的时候，避免有更多的读者进入并持有锁。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common_threads.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Your code goes in the structure and functions below</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">rwlock_t</span> &#123;</span></span><br><span class="line">    <span class="type">sem_t</span> lock;						<span class="comment">// 二值信号量，用作基础锁</span></span><br><span class="line">    								<span class="comment">// 保证对writers和readers操作的原子性</span></span><br><span class="line">    <span class="type">sem_t</span> writelock;				<span class="comment">// 写锁</span></span><br><span class="line">    <span class="type">int</span> readers;					<span class="comment">// 读者的数量</span></span><br><span class="line">    <span class="type">int</span> writers;</span><br><span class="line">&#125; <span class="type">rwlock_t</span>;</span><br><span class="line"></span><br><span class="line">			</span><br><span class="line"><span class="type">void</span> <span class="title function_">rwlock_init</span><span class="params">(<span class="type">rwlock_t</span> *rw)</span> &#123;</span><br><span class="line">    rw-&gt;readers = <span class="number">0</span>;				<span class="comment">// 读者的数量</span></span><br><span class="line">    rw-&gt;writers = <span class="number">0</span>;				<span class="comment">// 等待写的写者数量</span></span><br><span class="line">    Sem_init(&amp;rw-&gt;lock, <span class="number">1</span>)			<span class="comment">// 基础锁初始化</span></span><br><span class="line">    Sem_init(&amp;rw-&gt;writelock, <span class="number">1</span>)		<span class="comment">// 写锁初始化</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rwlock_acquire_readlock</span><span class="params">(<span class="type">rwlock_t</span> *rw)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    Sem_wait(&amp;rw-&gt;lock)</span><br><span class="line">    <span class="keyword">while</span> (rw-&gt;writers &gt; <span class="number">0</span>)			<span class="comment">// 判断是否有写者进行等待</span></span><br><span class="line">        ; <span class="comment">// spin					// 自旋等待</span></span><br><span class="line">    rw-&gt;readers++;</span><br><span class="line">    <span class="keyword">if</span> (rw-&gt;readers == <span class="number">1</span>)</span><br><span class="line">        Sem_wait(&amp;rw-&gt;writelock)</span><br><span class="line">    Sem_post(&amp;rw-&gt;lock)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rwlock_release_readlock</span><span class="params">(<span class="type">rwlock_t</span> *rw)</span> &#123;</span><br><span class="line">    Sem_wait(&amp;rw-&gt;lock)</span><br><span class="line">    rw-&gt;readers--;</span><br><span class="line">    <span class="keyword">if</span> (rw-&gt;readers == <span class="number">0</span>)</span><br><span class="line">        Sem_post(&amp;rw-&gt;writelock)</span><br><span class="line">    Sem_post(&amp;rw-&gt;lock)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rwlock_acquire_writelock</span><span class="params">(<span class="type">rwlock_t</span> *rw)</span> &#123;</span><br><span class="line">    <span class="comment">// 写者申请写锁前先将等待数目加一</span></span><br><span class="line">    Sem_wait(&amp;rw-&gt;lock)</span><br><span class="line">    rw-&gt;writers++;</span><br><span class="line">    Sem_post(&amp;rw-&gt;lock)</span><br><span class="line">    <span class="comment">// 申请写锁</span></span><br><span class="line">    Sem_wait(&amp;rw-&gt;writelock)</span><br><span class="line">    <span class="comment">// 写者获得写锁把等待数目减一</span></span><br><span class="line">    Sem_wait(&amp;rw-&gt;lock)</span><br><span class="line">    rw-&gt;writers--;</span><br><span class="line">    Sem_post(&amp;rw-&gt;lock)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rwlock_release_writelock</span><span class="params">(<span class="type">rwlock_t</span> *rw)</span> &#123;</span><br><span class="line">    Sem_post(&amp;rw-&gt;writelock)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面的代码和上面的文件没有什么区别</span></span><br></pre></td></tr></table></figure>

<p>这种策略实际上是一种写者优先的策略。由于读写锁的策略是针对多数读者少数写者的情况。这里我采用简单的自旋技术，让读者在申请锁之前总需要先判断一下是否有写者等待，如果有读者自选等待。然后在<code>rwlock_acquire_writelock</code>的代码中对<code>writers</code>的改写需要保证原子性，所以需要上锁。但是我们需要把锁的范围缩小到上面的仅对加减<code>writers</code>的操作上锁解锁。从第51行到第53行可能发生中断，使得尽管写者已经释放了锁，但是等待数目没有来得及减。但是此时所有读者仍然在等待减完才能抢占CPU。这一点在这里不用担心。</p>
<p>最后我们看一种夸张的情况，每一个读者在抢占锁之前都睡眠一秒钟。结果显示能够让写者先进行写操作。说明我们解决了饥饿的问题。</p>
<p><img src="/2022/05/19/OS-thread-homework/image-20220517145756037.png" alt="image-20220517145756037"></p>
<h3 id="6-1"><a href="#6-1" class="headerlink" title="6."></a>6.</h3><p><img src="/2022/05/19/OS-thread-homework/image-20220517145842415.png" alt="image-20220517145842415"></p>
<p>现在要用信号量实现没有饥饿问题的互斥量也就是锁。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common_threads.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Here, you have to write (almost) ALL the code. Oh no!</span></span><br><span class="line"><span class="comment">// How can you show that a thread does not starve</span></span><br><span class="line"><span class="comment">// when attempting to acquire this mutex you build?</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">ns_mutex_t</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> ticket;</span><br><span class="line">	<span class="type">int</span> turn;</span><br><span class="line">	<span class="type">sem_t</span> stic;</span><br><span class="line">	<span class="type">sem_t</span> stur;</span><br><span class="line">&#125; <span class="type">ns_mutex_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ns_mutex_init</span><span class="params">(<span class="type">ns_mutex_t</span> *m)</span> &#123;</span><br><span class="line">	Sem_init(&amp;m-&gt;stic, <span class="number">1</span>)</span><br><span class="line">	Sem_init(&amp;m-&gt;stur, <span class="number">1</span>)</span><br><span class="line">	m-&gt;ticket = <span class="number">0</span>;</span><br><span class="line">	m-&gt;turn = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ns_mutex_acquire</span><span class="params">(<span class="type">ns_mutex_t</span> *m)</span> &#123;</span><br><span class="line">	<span class="comment">// FetchAndAdd(&amp;m-&gt;stic)</span></span><br><span class="line">	Sem_wait(&amp;m-&gt;stic)</span><br><span class="line">	<span class="type">int</span> myturn = m-&gt;ticket++;</span><br><span class="line">	Sem_post(&amp;m-&gt;stic)</span><br><span class="line">    <span class="comment">// 自旋等待轮询到自己</span></span><br><span class="line">	<span class="keyword">while</span> (m-&gt;turn != myturn)</span><br><span class="line">		; <span class="comment">// spin</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ns_mutex_release</span><span class="params">(<span class="type">ns_mutex_t</span> *m)</span> &#123;</span><br><span class="line">	<span class="comment">// FetchAndAdd(&amp;m-&gt;stur)</span></span><br><span class="line">	Sem_wait(&amp;m-&gt;stur)</span><br><span class="line">	m-&gt;turn++;</span><br><span class="line">	Sem_post(&amp;m-&gt;stur)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> value = <span class="number">0</span>;</span><br><span class="line"><span class="type">ns_mutex_t</span> lock;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">worker</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">	ns_mutex_acquire(&amp;lock);</span><br><span class="line">	<span class="type">int</span> tmp = value++;</span><br><span class="line">	ns_mutex_release(&amp;lock);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;tid: %ld &gt; %d\n&quot;</span>, pthread_self(), tmp);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">	assert(argc == <span class="number">2</span>);</span><br><span class="line">	<span class="type">int</span> num_workers = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">	</span><br><span class="line">	<span class="type">pthread_t</span> pool[num_workers];</span><br><span class="line">	ns_mutex_init(&amp;lock);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;parent: begin\n&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_workers; i++)</span><br><span class="line">		Pthread_create(&amp;pool[i], <span class="literal">NULL</span>, worker, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_workers; i++)</span><br><span class="line">		Pthread_join(pool[i], <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;parent: end\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于上面的代码，我们需要的是公平性，我们可以通过学习Mellor-Crummey和Michael Scott提出来的ticket和turn的机制（课本228页）写出代码如上。主要是用了这种turn的轮询机制。通过锁的全局<code>ticket</code>和<code>turn</code>，以及每个线程申请时的<code>myturn</code>来实现公平。课本上主要使用原语<code>FetchAndAdd</code>实现对<code>lock-&gt;turn</code>和<code>lock-&gt;ticket</code>原子操作，这里我们用信号量生成的锁来实现这种原语。其实上面带有<code>FetchAndAdd</code>的注释的地方的代码相当于下面</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FetchAndAdd(sema) &#123;</span></span><br><span class="line">	Sem_wait(&amp;m-&gt;stic)			 \</span><br><span class="line">	<span class="comment">/* 某些操作 */</span>				  \</span><br><span class="line">	Sem_post(&amp;m-&gt;stic)			\</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终运行结果如下，我们可以清楚看到，每个线程都调度了，达到了相对的公平性。</p>
<p><img src="/2022/05/19/OS-thread-homework/image-20220519222752600.png" alt="image-20220519222752600"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Puitar</p>
  <div class="site-description" itemprop="description">博客萌新时不时送来没什么软用的文章</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">2</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/PUITAR" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;PUITAR" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Puitar</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
