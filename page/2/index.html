<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"puitar.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":true,"preload":true},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="博客萌新时不时送来没什么软用的文章">
<meta property="og:type" content="website">
<meta property="og:title" content="Puitar&#39;s Blog">
<meta property="og:url" content="https://puitar.github.io/page/2/index.html">
<meta property="og:site_name" content="Puitar&#39;s Blog">
<meta property="og:description" content="博客萌新时不时送来没什么软用的文章">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Puitar">
<meta property="article:tag" content="菜鸟菜鸟">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://puitar.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Puitar's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Puitar's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://puitar.github.io/2022/06/29/%E5%85%AB%E4%BD%8D%E6%95%B0%E7%A0%81%E7%AE%A1-%E6%B5%81%E6%B0%B4%E7%81%AF%EF%BC%88BSP%E7%89%88%E6%9C%AC%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Puitar">
      <meta itemprop="description" content="博客萌新时不时送来没什么软用的文章">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Puitar's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/29/%E5%85%AB%E4%BD%8D%E6%95%B0%E7%A0%81%E7%AE%A1-%E6%B5%81%E6%B0%B4%E7%81%AF%EF%BC%88BSP%E7%89%88%E6%9C%AC%EF%BC%89/" class="post-title-link" itemprop="url">八位数码管+流水灯（BSP版本）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-06-29 15:06:45" itemprop="dateCreated datePublished" datetime="2022-06-29T15:06:45+08:00">2022-06-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-06-30 08:09:48" itemprop="dateModified" datetime="2022-06-30T08:09:48+08:00">2022-06-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/STC-B/" itemprop="url" rel="index"><span itemprop="name">STC-B</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/STC-B/%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">基础编程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="八位数码管-流水灯（BSP版本）"><a href="#八位数码管-流水灯（BSP版本）" class="headerlink" title="八位数码管+流水灯（BSP版本）"></a>八位数码管+流水灯（BSP版本）</h1><p>因为不是专业的单片机专家，所以既然提供了带有BSP库的版本，自然就用BSP版本。这里介绍一下BSP版本的代码。</p>
<h2 id="文件说明"><a href="#文件说明" class="headerlink" title="文件说明"></a>文件说明</h2><p><img src="/2022/06/29/%E5%85%AB%E4%BD%8D%E6%95%B0%E7%A0%81%E7%AE%A1-%E6%B5%81%E6%B0%B4%E7%81%AF%EF%BC%88BSP%E7%89%88%E6%9C%AC%EF%BC%89/image-20220629151028369.png" alt="image-20220629151028369"></p>
<p>文件的主题部分如上图，除了main函数以外，我们看到<code>STC15F2K60S2.H</code>和前面一样是端口的地址定义的头文件</p>
<p>然后是<code>displayer.h</code>头文件，</p>
<blockquote>
<p><img src="/2022/06/29/%E5%85%AB%E4%BD%8D%E6%95%B0%E7%A0%81%E7%AE%A1-%E6%B5%81%E6%B0%B4%E7%81%AF%EF%BC%88BSP%E7%89%88%E6%9C%AC%EF%BC%89/image-20220629151443888.png" alt="image-20220629151443888"></p>
<p>这一部分就是显示功能的相关接口，STC单片机上的显示主要是数码管和LED灯。</p>
<ul>
<li><code>DisplayerInit</code>是显示模块初始化函数，会对对应的函数的硬件，以及相关针脚进行初始化，具体可以看看前面的博文，就是作P0、P2端口等以及其他相关寄存器的初始化</li>
<li><code>SetDisplayerArea</code>是设置有效显示区域，根据[begin, end]设置数码管显示范围。如果begin = 0，end = 7，显示的就是所有的数码管。但是范围不仅仅是这样，如果你的end大于7，比如是255，这也是能够正常工作的，只是硬件地址只有0-7，但是其他的无效地址会消耗一定的时间，这样总体显示时间变长了，由于是动态扫描的，所以8个有效数码管显示会出现闪烁，亮度下降的现象。</li>
<li><code>Seg7Print</code>参数是输入8个要显示的数据，这个可以根据输入的参数作为在<code>decode_table[]</code>中的索引，可以显示对应灯管的组合</li>
<li><code>LedPrint</code>控制8个数码管开关，一个位对应一个数码管，1是亮，0是暗。</li>
</ul>
</blockquote>
<p>还有一个文件是<code>sys.h</code>，这个是用来执行系统级别的操作，旨在对于用户以及系统的事件做出响应</p>
<blockquote>
<p><img src="/2022/06/29/%E5%85%AB%E4%BD%8D%E6%95%B0%E7%A0%81%E7%AE%A1-%E6%B5%81%E6%B0%B4%E7%81%AF%EF%BC%88BSP%E7%89%88%E6%9C%AC%EF%BC%89/image-20220629155718409.png" alt="image-20220629155718409"></p>
<p><img src="/2022/06/29/%E5%85%AB%E4%BD%8D%E6%95%B0%E7%A0%81%E7%AE%A1-%E6%B5%81%E6%B0%B4%E7%81%AF%EF%BC%88BSP%E7%89%88%E6%9C%AC%EF%BC%89/image-20220629155747086.png" alt="image-20220629155747086"></p>
<p>上面是系统相关的函数，注释写的很清楚，主要是初始化系统，并且定义了事件，以及响应事件的函数。这里不详细展开，用到的时候再进行说明。</p>
</blockquote>
<p>上面头文件涉及的函数，在<code>STCBSP_V3.6.LIB</code>静态库中进行定义，因此可以直接使用。</p>
<p><img src="/2022/06/29/%E5%85%AB%E4%BD%8D%E6%95%B0%E7%A0%81%E7%AE%A1-%E6%B5%81%E6%B0%B4%E7%81%AF%EF%BC%88BSP%E7%89%88%E6%9C%AC%EF%BC%89/image-20220629154235232.png" alt="image-20220629154235232"></p>
<h2 id="主函数逻辑说明"><a href="#主函数逻辑说明" class="headerlink" title="主函数逻辑说明"></a>主函数逻辑说明</h2><p><img src="/2022/06/29/%E5%85%AB%E4%BD%8D%E6%95%B0%E7%A0%81%E7%AE%A1-%E6%B5%81%E6%B0%B4%E7%81%AF%EF%BC%88BSP%E7%89%88%E6%9C%AC%EF%BC%89/image-20220629160509448.png" alt="image-20220629160509448" style="zoom:50%;"></p>
<p><code>main.c</code>中需要将<code>SysClock</code>设置成和下载的<code>IRC</code>一样的频率</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 显示数码管和LED等需要的头文件，其中前面两个是必须的 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;STC15F2K60S2.H&quot;</span>        <span class="comment">// 端口地址定义</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.H&quot;</span>                 <span class="comment">// 使用系统的函数定义</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;displayer.H&quot;</span> 			 <span class="comment">// 数码管显示</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 必须。定义系统工作时钟频率(Hz)，用户要修改成和实际工作频率(下载时)一致，如上图 */</span></span><br><span class="line">code <span class="type">unsigned</span> <span class="type">long</span> SysClock=<span class="number">11059200</span>;  <span class="comment">// code是告诉单片机这个变量的值刷写入ROM，不再改变</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 用户可以进行自定义数码管显示，主要是通过decode_table */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _displayer_H_                         </span></span><br><span class="line">code <span class="type">char</span> decode_table[]=&#123;			<span class="comment">/* 值 */</span></span><br><span class="line">    <span class="number">0x3f</span>,							<span class="comment">// 0		</span></span><br><span class="line">    <span class="number">0x06</span>,							<span class="comment">// 1			 </span></span><br><span class="line">    <span class="number">0x5b</span>,							<span class="comment">// 2			 </span></span><br><span class="line">    <span class="number">0x4f</span>,							<span class="comment">// 3			 											</span></span><br><span class="line">    <span class="number">0x66</span>,							<span class="comment">// 4			 									</span></span><br><span class="line">    <span class="number">0x6d</span>,							<span class="comment">// 5			 											</span></span><br><span class="line">    <span class="number">0x7d</span>,							<span class="comment">// 6			 		</span></span><br><span class="line">    <span class="number">0x07</span>,							<span class="comment">// 7			 </span></span><br><span class="line">    <span class="number">0x7f</span>,							<span class="comment">// 8		     </span></span><br><span class="line">    <span class="number">0x6f</span>,							<span class="comment">// 9			 </span></span><br><span class="line">    <span class="number">0x00</span>,							<span class="comment">// 无</span></span><br><span class="line">    <span class="number">0x08</span>,							<span class="comment">// 下-</span></span><br><span class="line">    <span class="number">0x40</span>,							<span class="comment">// 中-</span></span><br><span class="line">    <span class="number">0x01</span>, 							<span class="comment">// 上-</span></span><br><span class="line">    <span class="number">0x41</span>, 							<span class="comment">// 上中-	</span></span><br><span class="line">    <span class="number">0x48</span>,                 			<span class="comment">// 中下-</span></span><br><span class="line">    <span class="number">0x3f</span>|<span class="number">0x80</span>,						<span class="comment">// 带小数点0		</span></span><br><span class="line">    <span class="number">0x06</span>|<span class="number">0x80</span>,						<span class="comment">// 带小数点1			</span></span><br><span class="line">&#125;;  <span class="comment">// 也可以采用上面的拼接方式进行段选信息的构造</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* LED显示函数，可回调 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">my100mS_callback</span><span class="params">()</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="comment">// 定义一个LED寄存器类型</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> a;</span><br><span class="line">    <span class="comment">// LED显示左移</span></span><br><span class="line">    <span class="keyword">if</span>(a != <span class="number">0</span>) a=a&lt;&lt;<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 超出了，重置</span></span><br><span class="line">    <span class="keyword">else</span> a=<span class="number">0x01</span>;</span><br><span class="line">    <span class="comment">// 显示寄存器值</span></span><br><span class="line">    LedPrint(a);</span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 这里仅仅进行一次打印操作 </span></span><br><span class="line"><span class="comment">  	 * 但是每一次a的值从上一次继承下来，实现了移位操作</span></span><br><span class="line"><span class="comment">  	 * a是局部变量</span></span><br><span class="line"><span class="comment">  	 * 从局部变量声明的时候，它就在堆栈空间了，而不是调用函数的时候，才让它入栈的。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="comment">// 使用显示设备，需要进行初始化</span></span><br><span class="line">    DisplayerInit();  </span><br><span class="line">    <span class="comment">// 设置显示范围为0-64，实际有效只有0-7，因此有无效地址消耗时间，数码管会出现闪烁变暗</span></span><br><span class="line">    SetDisplayerArea(<span class="number">0</span>,<span class="number">64</span>);	</span><br><span class="line">    <span class="comment">// 八个数码管分别显示1-8</span></span><br><span class="line">    Seg7Print(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>);	</span><br><span class="line">    <span class="comment">// 利用回调函数，每100ms，就调用一次函数，这么做是为了节省栈空间，因为单片机的栈很小</span></span><br><span class="line">    SetEventCallBack(enumEventSys100mS, my100mS_callback);</span><br><span class="line">    <span class="comment">/* 这里是初始化系统并循环等待事件，如果没有下面这部分，程序运行结束，板子就死了 */</span></span><br><span class="line">    MySTC_Init();	    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123; </span><br><span class="line">        MySTC_OS();    </span><br><span class="line">    &#125;	             </span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<h2 id="C语言版本"><a href="#C语言版本" class="headerlink" title="C语言版本"></a>C语言版本</h2><p>整体和上一个版本差不多，这里不做赘述。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********************</span></span><br><span class="line"><span class="comment">    :八位数码管+流水灯</span></span><br><span class="line"><span class="comment">型号:STC15F2K60S2 主频:11.0592MHz</span></span><br><span class="line"><span class="comment">************************/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;STC15F2K60S2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> uint unsigned int</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> uchar unsigned char</span></span><br><span class="line"></span><br><span class="line">uchar arrSeg7Select[] = &#123;<span class="number">0x3f</span>, <span class="number">0x06</span>, <span class="number">0x5b</span>, <span class="number">0x4f</span>, <span class="number">0x66</span>, <span class="number">0x6d</span>, <span class="number">0x7d</span>, <span class="number">0x07</span>, <span class="number">0x7f</span>&#125;; <span class="comment">//显示0-8</span></span><br><span class="line">uchar arrDigitSelect[] = &#123;<span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x02</span>, <span class="number">0x03</span>, <span class="number">0x04</span>, <span class="number">0x05</span>, <span class="number">0x06</span>, <span class="number">0x07</span>&#125;;   	<span class="comment">//数码管0-7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*---------引脚别名定义---------*/</span></span><br><span class="line">sbit sbtLedSel = P2 ^ <span class="number">3</span>;   <span class="comment">//数码管与LED灯切换引脚</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*---------变量定义---------*/</span></span><br><span class="line">uchar uiLed = <span class="number">0x01</span>;        <span class="comment">//LED灯值寄存</span></span><br><span class="line">uint  uiLedCnt = <span class="number">0</span>;        <span class="comment">//LED灯累计计数器</span></span><br><span class="line">uchar i = <span class="number">0</span>;               <span class="comment">//数码管扫描显示循环</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*---------初始化函数---------*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    P0M1 = <span class="number">0x00</span>;</span><br><span class="line">    P0M0 = <span class="number">0xff</span>;</span><br><span class="line">    P2M1 = <span class="number">0x00</span>;</span><br><span class="line">    P2M0 = <span class="number">0x08</span>;</span><br><span class="line">    sbtLedSel = <span class="number">0</span>;  <span class="comment">//先选择数码管亮</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*---------延时函数---------*/</span></span><br><span class="line"><span class="comment">//下为生成1ms的延时函数，通过传入参数n，函数可以延时n毫秒</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_ms</span><span class="params">( uint n )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>( n )</span><br><span class="line">    &#123;</span><br><span class="line">        uchar i, j;</span><br><span class="line">        i = <span class="number">11</span>;</span><br><span class="line">        j = <span class="number">190</span>;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> ( --j );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> ( --i );</span><br><span class="line">        n--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*---------主函数---------*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Init();</span><br><span class="line">    <span class="keyword">while</span>( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        sbtLedSel = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++ )</span><br><span class="line">        &#123;</span><br><span class="line">            P0 = <span class="number">0</span>;</span><br><span class="line">            P2 = arrDigitSelect[i];     <span class="comment">//选择数码管的位数</span></span><br><span class="line">            P0 = arrSeg7Select[i + <span class="number">1</span>];  <span class="comment">//显示对应的数值</span></span><br><span class="line">            delay_ms( <span class="number">1</span> );</span><br><span class="line">        &#125;</span><br><span class="line">        uiLedCnt++;</span><br><span class="line">        sbtLedSel = <span class="number">1</span>;</span><br><span class="line">        P0 = uiLed;                     <span class="comment">//LED显示</span></span><br><span class="line">        delay_ms( <span class="number">1</span> );                  <span class="comment">//延时200ms</span></span><br><span class="line">        <span class="keyword">if</span>( uiLedCnt == <span class="number">50</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( uiLed == <span class="number">0x80</span> )        <span class="comment">//value等于0x80时，重新赋初值0x01</span></span><br><span class="line">                uiLed = <span class="number">0x01</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                uiLed = uiLed &lt;&lt; <span class="number">1</span>;    <span class="comment">//value值逐一左移</span></span><br><span class="line">            uiLedCnt = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://puitar.github.io/2022/06/28/%E6%89%AB%E6%8F%8F%E9%A2%91%E7%8E%87%E5%8F%AF%E6%94%B9%E5%8F%98%E7%9A%84%E7%94%B5%E5%AD%90%E9%92%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Puitar">
      <meta itemprop="description" content="博客萌新时不时送来没什么软用的文章">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Puitar's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/28/%E6%89%AB%E6%8F%8F%E9%A2%91%E7%8E%87%E5%8F%AF%E6%94%B9%E5%8F%98%E7%9A%84%E7%94%B5%E5%AD%90%E9%92%9F/" class="post-title-link" itemprop="url">扫描频率可改变的电子钟</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-06-28 08:39:23" itemprop="dateCreated datePublished" datetime="2022-06-28T08:39:23+08:00">2022-06-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-06-29 10:56:35" itemprop="dateModified" datetime="2022-06-29T10:56:35+08:00">2022-06-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/STC-B/" itemprop="url" rel="index"><span itemprop="name">STC-B</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/STC-B/%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">基础编程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="扫描频率可以改变的电子钟"><a href="#扫描频率可以改变的电子钟" class="headerlink" title="扫描频率可以改变的电子钟"></a>扫描频率可以改变的电子钟</h1><h2 id="程序设计思路"><a href="#程序设计思路" class="headerlink" title="程序设计思路"></a>程序设计思路</h2><p>数字钟通过计数模拟时钟，将计数值，转换成时间格式，以格式：“时-分-秒”在LED数码管上显示，并通过案件调整扫描频率。</p>
<p><img src="/2022/06/28/%E6%89%AB%E6%8F%8F%E9%A2%91%E7%8E%87%E5%8F%AF%E6%94%B9%E5%8F%98%E7%9A%84%E7%94%B5%E5%AD%90%E9%92%9F/7c3906954a01b39404fea430d2308932.png" alt="img"></p>
<h2 id="相关寄存器设置"><a href="#相关寄存器设置" class="headerlink" title="相关寄存器设置"></a>相关寄存器设置</h2><ul>
<li><p>P0的八个位和P2.3设置成推挽输出。按键是输入，不需要推挽。设置寄存器配置值如下。    </p>
<blockquote>
<p>P2以及P0的端口设置，和上一个数码管扫描实验是一样的。</p>
<p>额外增加的考虑是P3端口的设置。0通道和1通道都是0，是传统的8051I/O口模式。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">P2M1=<span class="number">0x00</span>;</span><br><span class="line">P2M0=<span class="number">0xff</span>;</span><br><span class="line">P0M1=<span class="number">0x00</span>;</span><br><span class="line">P0M0=<span class="number">0xff</span>;</span><br><span class="line">P3M0=<span class="number">0x00</span>;</span><br><span class="line">P3M1=<span class="number">0x00</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过定时器0，采集方式1，在定时器中断中进行计数累加</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TMOD = <span class="number">0x01</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>打开总的中断</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EA = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>开启定时器中断</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ET0 = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>计数寄存器初始化</p>
<blockquote>
<p>定时器0设置于模式1时，计数寄存器为16位模式，由高8位TH0和低8位TL0两个8位寄存器组成，当设定计算值为65536-50000=15536（D）时，转换为十六进制就是3CB0（H），此时，TH0=3C，TL0=B0分别装入即可，为了免除这些计算步骤，很多编程者采用“TH0=（65536-50000）/256;TL0=（65536-50000）%256“的编程方式，去让单片机自己去计算结果，那么为什么要介入256呢？其实并不难理解，做一下10——16进制的换算就知道了，256（D）=0100（H），这里01就是高8位的数据，00就是低8位的数据，通俗点说，15536（D）里有多少个256，就相当于高8位有多少数值，就是除的关系了，商存入高8位寄存器后余下的数存入低8位即可，取商计算就是TH0=（65536-50000）/256；而取余计算就是TL0=（65536-50000）%256 。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TH0=(<span class="number">65535</span><span class="number">-1000</span>)/<span class="number">256</span>;</span><br><span class="line">TL0=(<span class="number">65535</span><span class="number">-1000</span>)%<span class="number">256</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动定时器</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TR0=<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>中断1优先级置1，表示中断1设置为最高优先级</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PT0=<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置P2和P0为推挽输出模式</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">P2M1=<span class="number">0x00</span>;</span><br><span class="line">P2M0=<span class="number">0xff</span>;</span><br><span class="line">P0M1=<span class="number">0x00</span>;</span><br><span class="line">P0M0=<span class="number">0xff</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="代码说明"><a href="#代码说明" class="headerlink" title="代码说明"></a>代码说明</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 引入端口定义头文件和中断定义头文件 */</span> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;STC15F2K60S2.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;intrins.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 重命名，简写 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> uint unsigned int</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> uchar unsigned char</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 中断1 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> i1 interrupt 1</span></span><br><span class="line"></span><br><span class="line">sbit ledSel = P2 ^<span class="number">3</span>;    			<span class="comment">// LED或数码管选择信号(共用选择端信号)</span></span><br><span class="line">sbit key1 = P3 ^<span class="number">2</span>; 					<span class="comment">// 按键控制数码管扫描的频率</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 显示0-9对应的数字，段选选择 */</span></span><br><span class="line">uchar baseSevenSegment[] = &#123;</span><br><span class="line">    <span class="number">0x3f</span>, <span class="number">0x06</span>, <span class="number">0x5b</span>, <span class="number">0x4f</span>, <span class="number">0x66</span>,</span><br><span class="line">    <span class="number">0x6d</span>, <span class="number">0x7d</span>, <span class="number">0x07</span>, <span class="number">0x7f</span>, <span class="number">0x6f</span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="type">const</span> line = <span class="number">0x40</span>; 	<span class="comment">// &quot;-&quot;：8中中间横杠的段选信息</span></span><br><span class="line"><span class="type">char</span> timeAddOneFlag = <span class="number">0</span>;    		<span class="comment">// 时间增加标志，为1，时间增加一秒</span></span><br><span class="line"><span class="type">char</span> key1ActionFlag = <span class="number">0</span>;     		<span class="comment">// 按键操作标志，为1，按键操作需要响应</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> ledOnFlag = <span class="number">0</span>; 		<span class="comment">// LED亮起标志，为1，LED亮起</span></span><br><span class="line"><span class="type">char</span> tubeOnFlag = <span class="number">0</span>;        		<span class="comment">// 数码管亮标志，为1，数码管亮起</span></span><br><span class="line"><span class="type">int</span> ledValue = <span class="number">1</span>;          	 		<span class="comment">// LED显示值为多少</span></span><br><span class="line"><span class="type">int</span> myDisplay[<span class="number">8</span>] = &#123;<span class="number">0</span>&#125;;     		<span class="comment">// 数码管显示值为多少，一共8个数码管</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> timeCount = <span class="number">1</span>; 		<span class="comment">// 计数器</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> currHour = <span class="number">0</span>;			<span class="comment">// 当前小时</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> currMinute = <span class="number">0</span>;		<span class="comment">// 当前分钟</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> currSecond = <span class="number">0</span>;		<span class="comment">// 当前秒钟</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> interruptCount = <span class="number">0</span>;	<span class="comment">// 中断计数器</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> keyDownTime = <span class="number">0</span>;		<span class="comment">// 按键按下的时间</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> scanTime = <span class="number">1</span>;  		<span class="comment">// 扫描时间</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> currBit = <span class="number">0</span>;   		<span class="comment">// 当前显示的位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 延时函数 可以用ISP生成 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay5us</span><span class="params">()</span>       <span class="comment">//@11.0592MHz</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">    _nop_();</span><br><span class="line">    i = <span class="number">11</span>;</span><br><span class="line">    <span class="keyword">while</span> (--i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置ledSel,转为数码管显示 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">switchToTube</span><span class="params">()</span> &#123;</span><br><span class="line">    ledSel = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置ledSel,转为led设置 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">switchToLed</span><span class="params">()</span> &#123;</span><br><span class="line">    P0 = <span class="number">0</span>;</span><br><span class="line">    ledSel = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 改变其中一位的内容</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param bitNum 位数（第几位）（例如最左那位，则调用1）</span></span><br><span class="line"><span class="comment"> * @param value 改变后的数字，需确保大于0小于10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">change1Bit</span><span class="params">(<span class="type">int</span> bitNum, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    myDisplay[bitNum - <span class="number">1</span>] = baseSevenSegment[value];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 改变其中一位的内容（设置七段码）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param bitNum 位数（第几位）（例如最左那位，则调用1）</span></span><br><span class="line"><span class="comment"> * @param sevenSegCode 目标七段码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">change1Bit_seven</span><span class="params">(<span class="type">int</span> bitNum, <span class="type">int</span> sevenSegCode)</span> &#123;</span><br><span class="line">    myDisplay[bitNum - <span class="number">1</span>] = sevenSegCode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数码管设置为显示指定的数值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param num 数字</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">changeAll</span><span class="params">(<span class="type">long</span> num)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">7</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="type">int</span> foo = num % <span class="number">10</span>;</span><br><span class="line">        myDisplay[i] = baseSevenSegment[foo];</span><br><span class="line">        num /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * led亮</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">displayLed</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (ledOnFlag) &#123;</span><br><span class="line">        switchToLed();</span><br><span class="line">        P0 = ledValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 显示数码管</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">showTube</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tubeOnFlag) &#123;</span><br><span class="line">        switchToTube();</span><br><span class="line">        P0 = <span class="number">0</span>;</span><br><span class="line">        P2 = currBit;</span><br><span class="line">        P0 = myDisplay[currBit];</span><br><span class="line">        Delay5us();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化定时器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">timer0Initialize</span><span class="params">()</span>        <span class="comment">//0.1毫秒@12MHz</span></span><br><span class="line">&#123;</span><br><span class="line">    AUXR |= <span class="number">0x80</span>;        <span class="comment">// 定时器时钟1T模式</span></span><br><span class="line">    TMOD &amp;= <span class="number">0xF0</span>;        <span class="comment">// 设置定时器模式</span></span><br><span class="line">    TL0 = <span class="number">0xAE</span>;        	 <span class="comment">// 设置定时器初值</span></span><br><span class="line">    TH0 = <span class="number">0xFB</span>;          <span class="comment">// 设置定时器初值</span></span><br><span class="line">    TF0 = <span class="number">0</span>;             <span class="comment">// 清除TF0标志</span></span><br><span class="line">    TR0 = <span class="number">1</span>;             <span class="comment">// 定时器0开始计时</span></span><br><span class="line">    EA = <span class="number">1</span>; 			 <span class="comment">// 打开总的中断</span></span><br><span class="line">    ET0 = <span class="number">1</span>; 			 <span class="comment">// 打开定时器0中断</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 整体程序初始化函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">initialize</span><span class="params">()</span> &#123;</span><br><span class="line">    P0M0 = <span class="number">0xFF</span>;</span><br><span class="line">    P0M1 = <span class="number">0x00</span>;</span><br><span class="line">    P2M0 = <span class="number">0x0f</span>; <span class="comment">//设置P2.0-3为推挽工作状态</span></span><br><span class="line">    P2M1 = <span class="number">0x00</span>;</span><br><span class="line">    P3M0 = <span class="number">0x00</span>;</span><br><span class="line">    P3M1 = <span class="number">0x00</span>;</span><br><span class="line">    P3M0 = <span class="number">0x00</span>;</span><br><span class="line">    P3M1 = <span class="number">0x00</span>;</span><br><span class="line">    ledSel = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    timer0Initialize();</span><br><span class="line">    changeAll(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 第三位和第六位设置为 &#x27;-&#x27;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    change1Bit_seven(<span class="number">3</span>, line);</span><br><span class="line">    change1Bit_seven(<span class="number">6</span>, line);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 时间自增1秒</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">addTime</span><span class="params">()</span> &#123;</span><br><span class="line">    ++currSecond;</span><br><span class="line">    <span class="keyword">if</span> (currSecond == <span class="number">60</span>) &#123;</span><br><span class="line">        ++currMinute;</span><br><span class="line">        currSecond = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (currMinute == <span class="number">60</span>) &#123;</span><br><span class="line">            ++currHour;</span><br><span class="line">            currMinute = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (currHour == <span class="number">24</span>)</span><br><span class="line">                currHour = <span class="number">0</span>;</span><br><span class="line">            change1Bit(<span class="number">2</span>, currHour % <span class="number">10</span>);</span><br><span class="line">            change1Bit(<span class="number">1</span>, currHour / <span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        change1Bit(<span class="number">5</span>, currMinute % <span class="number">10</span>);</span><br><span class="line">        change1Bit(<span class="number">4</span>, currMinute / <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    change1Bit(<span class="number">8</span>, currSecond % <span class="number">10</span>);</span><br><span class="line">    change1Bit(<span class="number">7</span>, currSecond / <span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 按下key1要做的事</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">key1Action</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (key1ActionFlag) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ledValue == <span class="number">0x80</span>)</span><br><span class="line">            ledValue = <span class="number">0x01</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ledValue &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (ledValue == <span class="number">1</span>)</span><br><span class="line">            scanTime = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ledValue == <span class="number">2</span>)</span><br><span class="line">            scanTime = <span class="number">50</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ledValue == <span class="number">4</span>)</span><br><span class="line">            scanTime = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ledValue == <span class="number">8</span>)</span><br><span class="line">            scanTime = <span class="number">200</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ledValue == <span class="number">16</span>)</span><br><span class="line">            scanTime = <span class="number">500</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ledValue == <span class="number">32</span>)</span><br><span class="line">            scanTime = <span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ledValue == <span class="number">64</span>)</span><br><span class="line">            scanTime = <span class="number">2000</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ledValue == <span class="number">128</span>)</span><br><span class="line">            scanTime = <span class="number">5000</span>;</span><br><span class="line">        key1ActionFlag = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 收到中断的信号（是时候自增时间了）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">timeSignalHandler</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (timeAddOneFlag) &#123;</span><br><span class="line">        addTime();</span><br><span class="line">        timeAddOneFlag = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单片机运行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        timeSignalHandler();</span><br><span class="line">        displayLed();</span><br><span class="line">        showTube();</span><br><span class="line">        key1Action();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 每0.1毫秒进入一次定时器中断</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">interruptFunction</span><span class="params">()</span> i1 &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> KEY_TIME_THRESHOLD = <span class="number">500</span>;</span><br><span class="line">    interruptCount = (interruptCount + <span class="number">1</span>) % <span class="number">20000</span>;</span><br><span class="line">    <span class="comment">// led显示的频率应该低些才有好的显示效果</span></span><br><span class="line">    <span class="keyword">if</span> (interruptCount % <span class="number">12</span> &gt; <span class="number">10</span>) &#123;</span><br><span class="line">        ledOnFlag = <span class="number">1</span>;</span><br><span class="line">        tubeOnFlag = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        tubeOnFlag = <span class="number">1</span>;</span><br><span class="line">        ledOnFlag = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 数码管的扫描</span></span><br><span class="line">    <span class="keyword">if</span> (interruptCount % scanTime == <span class="number">0</span>)</span><br><span class="line">        currBit = (currBit + <span class="number">1</span>) % <span class="number">8</span>;</span><br><span class="line">    <span class="comment">// 读秒</span></span><br><span class="line">    <span class="keyword">if</span> (interruptCount % <span class="number">10000</span> == <span class="number">0</span>)</span><br><span class="line">        timeAddOneFlag = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 按键功能设置</span></span><br><span class="line">    <span class="keyword">if</span> (key1 == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (keyDownTime &lt; KEY_TIME_THRESHOLD)</span><br><span class="line">            ++keyDownTime;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (keyDownTime &gt;= KEY_TIME_THRESHOLD)</span><br><span class="line">            key1ActionFlag = <span class="number">1</span>;</span><br><span class="line">        keyDownTime = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    initialize();</span><br><span class="line">    run();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​        </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://puitar.github.io/2022/06/27/%E5%85%AB%E4%BD%8D%E6%95%B0%E7%A0%81%E7%AE%A1%E5%8A%A8%E6%80%81%E6%89%AB%E6%8F%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Puitar">
      <meta itemprop="description" content="博客萌新时不时送来没什么软用的文章">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Puitar's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/27/%E5%85%AB%E4%BD%8D%E6%95%B0%E7%A0%81%E7%AE%A1%E5%8A%A8%E6%80%81%E6%89%AB%E6%8F%8F/" class="post-title-link" itemprop="url">八位数码管动态扫描</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-06-27 13:32:45 / Modified: 14:52:10" itemprop="dateCreated datePublished" datetime="2022-06-27T13:32:45+08:00">2022-06-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/STC-B/" itemprop="url" rel="index"><span itemprop="name">STC-B</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/STC-B/%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">基础编程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="八位数码管动态扫描"><a href="#八位数码管动态扫描" class="headerlink" title="八位数码管动态扫描"></a>八位数码管动态扫描</h1><p>实验工程可以在学习通上面下载</p>
<h2 id="程序设计流程图"><a href="#程序设计流程图" class="headerlink" title="程序设计流程图"></a>程序设计流程图</h2><p><img src="/2022/06/27/%E5%85%AB%E4%BD%8D%E6%95%B0%E7%A0%81%E7%AE%A1%E5%8A%A8%E6%80%81%E6%89%AB%E6%8F%8F/a30fcab29846191787fc9aaabeae05fa.png" alt="img"></p>
<p>在程序启动的初期，需要对硬件有抽象的定义，这由我们的.h头文件表示，初始化硬件，实际是对一些寄存器的初始化，和上一个流水灯的<code>init</code>函数差不多。然后就是主要逻辑，扫描位选，并完成端口的赋值。</p>
<h2 id="原理说明"><a href="#原理说明" class="headerlink" title="原理说明"></a>原理说明</h2><h3 id="什么是段选和位选"><a href="#什么是段选和位选" class="headerlink" title="什么是段选和位选"></a>什么是段选和位选</h3><p>简单说：段选信号是选择数码管的那一段灯管亮起，位选信号是选择八个数码管的哪一个。</p>
<p><img src="/2022/06/27/%E5%85%AB%E4%BD%8D%E6%95%B0%E7%A0%81%E7%AE%A1%E5%8A%A8%E6%80%81%E6%89%AB%E6%8F%8F/image-20220627143830272.png" alt="image-20220627143830272"></p>
<p>如下图，由于这八个数码管是通用的同一个GND，也就是共地的。（一次只能一个开漏地级接给一个数码管，否则不同的二极管会冲突）因此，一次只能有一个数码管亮起，比如下图中八个数码管一次显示0-7，则只能够从左到右，D1先显示0，D1熄灭，D2再显示1，D2熄灭，…，然后轮流下去，如果速度够快，人眼看起来就像灯是一起亮着的。</p>
<p><img src="/2022/06/27/%E5%85%AB%E4%BD%8D%E6%95%B0%E7%A0%81%E7%AE%A1%E5%8A%A8%E6%80%81%E6%89%AB%E6%8F%8F/image-20220627135806124.png" alt="image-20220627135806124" style="zoom:50%;"></p>
<h3 id="段选进一步说明"><a href="#段选进一步说明" class="headerlink" title="段选进一步说明"></a>段选进一步说明</h3><p><img src="/2022/06/27/%E5%85%AB%E4%BD%8D%E6%95%B0%E7%A0%81%E7%AE%A1%E5%8A%A8%E6%80%81%E6%89%AB%E6%8F%8F/image-20220627142752484.png" alt="image-20220627142752484"></p>
<p><img src="/2022/06/27/%E5%85%AB%E4%BD%8D%E6%95%B0%E7%A0%81%E7%AE%A1%E5%8A%A8%E6%80%81%E6%89%AB%E6%8F%8F/image-20220627142912078.png" alt="image-20220627142912078" style="zoom:50%;"></p>
<p>位选就是第几个数码管，段选是怎么来的？</p>
<blockquote>
<p>比如我们要左起第3个（01234567）数码管显示6，因此位选就是2，也就是P2  = 2，当然也可以用程序中的方法（多此一举）<code>P2 = weixuan[2]</code></p>
<p>然后段选要显示6根据上面的图，我们知道，显示6，需要“a, c, d, f, g, e”这些灯管亮起。所以位选信息如下</p>
<p><img src="/2022/06/27/%E5%85%AB%E4%BD%8D%E6%95%B0%E7%A0%81%E7%AE%A1%E5%8A%A8%E6%80%81%E6%89%AB%E6%8F%8F/image-20220627144325373.png" alt="image-20220627144325373" style="zoom:80%;"></p>
<p>所以因此段选信息就是：<code>duanxuan[6] = 0b0111101 = 0x7d</code></p>
<p>所以对应P0.7-P0.0就是0x7d</p>
<p>类似上面的方法就可以枚举出所有的段选情况：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uchar duanxuan[]=&#123;<span class="number">0x3f</span>,<span class="number">0x06</span>,<span class="number">0x5b</span>,<span class="number">0x4f</span>,<span class="number">0x66</span>,<span class="number">0x6d</span>,<span class="number">0x7d</span>,<span class="number">0x07</span>,<span class="number">0x7f</span>&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="代码说明"><a href="#代码说明" class="headerlink" title="代码说明"></a>代码说明</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 对硬件各个端口的定义的头文件，直接使用即可 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;STC15F2K60S2.h&gt;</span></span></span><br><span class="line"><span class="comment">/* 重定义类型名，简写 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> uint unsigned int</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> uchar unsigned char</span></span><br><span class="line"></span><br><span class="line">uint i=<span class="number">0</span>;</span><br><span class="line"><span class="comment">// 段选：选择亮灯</span></span><br><span class="line">uchar duanxuan[]=&#123;<span class="number">0x3f</span>,<span class="number">0x06</span>,<span class="number">0x5b</span>,<span class="number">0x4f</span>,<span class="number">0x66</span>,<span class="number">0x6d</span>,<span class="number">0x7d</span>,<span class="number">0x07</span>,<span class="number">0x7f</span>&#125;;</span><br><span class="line"><span class="comment">// 位选：选择哪一个数码管</span></span><br><span class="line">uchar weixuan[]=&#123;<span class="number">0x00</span>,<span class="number">0x01</span>,<span class="number">0x02</span>,<span class="number">0x03</span>,<span class="number">0x04</span>,<span class="number">0x05</span>,<span class="number">0x06</span>,<span class="number">0x07</span>&#125;;			 </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay</span><span class="params">(<span class="type">int</span> n)</span>				<span class="comment">// 延时函数，单位毫秒</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(n--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 设置推挽输出</span></span><br><span class="line"><span class="comment">     * 和流水灯实验类似，对P0端口和P2端口进行设置</span></span><br><span class="line"><span class="comment">     * 端口设置推挽输出，通道0设置“1”，通道0全0，具体见数据手册，流水灯也讲过了</span></span><br><span class="line"><span class="comment">     * 端口0的0通道，是表示位选，八个位对应八个灯管，所以全部设成1</span></span><br><span class="line"><span class="comment">     * 端口2的0通道，是表示段选，一次只能选一个数码管，由三位输入进行选择</span></span><br><span class="line"><span class="comment">     * 分别是：P2.2 P2.1 P2.0</span></span><br><span class="line"><span class="comment">     * 刚好是P2的第三位，所以赋值时候，只要P2 = weixuan[i]</span></span><br><span class="line"><span class="comment">     * 就可以</span></span><br><span class="line"><span class="comment">     * 这里简单将2的0通道全部设成1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	P2M0=<span class="number">0xff</span>;					</span><br><span class="line">   	P2M1=<span class="number">0x00</span>;</span><br><span class="line">    P0M0=<span class="number">0xff</span>;</span><br><span class="line">    P0M1=<span class="number">0x00</span>;</span><br><span class="line">	<span class="comment">/* 循环扫描数码管</span></span><br><span class="line"><span class="comment">     * 不断扫描数码管，使每一小段数码管都点亮一段时间</span></span><br><span class="line"><span class="comment">     * 视觉上一直是亮的状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			P0=<span class="number">0</span>;</span><br><span class="line">			P2=weixuan[i];		<span class="comment">// 选择数码管的位数</span></span><br><span class="line">			P0=duanxuan[i+<span class="number">1</span>];	<span class="comment">// 选择对应的数值</span></span><br><span class="line">			Delay(<span class="number">600</span>);			<span class="comment">// 延时</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://puitar.github.io/2022/06/26/%E6%B5%81%E6%B0%B4%E7%81%AF%E5%AE%9E%E9%AA%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Puitar">
      <meta itemprop="description" content="博客萌新时不时送来没什么软用的文章">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Puitar's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/26/%E6%B5%81%E6%B0%B4%E7%81%AF%E5%AE%9E%E9%AA%8C/" class="post-title-link" itemprop="url">流水灯实验</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-06-26 11:02:25" itemprop="dateCreated datePublished" datetime="2022-06-26T11:02:25+08:00">2022-06-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-06-27 11:28:23" itemprop="dateModified" datetime="2022-06-27T11:28:23+08:00">2022-06-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/STC-B/" itemprop="url" rel="index"><span itemprop="name">STC-B</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/STC-B/%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">基础编程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="流水灯实验"><a href="#流水灯实验" class="headerlink" title="流水灯实验"></a>流水灯实验</h1><h2 id="程序设计思路"><a href="#程序设计思路" class="headerlink" title="程序设计思路"></a>程序设计思路</h2><p>流水灯是经典实验。要点亮发光二极管，要把P0端口和P2.3端口设置成推挽输出，然后</p>
<ul>
<li>将P2.3设成“1”，这表示使能发光二极管</li>
<li>对P0端口赋值，就可以点亮对应的led灯了</li>
</ul>
<p>而对于流水灯，基本思路就是点亮一个led灯，等待一段时间，然后熄灭它，同时点亮下一个led灯，然后如此循环下去，就可以看到流水效果如下</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">00000001</span><br><span class="line">00000010</span><br><span class="line">00000100</span><br><span class="line">00001000</span><br><span class="line">00010000</span><br><span class="line">00100000</span><br><span class="line">01000000</span><br><span class="line">10000000</span><br><span class="line">00000001</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h2 id="关键代码说明"><a href="#关键代码说明" class="headerlink" title="关键代码说明"></a>关键代码说明</h2><h3 id="相关定义以及头文件"><a href="#相关定义以及头文件" class="headerlink" title="相关定义以及头文件"></a>相关定义以及头文件</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 这个是我们的单片机的端口的定义 */</span></span><br><span class="line"><span class="comment">/* 如果仔细阅读头文件，可以看到就是用唯一的整数标识每一个端口 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;STC15F2K60S2.H&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义类型，简写 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> uchar unsigned char</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> uint unsigned int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 选择位 */</span></span><br><span class="line">sbit led_sel=P2^<span class="number">3</span>; <span class="comment">// 端口P2.3</span></span><br><span class="line">uchar led;         <span class="comment">// 用一个uchar表示8个LED，每一个是1位</span></span><br></pre></td></tr></table></figure>
<p>本程序主要是三个函数组成</p>
<h3 id="对二级管初始化"><a href="#对二级管初始化" class="headerlink" title="对二级管初始化"></a>对二级管初始化</h3><blockquote>
<p><code>void Init();</code></p>
</blockquote>
<p>这个函数主要是发光二极管的初始化设置：</p>
<p><strong>只要将P0口和P2.3工作模式设置为推挽输出，同时将P2.3置“1”，使能发光二极管电路。</strong>（这里的置“1”是P2的bit3置为1）</p>
<p><img src="/2022/06/26/%E6%B5%81%E6%B0%B4%E7%81%AF%E5%AE%9E%E9%AA%8C/image-20220626175135866.png" alt="image-20220626175135866"></p>
<p><img src="/2022/06/26/%E6%B5%81%E6%B0%B4%E7%81%AF%E5%AE%9E%E9%AA%8C/image-20220626175208809.png" alt="image-20220626175208809"></p>
<p>其中P0、P2这两个端口的设置通过对对应的寄存器赋值来设置实现。</p>
<p>看看上面两个表，其中第一列，也就是通道1为0（八个位都是0），通道0为1（特定位为1），表示处于推挽模式。STC15F2K60S2数据手册4.1章节（322页）有详细的介绍，下面简单介绍进一步如何配置。</p>
<p><img src="/2022/06/26/%E6%B5%81%E6%B0%B4%E7%81%AF%E5%AE%9E%E9%AA%8C/image-20220626174347225.png" alt="image-20220626174347225"></p>
<p>上面是STC-B的部分电路原理图。由于处于推挽输出模式，要求通道0为1，通道1为0。通道1为0，就把通道一八个位全部设置成低电平。但是通道0为1就要对特定位进行赋1。对于P0端口，我们可以在电路图中看到是红色框框，它对应了八个发光二极管的正极端，所以要让8个发光二极管统统发光，就要全部设置使能。所以对于P0的通道0，进行赋1，就要把八个位全部设置成1。另一方面，对于P2端口。我们看到上面对于这个实验的led灯，只有一个LED负极开漏端有一个LED_SEL选择信号，表示选择哪一个LED发光。可以看到蓝色框框，只是P2.3，也就是端口P2的0通道的第三个位赋1就好。</p>
<p>因此我们得到如下初始化代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Init</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">// P0的通道1全0</span></span><br><span class="line">	P0M1=<span class="number">0x00</span>;</span><br><span class="line">    <span class="comment">// P0的通道0全1</span></span><br><span class="line">	P0M0=<span class="number">0xff</span>;</span><br><span class="line">	<span class="comment">// P2的通道1全0</span></span><br><span class="line">	P2M1=<span class="number">0x00</span>;</span><br><span class="line">    <span class="comment">// P2的通道0只要bit3为1</span></span><br><span class="line">	P2M0=<span class="number">0x08</span>;</span><br><span class="line">	<span class="comment">// 流水灯从L0开始(00000001)</span></span><br><span class="line">	led_sel=<span class="number">1</span>;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="延时函数"><a href="#延时函数" class="headerlink" title="延时函数"></a>延时函数</h3><blockquote>
<p><code>void delay_ms(uint n);</code></p>
</blockquote>
<p>函数<code>delay_ms</code>的功能是延时n毫秒，但时间不一定特别准确。单片机工作在同一的时钟脉冲控制下。这个脉冲式单片机控制器的时钟电路产生的。时钟电路由振荡器和分频器构成，振荡器产生基本振荡信号，然后分频，得到相应时钟。（这玩意了解一下就好了）</p>
<p><strong>关于单片机中周期的说明：</strong></p>
<ul>
<li><p>振荡周期： 晶体振荡器的周期。</p>
</li>
<li><p>状态周期： 振荡信号经二分频后形成的时钟脉冲信号，用S表示。一个状态周期的两个振荡周期作为两个节拍分别称为节拍P1和节拍P2。P1有效时，通常完成算术逻辑操作；P2有效时，一般进行内部寄存器之间的传输。</p>
</li>
<li><p>机器周期： 完成一个基本操作所需的时间称为机器周期。一个机器周期包含6个状态周期，用S1、S2、….、S6表示；共12个节拍，依次可表示为S1P1、S1P2、S2P1、S2P2、……、S6P1、S6P2。</p>
</li>
<li><p>指令周期：CPU执行一条指令所需要的时间。CPU执行指令是在时钟脉冲控制下一步一步进行的，由于指令的功能和长短各不相同，因此，指令执行所需的时间也不一样。一个指令周期通常含有1～4个机器周期。 </p>
</li>
</ul>
<p><img src="/2022/06/26/%E6%B5%81%E6%B0%B4%E7%81%AF%E5%AE%9E%E9%AA%8C/b8bf661c195bddcad5caf5d85ce46e12.png" alt="img"></p>
<p>上图是MCS-51单片机各种周期的相互关系。</p>
<p>因此，根据指令执行的时间，可计算出1ms可以相应执行多少条指令，函数中可通过循环执行空指令来达到延时1ms的效果。此外延时函数也可以在STC-ISP中通过“软件延时计算器”功能自动生成指定延时时间的延时函数代码，如下：</p>
<p><img src="/2022/06/26/%E6%B5%81%E6%B0%B4%E7%81%AF%E5%AE%9E%E9%AA%8C/image-20220626184218824.png" alt="image-20220626184218824"></p>
<p>直接用ISP串口助手生成延时200ms对应的代码即可</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Delay200ms</span><span class="params">()</span>		<span class="comment">//@11.0592MHz</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i, j, k;</span><br><span class="line">	<span class="comment">//_nop_();</span></span><br><span class="line">	<span class="comment">//_nop_();</span></span><br><span class="line">	i = <span class="number">9</span>;</span><br><span class="line">	j = <span class="number">104</span>;</span><br><span class="line">	k = <span class="number">139</span>;</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">do</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">while</span> (--k);</span><br><span class="line">		&#125; <span class="keyword">while</span> (--j);</span><br><span class="line">	&#125; <span class="keyword">while</span> (--i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h3><blockquote>
<p>void main();</p>
</blockquote>
<p>首先要调用函数Init()对电路进行初始化，再循环地对P0口进行赋值，点亮流水灯。</p>
<p>每一次流水灯对应点亮的位向左移动一位，具体就如“程序设计思路”的演示图所示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 初始化LED灯</span></span><br><span class="line">	Init();</span><br><span class="line">    <span class="comment">// 从L0开始亮</span></span><br><span class="line">	led=<span class="number">0x01</span>;</span><br><span class="line">    <span class="comment">// 无休止闪烁</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">// P0端口连接LED灯，所以把寄存器LED给P0</span></span><br><span class="line">		P0=led;</span><br><span class="line">		<span class="comment">// 延时200ms	</span></span><br><span class="line">		Delay200ms();</span><br><span class="line">        <span class="comment">// LED寄存器状态赋值</span></span><br><span class="line">		<span class="keyword">if</span>(led==<span class="number">0x80</span>) <span class="comment">// 如果到了L7灯，下一个状态又从L0开始</span></span><br><span class="line">			led=<span class="number">0x01</span>;</span><br><span class="line">		<span class="keyword">else</span>		  <span class="comment">// 否则左移一位</span></span><br><span class="line">			led=led&lt;&lt;<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="下载程序"><a href="#下载程序" class="headerlink" title="下载程序"></a>下载程序</h2><p>在学习资料里面下载相关工具。主要是<em>keil uvision 4</em>。</p>
<p><img src="/2022/06/26/%E6%B5%81%E6%B0%B4%E7%81%AF%E5%AE%9E%E9%AA%8C/image-20220627112449125.png" alt="image-20220627112449125"></p>
<p>新建工程uprojx，然后编译生成hex文件，烧入程序，运行。</p>
<blockquote>
<p>如果编译没有生成<code>.hex</code>文件可以进行如下设置</p>
</blockquote>
<p><img src="/2022/06/26/%E6%B5%81%E6%B0%B4%E7%81%AF%E5%AE%9E%E9%AA%8C/image-20220627112712761.png" alt="image-20220627112712761"></p>
<p><strong>成功效果</strong>如下</p>
<p><img src="/2022/06/26/%E6%B5%81%E6%B0%B4%E7%81%AF%E5%AE%9E%E9%AA%8C/image-20220627112808166.png" alt="image-20220627112808166"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://puitar.github.io/2022/06/22/%E4%BA%BA%E6%B5%81%E7%BB%9F%E8%AE%A1%E6%A8%A1%E5%9D%97%E8%AF%B4%E6%98%8E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Puitar">
      <meta itemprop="description" content="博客萌新时不时送来没什么软用的文章">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Puitar's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/22/%E4%BA%BA%E6%B5%81%E7%BB%9F%E8%AE%A1%E6%A8%A1%E5%9D%97%E8%AF%B4%E6%98%8E/" class="post-title-link" itemprop="url">人流统计模块说明</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-06-22 20:04:50 / Modified: 20:26:14" itemprop="dateCreated datePublished" datetime="2022-06-22T20:04:50+08:00">2022-06-22</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%89%A9%E8%81%94%E7%BD%91%E8%AE%BE%E8%AE%A1%E5%A4%A7%E8%B5%9B/" itemprop="url" rel="index"><span itemprop="name">物联网设计大赛</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%89%A9%E8%81%94%E7%BD%91%E8%AE%BE%E8%AE%A1%E5%A4%A7%E8%B5%9B/%E6%A8%A1%E5%9D%97/" itemprop="url" rel="index"><span itemprop="name">模块</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="人流统计模块讲解"><a href="#人流统计模块讲解" class="headerlink" title="人流统计模块讲解"></a>人流统计模块讲解</h1><p>我们使用<code>onenet</code>提供的AI平台的接口</p>
<h2 id="人体检测"><a href="#人体检测" class="headerlink" title="人体检测"></a>人体检测</h2><h3 id="能力介绍"><a href="#能力介绍" class="headerlink" title="能力介绍"></a>能力介绍</h3><p>接口能力：检测并定位图片中无遮挡的人体，返回人体位置和置信度（0~1），可实现多人体检测；</p>
<p>图片格式：现支持PNG、JPG、JPEG、BMP，不支持GIF图片；</p>
<p>图片大小：上传图片大小不超过2M；图片中识别的人体不被遮挡，人体区域高度120像素以上，宽度80像素以上；</p>
<p>业务应用：智慧零售人流量统计、人体跟踪、安防监控。</p>
<h3 id="API调用方式"><a href="#API调用方式" class="headerlink" title="API调用方式"></a>API调用方式</h3><div class="table-container">
<table>
<thead>
<tr>
<th><code>请求方式</code></th>
<th><code>POST</code></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>url</code></td>
<td><code>http://ai.heclouds.com:9090/v1/aiApi/picture/BODY_RECO</code></td>
</tr>
<tr>
<td><code>http-header</code></td>
<td><code>token</code>: xxxxxxxxxxxxxxxxx  //通过AI Key和Secret Key鉴权（推荐）</td>
</tr>
<tr>
<td><code>request-body</code></td>
<td><code>&#123;    &quot;picture&quot;: [&quot;String&quot;]  //一张图片的base64图片编码</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="下面是python的示例代码"><a href="#下面是python的示例代码" class="headerlink" title="下面是python的示例代码"></a>下面是python的示例代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;http://ai.heclouds.com:9090/v1/aiApi/picture/BODY_RECO&#x27;</span></span><br><span class="line">headers =&#123;</span><br><span class="line">    <span class="string">&#x27;Content-Type&#x27;</span>:<span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;token&#x27;</span>:<span class="string">&#x27;xxxxxxxxxxxxxxxxx(用户鉴权接口返回结果中的accessToken)&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开图片文件</span></span><br><span class="line">file = <span class="built_in">open</span>(<span class="string">&#x27;D:/Desktop/体验图片/03人体检测/body5.png&#x27;</span>,<span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将其转为base64信息</span></span><br><span class="line">base64Str = base64.b64encode(file.read()).decode()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭打开的文件</span></span><br><span class="line">file.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造接口调用参数</span></span><br><span class="line">data = &#123;</span><br><span class="line">  <span class="string">&#x27;picture&#x27;</span>:[base64Str]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># POST 方式调用</span></span><br><span class="line">response = requests.request(<span class="string">&quot;POST&quot;</span>, url, headers=headers, data=json.dumps(data))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印结果</span></span><br><span class="line"><span class="built_in">print</span>(response.text)</span><br></pre></td></tr></table></figure>
<h3 id="返回示例"><a href="#返回示例" class="headerlink" title="返回示例"></a>返回示例</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;stateCode&quot;</span>: <span class="string">&quot;0x0000&quot;</span>, //结果状态码，16进制。<span class="string">&quot;0x0000&quot;</span>：成功</span><br><span class="line">    <span class="string">&quot;message&quot;</span>: <span class="string">&quot;success&quot;</span>,  //返回信息</span><br><span class="line">    <span class="string">&quot;data&quot;</span>: Array  //JSON对象数组，每一个JSON对象表示一个人体，包含了人体在图片中的位置、大小，标签，置信度</span><br><span class="line">&#125;</span><br><span class="line">例如:</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        //人体在图片中的位置、大小</span><br><span class="line">        <span class="string">&quot;box&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;x&quot;</span>: 50,</span><br><span class="line">            <span class="string">&quot;y&quot;</span>: 270,</span><br><span class="line">            <span class="string">&quot;width&quot;</span>: 795,</span><br><span class="line">            <span class="string">&quot;height&quot;</span>: 978</span><br><span class="line">        &#125;,</span><br><span class="line">        //置信度（0~1）</span><br><span class="line">        <span class="string">&quot;confidence&quot;</span>: 0.9998502731323242,</span><br><span class="line">        //标签</span><br><span class="line">        <span class="string">&quot;label&quot;</span>: <span class="string">&quot;person&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line">注意：</span><br><span class="line">http错误码返回<span class="string">&quot;401&quot;</span>时表示<span class="string">&quot;未经授权&quot;</span>，造成的原因有：未使用或使用的token不正确；使用的token已经超时失效。</span><br></pre></td></tr></table></figure>
<h2 id="代码说明"><a href="#代码说明" class="headerlink" title="代码说明"></a>代码说明</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获得tocken对应的keys</span></span><br><span class="line">aiKey = <span class="string">&#x27;d071c2afa0f14fb28d40be114e524984&#x27;</span></span><br><span class="line">secretKey = <span class="string">&#x27;209e5e8fb0b64299b671cc8a0c3a3592&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取access Token</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_access_token</span>(<span class="params">aikey, seckey</span>):</span><br><span class="line">    tkUrl = <span class="string">&#x27;http://ai.heclouds.com:9090/v1/user/app/accessToken?aiKey=%s&amp;secretKey=%s&#x27;</span> % (aiKey, secretKey)</span><br><span class="line">    tkheader = &#123;</span><br><span class="line">        <span class="string">&quot;Content-Type&quot;</span> : <span class="string">&quot;application/json&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># 获得tocken返回的json</span></span><br><span class="line">    r = requests.get(url=tkUrl, headers=tkheader).json()</span><br><span class="line">    <span class="keyword">return</span> r[<span class="string">&quot;data&quot;</span>][<span class="string">&quot;accessToken&quot;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getRes</span>():</span><br><span class="line">    url = <span class="string">&#x27;http://ai.heclouds.com:9090/v1/aiApi/picture/BODY_RECO&#x27;</span></span><br><span class="line">    headers =&#123;</span><br><span class="line">        <span class="string">&#x27;Content-Type&#x27;</span>:<span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;token&#x27;</span>: get_access_token(aiKey, secretKey)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># 打开图片文件</span></span><br><span class="line">    file = <span class="built_in">open</span>(<span class="string">&#x27;1.png&#x27;</span>,<span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">    <span class="comment"># 将其转为base64信息</span></span><br><span class="line">    base64Str = base64.b64encode(file.read()).decode()</span><br><span class="line">    <span class="comment"># 关闭打开的文件</span></span><br><span class="line">    file.close()</span><br><span class="line">    <span class="comment"># 构造接口调用参数</span></span><br><span class="line">    data = &#123;</span><br><span class="line">        <span class="string">&#x27;picture&#x27;</span>:[base64Str]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># POST 方式调用</span></span><br><span class="line">    response = requests.request(<span class="string">&quot;POST&quot;</span>, url, headers=headers, data=json.dumps(data)).json()</span><br><span class="line">    <span class="comment"># 打印结果</span></span><br><span class="line">    <span class="comment"># print(len(response[&quot;data&quot;]))</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(response[<span class="string">&quot;data&quot;</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    getRes()</span><br></pre></td></tr></table></figure>
<p>注释已经讲解的很清楚了。上一个函数是获得<code>accessToken</code>的函数，下一个就是获取答案，由于答案是返回一个json数组，每一个元素就是一个人体，一个框框的信息。我们直接次<code>len</code>函数获得数组的元素个数。我们就可以获得实时人数。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://puitar.github.io/2022/06/14/OS%E6%9C%9F%E6%9C%AB%E9%93%A7%E9%94%BA%E7%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Puitar">
      <meta itemprop="description" content="博客萌新时不时送来没什么软用的文章">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Puitar's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/14/OS%E6%9C%9F%E6%9C%AB%E9%93%A7%E9%94%BA%E7%A2%98/" class="post-title-link" itemprop="url">OS期末铧锺碘</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-06-14 16:53:07" itemprop="dateCreated datePublished" datetime="2022-06-14T16:53:07+08:00">2022-06-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-07-14 15:11:52" itemprop="dateModified" datetime="2022-07-14T15:11:52+08:00">2022-07-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/courses-learning/" itemprop="url" rel="index"><span itemprop="name">courses-learning</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/courses-learning/%E5%A4%A7%E4%BA%8C%E4%B8%8B%E6%9C%9F%E6%9C%AB/" itemprop="url" rel="index"><span itemprop="name">大二下期末</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="操作系统铧锺碘"><a href="#操作系统铧锺碘" class="headerlink" title="操作系统铧锺碘"></a>操作系统铧锺碘</h1><p>期末考占总评的40%</p>
<p>老师提到的考试复习指南：</p>
<ul>
<li>注重应用，需要直到API怎么用，各个参数是什么</li>
<li>能够举一些例子</li>
<li>从网络上找一些经典的资料</li>
</ul>
<h2 id="四个简答题"><a href="#四个简答题" class="headerlink" title="四个简答题"></a>四个简答题</h2><p>分值：5分一个</p>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><blockquote>
<ul>
<li>各种调度算法是什么样的。各种调度算法有什么特点，还存在什么问题？</li>
<li>多级反馈队列为什么常用，彩票调度算法和步长调度算法等公平份额算法为什么不行？</li>
</ul>
</blockquote>
<h4 id="各种调度算法的特点和优缺点"><a href="#各种调度算法的特点和优缺点" class="headerlink" title="各种调度算法的特点和优缺点"></a>各种调度算法的特点和优缺点</h4><h5 id="先进先出-FIFO"><a href="#先进先出-FIFO" class="headerlink" title="先进先出(FIFO)"></a>先进先出(FIFO)</h5><ul>
<li>先进先出（First In First Out，FIFO），或者又叫做先到先服务（First Come First Served，FCFS）</li>
</ul>
<p><img src="/2022/06/14/OS%E6%9C%9F%E6%9C%AB%E9%93%A7%E9%94%BA%E7%A2%98/image-20220614133547462.png" alt="image-20220614133547462" style="zoom:80%;"></p>
<ul>
<li>优点：简单，易于实现（最符合直觉的策略）</li>
<li>存在问题：<ul>
<li>存在护航效应（一些耗时较少的潜在资源消费 者被排在重量级的资源消费者之后）。简而言之就是：先到达的长进程让后到达的短进程饿死。</li>
<li>周转时间和响应时间都是糟糕的。</li>
</ul>
</li>
</ul>
<h5 id="最短任务-作业-优先-SJF"><a href="#最短任务-作业-优先-SJF" class="headerlink" title="最短任务(作业)优先(SJF)"></a>最短任务(作业)优先(SJF)</h5><ul>
<li>最短任务优先（First Job First，SJF）：先运行最短的任务，然后是次短的任务，如此下去。</li>
</ul>
<p><img src="/2022/06/14/OS%E6%9C%9F%E6%9C%AB%E9%93%A7%E9%94%BA%E7%A2%98/image-20220614133837340.png" alt="image-20220614133837340" style="zoom:80%;"></p>
<ul>
<li>特点：<ul>
<li>SJF在所有作业同时到达的情况下是最优（optmial，opt）调度算法。</li>
<li>它是非抢占式的，如果长任务比短任务先到达，还是会有护航效应。</li>
</ul>
</li>
<li>优点：<ul>
<li>周转时间很好</li>
</ul>
</li>
<li>缺点：<ul>
<li>响应时间不好</li>
</ul>
</li>
</ul>
<h5 id="最短完成时间优先-STCF"><a href="#最短完成时间优先-STCF" class="headerlink" title="最短完成时间优先(STCF)"></a>最短完成时间优先(STCF)</h5><ul>
<li>向SJF添加抢占，就是最短完成时间优先（Shortest Time-to-Completion First，STCF）或者称作抢占式最短作业优先（Preemptive Shortest Job）调度程序</li>
</ul>
<p><img src="/2022/06/14/OS%E6%9C%9F%E6%9C%AB%E9%93%A7%E9%94%BA%E7%A2%98/image-20220614135705282.png" alt="image-20220614135705282" style="zoom:80%;"></p>
<ul>
<li>特点：<ul>
<li>STCF在作业不同时到达的情况下延续了SJF的最优性</li>
<li>它是抢占式的，如果长任务先到达，短任务后到达，短任务会抢占CPU先执行。</li>
</ul>
</li>
<li>优点：<ul>
<li>周转时间很好</li>
</ul>
</li>
<li>缺点：<ul>
<li>响应时间不好</li>
</ul>
</li>
</ul>
<h5 id="轮转"><a href="#轮转" class="headerlink" title="轮转"></a>轮转</h5><ul>
<li>轮转（Round-Robin，RR），又称作时间切片（time-slicing）：RR在一个时间片（time slice，有时称为调度量子，scheduling quantum）内工作，然后切换到运行队列的下一个任务，而不是运行一个任务直到结束。它反复运行，直到所有任务完成。</li>
</ul>
<p><img src="/2022/06/14/OS%E6%9C%9F%E6%9C%AB%E9%93%A7%E9%94%BA%E7%A2%98/image-20220614140940324.png" alt="image-20220614140940324" style="zoom:80%;"></p>
<ul>
<li>时间片长度影响性能：越短，响应时间越好；太短，频繁切换上下文影响整体性能。</li>
<li>特点：是一种公平调度算法</li>
<li>优点：<ul>
<li>响应时间好</li>
</ul>
</li>
<li>缺点：<ul>
<li>周转时间差</li>
</ul>
</li>
<li>进一步优化：重叠RR，考虑了IO，需要IO的任务让出CPU在完成前不参与调度。</li>
</ul>
<h5 id="多级反馈队列-MLFQ"><a href="#多级反馈队列-MLFQ" class="headerlink" title="多级反馈队列(MLFQ)"></a>多级反馈队列(MLFQ)</h5><ul>
<li><strong>规则</strong>：期中考过了，我觉得不会再考，但是仍然很重要。<ul>
<li>规则1：如果A的优先级&gt;B的优先级，运行A（不运行B）。</li>
<li>规则2：如果A的优先级=B的优先级，轮转运行A和B。</li>
<li>规则3：工作进入系统时，放在最高优先级（最上层队列）。</li>
<li>规则4：一旦工作用完了在某一层中的时间配额（无论中间主动放弃多少次CPU），就降低优先级（移入低一级队列）。</li>
<li>规则5：经过一段时间S，就将系统中所有工作重新加入最高优先级队列。</li>
</ul>
</li>
<li>特点：<ul>
<li>在没有任务长短的先验知识情况下，同时优化了周转时间和响应时间。</li>
<li>采用多级队列，每个队列代表一个优先级。</li>
</ul>
</li>
<li>优点：<ul>
<li>对于短时间运行的交互型工作，获得类似SJF/STCF的很好的全局性能（周转时间）。</li>
<li>同时对长时间运行的CPU密集型负载也可以公平地运行（响应时间）。</li>
</ul>
</li>
</ul>
<h5 id="彩票调度-Lottery"><a href="#彩票调度-Lottery" class="headerlink" title="彩票调度(Lottery)"></a>彩票调度(Lottery)</h5><ul>
<li>给每个进程分发⼀定量的彩票，每次调 度时随机抽出⼀个号码，被抽中的进程获得CPU。</li>
<li>彩票数（tickets）代表了进程占有某个资源地份额。一个进程拥有的彩票占总数地百分比，就是占有资源的份额。</li>
</ul>
<p><img src="/2022/06/14/OS%E6%9C%9F%E6%9C%AB%E9%93%A7%E9%94%BA%E7%A2%98/image-20220614142733606.png" alt="image-20220614142733606" style="zoom:80%;"></p>
<ul>
<li>特点：<ul>
<li>充分利用了随机性</li>
<li>从概率上满足期望的比例，但不能确保。运行时间越长，得到的CPU时间比例越接近期望。</li>
</ul>
</li>
<li>优点：<ul>
<li>可以避免奇怪的边角情况。</li>
<li>很轻量，几乎不需要记录任何状态</li>
<li>随机方法很快</li>
</ul>
</li>
<li>缺点：<ul>
<li>工作时间很短的时，平均不公平度很差。只有运行很多时间片时，才得到期望结果。</li>
</ul>
</li>
</ul>
<h5 id="步长调度算法-Stride"><a href="#步长调度算法-Stride" class="headerlink" title="步长调度算法(Stride)"></a>步长调度算法(Stride)</h5><ul>
<li>给每个进程分发⼀定量的彩票，用一个大数除以彩票得到步长，程序被调度⼀次则累计⼀次行程值（pass值 += 步长），每次调度行程值最小的进程。</li>
</ul>
<p><img src="/2022/06/14/OS%E6%9C%9F%E6%9C%AB%E9%93%A7%E9%94%BA%E7%A2%98/image-20220614144327579.png" alt="image-20220614144327579" style="zoom:80%;"></p>
<ul>
<li>优点：在给定优先级的情况下，达到绝对公平，比彩票调度优化了确定性。</li>
<li>缺点：需要一个全局状态(pass值)</li>
</ul>
<h4 id="为什么MLFQ可用，彩票步长不用"><a href="#为什么MLFQ可用，彩票步长不用" class="headerlink" title="为什么MLFQ可用，彩票步长不用"></a>为什么MLFQ可用，彩票步长不用</h4><ul>
<li><p>MLFQ可用的原因就是它的优点：</p>
<ul>
<li>对于短时间运行的交互型工作，获得类似SJF/STCF的很好的全局性能（周转时间）。</li>
<li>同时对长时间运行的CPU密集型负载也可以公平地运行。</li>
</ul>
</li>
<li><p>彩票步长不广泛使用的原因：</p>
<ul>
<li>一个原因是这两种方式都不能很好地适合I/O；</li>
<li>另一个原因是其中最难的票数分配问题并没有确定的解决方式。</li>
</ul>
</li>
</ul>
<h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><blockquote>
<ul>
<li>虚拟内存空间是什么？</li>
<li>为什么需要虚拟内存空间而不是直接使用物理内存空间？</li>
<li>使用虚拟内存空间的目标或者说是指标是什么？</li>
</ul>
</blockquote>
<h4 id="什么时虚拟内存空间？"><a href="#什么时虚拟内存空间？" class="headerlink" title="什么时虚拟内存空间？"></a>什么时虚拟内存空间？</h4><p>虚拟内存是计算机系统<strong>内存管理的一种技术</strong>。它负责为程序提供一 个巨大的、稀疏的、私有的地址空间的假象，其中保存了程序的所有指令和数据。而实际上，它通常是被分隔成多个物理内存片段，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。</p>
<h4 id="为什么需要虚拟内存空间？"><a href="#为什么需要虚拟内存空间？" class="headerlink" title="为什么需要虚拟内存空间？"></a>为什么需要虚拟内存空间？</h4><p>主要是虚拟内存提供了三个主要的好处：易于使用，高性能，可靠。</p>
<ul>
<li>虚拟内存可以为进程提供独立的内存空间并引入多层的页表结构将虚拟内存翻译成物理内存，进程之间可以共享物理内存减少开销，也能简化程序的链接、装载以及内存分配过程；</li>
<li>虚拟内存可以结合磁盘和物理内存的优势为进程提供看起来速度足够快并且容量足够大的存储；</li>
<li>虚拟内存可以控制进程对物理内存的访问，隔离不同进程的访问权限，提高系统的安全性；</li>
</ul>
<h4 id="虚拟内存的目标（指标）"><a href="#虚拟内存的目标（指标）" class="headerlink" title="虚拟内存的目标（指标）"></a>虚拟内存的目标（指标）</h4><p><img src="/2022/06/14/OS%E6%9C%9F%E6%9C%AB%E9%93%A7%E9%94%BA%E7%A2%98/image-20220615010114930.png" alt="image-20220615010114930" style="zoom:80%;"></p>
<p><img src="/2022/06/14/OS%E6%9C%9F%E6%9C%AB%E9%93%A7%E9%94%BA%E7%A2%98/image-20220615010135694.png" alt="image-20220615010135694" style="zoom:80%;"></p>
<h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><blockquote>
<ul>
<li>什么是并发？并发的概念是什么？</li>
<li>竞态条件、临界区等概念</li>
</ul>
</blockquote>
<h4 id="什么是并发"><a href="#什么是并发" class="headerlink" title="什么是并发"></a>什么是并发</h4><p><strong>并发</strong>当有多个线程在操作时,如果系统只有一个CPU,则它不可能真正同时进行一个以上的线程，它只能把CPU运行时间划分成若干个时间段,再将时间段分配给各个线程执行，在一个时间段的线程代码运行时，其它线程处于挂起状。这种方式我们称之为并发。</p>
<h4 id="什么是临界区、竞态条件等"><a href="#什么是临界区、竞态条件等" class="headerlink" title="什么是临界区、竞态条件等"></a>什么是临界区、竞态条件等</h4><p><img src="/2022/06/14/OS%E6%9C%9F%E6%9C%AB%E9%93%A7%E9%94%BA%E7%A2%98/image-20220614155546936.png" alt="image-20220614155546936" style="zoom:80%;"></p>
<h3 id="持久"><a href="#持久" class="headerlink" title="持久"></a>持久</h3><blockquote>
<p>明确为：崩溃一致性</p>
<ul>
<li>什么是崩溃一致性</li>
<li>崩溃一致性存在什么例子</li>
</ul>
</blockquote>
<h4 id="什么是崩溃一致性问题"><a href="#什么是崩溃一致性问题" class="headerlink" title="什么是崩溃一致性问题"></a>什么是崩溃一致性问题</h4><p>文件系统如何在出现断电（power loss）或系统崩溃（system  crash）的情况下，更新持久数据结构。这称为崩溃一致性问题。</p>
<h4 id="存在什么例子"><a href="#存在什么例子" class="headerlink" title="存在什么例子"></a>存在什么例子</h4><ul>
<li><strong>课本42.1</strong></li>
</ul>
<p>简单描述就是：</p>
<p><img src="/2022/06/14/OS%E6%9C%9F%E6%9C%AB%E9%93%A7%E9%94%BA%E7%A2%98/image-20220615161654399.png" alt="image-20220615161654399"></p>
<p>考虑一种情况是将单个数据块附加到原有文件末尾。则这个过程文件需要更新的有：数据位图增加一个表示数据块有效的位；更新<code>inode</code>中的数据块指针等；更新数据块Db。</p>
<p>现在我们考虑6种不一致现象：</p>
<ul>
<li><strong>只更新了数据块。</strong>此时，该文件的<code>inode</code>中没有指向Db的指针。Db的写入相当于无效。</li>
<li><strong>只更新了<code>inode</code>。</strong>此时，数据块没有更新，导致读取这个块返回给用户垃圾数据。同时出现文件系统不一致，数据位图告诉我们Db这个块未分配，但是<code>inode</code>认为它分配了。</li>
<li><strong>只更新了数据位图。</strong>此时，同样出现文件系统不一致，数据位图认为Db这个块分配了，但是<code>inode</code>没有指向它。如果不解决，会造成空间泄露。</li>
<li><strong>只更新了<code>inode</code>和数据位图。</strong>此时文件系统的元数据是一致的。但是数据没有更新，造成了垃圾数据。</li>
<li><strong>只更新了<code>inode</code>和数据块。</strong><code>inode</code>能够指向正确的数据块。但是又出现了文件系统给元数据不一致（<code>inode</code>和位图）。</li>
<li><strong>只更新了数据位图和数据块。</strong><code>inode</code>和位图的不一致性问题。没有<code>inode</code>指向这个块。</li>
</ul>
<h2 id="五个计算题加分析题"><a href="#五个计算题加分析题" class="headerlink" title="五个计算题加分析题"></a>五个计算题加分析题</h2><p>共计80分，其中由于计科期中考试进程考的比较多，进程部分的分值会少一点</p>
<p>五个答题主要是1+2+1+1：进程一个，虚拟内存两个，并发一个，文件部分一个</p>
<h3 id="进程x1"><a href="#进程x1" class="headerlink" title="进程x1"></a>进程x1</h3><p>没给提示。有可能是fork和exec相关的。</p>
<ul>
<li>（12 分）描述进程与线程以及它们之间的区别和联系。分析给出下图代码（图 5-1）在控 制台可能输出的信息；代码（图 5-2）可能会创建多少个进程，多少个线程。（答案5，2）</li>
</ul>
<p><img src="/2022/06/14/OS%E6%9C%9F%E6%9C%AB%E9%93%A7%E9%94%BA%E7%A2%98/image-20220615163218702.png" alt="image-20220615163218702" style="zoom:80%;"></p>
<p><img src="/2022/06/14/OS%E6%9C%9F%E6%9C%AB%E9%93%A7%E9%94%BA%E7%A2%98/image-20220615163231423.png" alt="image-20220615163231423"></p>
<p><img src="/2022/06/14/OS%E6%9C%9F%E6%9C%AB%E9%93%A7%E9%94%BA%E7%A2%98/ML4YT3TK5Z~_Y1D9DP`M4FP.png" alt="img"></p>
<h3 id="虚拟内存x2"><a href="#虚拟内存x2" class="headerlink" title="虚拟内存x2"></a>虚拟内存x2</h3><p>有两个题，由于现代操作系统普遍使用分页管理机制，而不是分段管理机制，所以着重在分页上（自己体会这句话）。而且他不怎么说分段，所以肯定考分页。</p>
<blockquote>
<ul>
<li>首先要搞懂最简单的线性页表，它有什么缺陷？</li>
<li>页表使得访存需要增加额外的访问页表的成本，所以很慢。为此有了TLB加速缓存。TLB是怎么工作的。</li>
<li>线性页表（一级）存储太大，所以有了多级页表。搞清楚怎么做的特别是二级三级页表。（我觉得是三级页表，老师提到了两三次）</li>
<li>在页表中除了物理页号，还有一些其他的属性位，都有些什么，它们代表什么含义？（例如有效位、存在位等）</li>
<li>通过上面的页表机制，给定一个虚拟地址，怎么计算它的物理地址？</li>
<li>超越物理内存（置换策略）</li>
</ul>
</blockquote>
<ul>
<li><p>线性页表（linear page table），就是一个数组。操作系统通过虚拟页号（VPN）检索该数组，并在该索引处查找页表项（PTE），以便找到期望的物理帧号（PFN）。</p>
</li>
<li><p>线性页表存在的问题就是太慢和太大</p>
<ul>
<li>对应的解决办法就是TLB和分级页表</li>
</ul>
</li>
<li><p>TLB和多级页表很重要，但是请见书本。</p>
</li>
<li><p>一些属性位：</p>
<p><img src="/2022/06/14/OS%E6%9C%9F%E6%9C%AB%E9%93%A7%E9%94%BA%E7%A2%98/image-20220614162257586.png" alt="image-20220614162257586" style="zoom:80%;"></p>
<p>上图包含一个存在位（P），确定是否允 许写入该页面的读/写位（R/W） 确定用户模式进程是否可以访问该页面的用户/超级用户位 （U/S），有几位（PWT、PCD、PAT 和 G）确定硬件缓存如何为这些页面工作，一个访问位 （A）和一个脏位（D），最后是页帧号（PFN）本身。</p>
<ul>
<li>有效位(V)：用于指定特定的地址转换是否有效</li>
<li>保护位(R/W)：表明页是否可以读取、写入或执行</li>
<li>存在位(P)：表示该页是在物理存储器上还是在磁盘交换区上</li>
<li>参考位(A)：又称访问位，用于追踪页是否被访问，也用于确定哪些页很受欢迎，应该保留在内存中。</li>
<li>脏位(D)：标示该页是否被写过</li>
</ul>
</li>
<li><p>怎么用页表进行地址转换请看书</p>
<ul>
<li>不难，就是查表</li>
<li>需要注意，物理页（帧）号拼上页偏移才是物理地址。</li>
</ul>
</li>
<li><p>超越物理内存（置换策略）</p>
<ul>
<li><p>平均内存访问时间（Average  Memory Access Time，AMAT）</p>
<script type="math/tex; mode=display">
AMAT = (P_{Hit}·T_M) + (P_{Miss}·T_D)</script></li>
<li><p>最优策略是MIN（无法实现，作为策略追求的性能上界）</p>
</li>
<li><p>简单策略FIFO</p>
<p><img src="/2022/06/14/OS%E6%9C%9F%E6%9C%AB%E9%93%A7%E9%94%BA%E7%A2%98/image-20220614163007021.png" alt="image-20220614163007021" style="zoom: 80%;"></p>
</li>
<li><p>随机策略</p>
<p><img src="/2022/06/14/OS%E6%9C%9F%E6%9C%AB%E9%93%A7%E9%94%BA%E7%A2%98/image-20220614163049148.png" alt="image-20220614163049148" style="zoom: 80%;"></p>
</li>
<li><p>最近最少使用（Least-Recently-Used，LRU）</p>
<p><img src="/2022/06/14/OS%E6%9C%9F%E6%9C%AB%E9%93%A7%E9%94%BA%E7%A2%98/image-20220614163141209.png" alt="image-20220614163141209" style="zoom: 80%;"></p>
</li>
<li><p>最不经常使用”（Least-Frequently-Used， LFU）（历史信息中使用频次最低的）</p>
</li>
</ul>
</li>
<li><p><img src="/2022/06/14/OS%E6%9C%9F%E6%9C%AB%E9%93%A7%E9%94%BA%E7%A2%98/image-20220615021516526.png" alt="image-20220615021516526"></p>
<ul>
<li>基本思想：<ul>
<li>分段是指将虚拟地址空间中代码、堆、栈等段分别映射到物理内存，而不是将整 个虚拟地址空间全部映射到物理内存。</li>
<li>分页是将虚拟地址空间等分为固定大小的页 （如 4KB），以页的方式将虚拟地址空间与物理内存进行映射。</li>
</ul>
</li>
<li>地址转换过程：<ul>
<li>分段主要是把不同的段，借助两个寄存器（基址寄存器和界限寄存器），其中物理地址等同于基址寄存器中存储的段机制加上段内偏移。界限寄存器主要实现了段的保护功能。</li>
<li>页的地址转换是将虚拟地址分成虚拟页号部分和页偏移部分。虚拟页号通过页表存储的物理帧号实现虚拟页号到物理页号的映射。由于偏移不变，所以把得到的物理页号拼上偏移就是物理地址。</li>
</ul>
</li>
<li>优缺点：<ul>
<li>分段的优点是硬件支 持比较简单；缺点是可能会导致外部碎片、空闲空间的管理比较复杂。</li>
<li>分页的优点是 空间管理简单、没有外部碎片，缺点是页表存储空间大、地址翻译慢（需要 TLB 加 速），因此需要硬件的支持较多。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="并发x1"><a href="#并发x1" class="headerlink" title="并发x1"></a>并发x1</h3><p>由于并发的计算分析大题只考一个，而且老师又提示说会考一提编程相关的代码题，要会用函数，会用接口。肯定就是这题。</p>
<blockquote>
<p>用信号量解决理发师问题。如果有余力也可以看看信号量解决吸烟者问题。我觉得就是理发师</p>
</blockquote>
<p>类似这个历年真题。把打印员换成理发师，就是经典的理发师问题。</p>
<p><img src="C:/Users/18319/AppData/Roaming/Typora/typora-user-images/image-20220615151151214.png" alt="image-20220615151151214"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NUM_CHAIR 5					<span class="comment">// 最大等待椅子数目</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUM_CUST  10				<span class="comment">// 顾客数量</span></span></span><br><span class="line"><span class="type">sem_t</span> customers;         			<span class="comment">// 表示有顾客的条件变量</span></span><br><span class="line"><span class="type">sem_t</span> barber;    	     			<span class="comment">// 表示理发师醒了的条件变量</span></span><br><span class="line"><span class="type">sem_t</span> mutex;              			<span class="comment">// 空闲椅子数是共享资源，需要互斥量</span></span><br><span class="line"><span class="type">int</span> freechairs;      				<span class="comment">// 空椅子的数量</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> * <span class="title function_">Barber</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (ture) &#123;	     			<span class="comment">// 理发师持续不断工作或者睡眠</span></span><br><span class="line">        sem_wait(&amp;customers);		<span class="comment">// 试图为一个顾客理发，如果没有顾客就睡着</span></span><br><span class="line">        sem_wait(&amp;mutex);			<span class="comment">// 需要修改空椅子的数量(全局变量)，需要上锁</span></span><br><span class="line">        freechair++;			    <span class="comment">// 为一个顾客理发，顾客起身，空一张椅子出来</span></span><br><span class="line">        sem_post(&amp;barber);			<span class="comment">// 此时理发师可以工作，通知顾客过来理发</span></span><br><span class="line">        sem_post(&amp;mutex);			<span class="comment">// 修改完空椅子数目，释放锁</span></span><br><span class="line">        <span class="comment">/* 理发师在理发... */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> * <span class="title function_">Customers</span><span class="params">()</span> &#123; 	 			<span class="comment">// 一个线程仅仅表示一名顾客</span></span><br><span class="line">    sem_wait(&amp;mutex);    		 	<span class="comment">// 想要坐到一张椅子上等待</span></span><br><span class="line">    <span class="keyword">if</span> (freechairs &gt; <span class="number">0</span>) &#123;			<span class="comment">// 如果还有空椅子的话</span></span><br><span class="line">        freechairs--;				<span class="comment">// 顾客坐到一张椅子上等待</span></span><br><span class="line">        sem_post(&amp;customers);		<span class="comment">// 唤醒理发师，有顾客来了</span></span><br><span class="line">        sem_post(&amp;mutex);			<span class="comment">// 顾客已经坐到椅子上等待，释放互斥量</span></span><br><span class="line">        sem_wait(&amp;barber);			<span class="comment">// 如果理发师还在忙，就等他</span></span><br><span class="line">        <span class="comment">/* 抢到理发师，此时顾客开始理发 */</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;							<span class="comment">// 没有空着的椅子 </span></span><br><span class="line">        sem_post(&amp;mutex);			<span class="comment">// 不要忘记试图坐下上的锁(第20行)</span></span><br><span class="line">        <span class="comment">/* 没有椅子坐，直接走了 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">/* 初始化 */</span></span><br><span class="line">    sem_init(&amp;customers, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    sem_init(&amp;barbers, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    sem_init(&amp;mutex, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    freechairs = NUM_CHAIR;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 启动理发师和顾客 */</span></span><br><span class="line">    <span class="type">pthread_t</span> bar, cust[NUM_CUST];</span><br><span class="line">    Pthread_create(&amp;bar, <span class="literal">NULL</span>, Barber, <span class="literal">NULL</span>);	  	</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_CUST; i++) &#123;</span><br><span class="line">        Pthread_create(&amp;cust[i], <span class="literal">NULL</span>, Customers, <span class="literal">NULL</span>);</span><br><span class="line">        sleep(randint(<span class="literal">NULL</span>));	  <span class="comment">// 每隔一个随机时间来一个顾客</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="补充之吸烟者问题"><a href="#补充之吸烟者问题" class="headerlink" title="补充之吸烟者问题"></a>补充之吸烟者问题</h4><p>这里只用到了信号量，因为座子上的资源只够一个人吸烟，不会有共享</p>
<p><img src="/2022/06/14/OS%E6%9C%9F%E6%9C%AB%E9%93%A7%E9%94%BA%E7%A2%98/cf90bb5e99024c04b9cdab2779822591.jpg" alt="在这里插入图片描述"></p>
<p><img src="/2022/06/14/OS%E6%9C%9F%E6%9C%AB%E9%93%A7%E9%94%BA%E7%A2%98/71681ce2b6b14269a5d98021c97ee207.jpg" alt="在这里插入图片描述"></p>
<p><img src="/2022/06/14/OS%E6%9C%9F%E6%9C%AB%E9%93%A7%E9%94%BA%E7%A2%98/b41906fd38354d9db406f11b5fdb6635.jpg" alt="在这里插入图片描述"></p>
<h3 id="文件x1"><a href="#文件x1" class="headerlink" title="文件x1"></a>文件x1</h3><blockquote>
<ul>
<li>存储管理<ul>
<li>磁盘结构是什么样的？旋转寻道传输以及这方面的知识以及有关的时间是怎么算的？</li>
<li>RAID（0/1/4/5）各自有什么特点和优缺点，稳态吞吐量怎么算的</li>
</ul>
</li>
<li>文件系统<ul>
<li>数据进行读写，要经历什么样的步骤</li>
<li>元数据的成员有哪些：修改时间、…、直接指针、间接指针<ul>
<li>放在一个应用场景中让你进行设计（大概率是设计分配直接指针和间接指针[二级、三级]）</li>
<li>对应消耗多少空间，对应的数据块又有多大？</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="磁盘结构"><a href="#磁盘结构" class="headerlink" title="磁盘结构"></a>磁盘结构</h4><p><img src="/2022/06/14/OS%E6%9C%9F%E6%9C%AB%E9%93%A7%E9%94%BA%E7%A2%98/image-20220614164632169.png" alt="image-20220614164632169" style="zoom: 80%;"></p>
<script type="math/tex; mode=display">
T_{I/O} = T_{寻道} + T_{旋转} + T_{传输}</script><script type="math/tex; mode=display">
R_{I/O} = \frac{传输大小}{T_{I/O}}</script><p><img src="/2022/06/14/OS%E6%9C%9F%E6%9C%AB%E9%93%A7%E9%94%BA%E7%A2%98/image-20220615015619442.png" alt="image-20220615015619442" style="zoom:80%;"></p>
<h4 id="各种时间怎么算"><a href="#各种时间怎么算" class="headerlink" title="各种时间怎么算"></a>各种时间怎么算</h4><p>有两个真题,可以理解一下</p>
<ul>
<li>真题1</li>
</ul>
<p><img src="/2022/06/14/OS%E6%9C%9F%E6%9C%AB%E9%93%A7%E9%94%BA%E7%A2%98/image-20220615171059400.png" alt="image-20220615171059400"></p>
<p><img src="/2022/06/14/OS%E6%9C%9F%E6%9C%AB%E9%93%A7%E9%94%BA%E7%A2%98/image-20220615171145581.png" alt="image-20220615171145581"></p>
<ul>
<li>真题2:</li>
</ul>
<p><img src="/2022/06/14/OS%E6%9C%9F%E6%9C%AB%E9%93%A7%E9%94%BA%E7%A2%98/image-20220615171003028.png" alt="image-20220615171003028"></p>
<p><img src="/2022/06/14/OS%E6%9C%9F%E6%9C%AB%E9%93%A7%E9%94%BA%E7%A2%98/image-20220615170926641.png" alt="image-20220615170926641"></p>
<h4 id="RAID各级的优缺点以及特点"><a href="#RAID各级的优缺点以及特点" class="headerlink" title="RAID各级的优缺点以及特点"></a>RAID各级的优缺点以及特点</h4><ul>
<li><p><strong>【RAID 0——RAID中速度最快】</strong></p>
<p><strong>原理：</strong>采用数据条带技术（Striping），将数据分成“块”保存在不同磁盘上，读写时以并行的方式对各磁盘同时进行操作。</p>
<p><strong>优点：</strong>组建低成本，且具有传输速度快、存储空间利用率高等优点；</p>
<p><strong>缺点：</strong>不提供数据冗余保护，任何一块硬盘发生损坏，则所有的数据将不可恢复；</p>
</li>
<li><p><strong>【RAID 1——RAID中安全性最高】</strong></p>
<p><strong>原理：</strong>俗称“磁盘镜像”，将数据完全一致地分别写到工作磁盘和镜像磁盘，一旦工作磁盘发生故障，系统自动从镜像磁盘读取数据，不会影响用户工作。</p>
<p><strong>优点：</strong>磁盘数据呈现完全镜像，具有安全性好、技术简单、管理方便等优点；</p>
<p><strong>缺点：</strong>实现成本高，磁盘空间利用率仅 50%；</p>
</li>
<li><p><strong>【RAID 4——条带分布+专用盘校验】</strong></p>
<p><strong>原理：</strong>其中一块硬盘上存储校验数据，当某块硬盘出现故障时，其它硬盘可以通过校验数据将有故障的硬盘的数据重新恢复出来。</p>
<p><strong>优点：</strong>1、磁盘利用率较高(N-1)；2、并行I/O传输，顺序读性能较高</p>
<p><strong>缺点：</strong>1、专用校验盘成为性能瓶颈；2、每次读写牵动整个组，每次只能完成一次I/O 传输</p>
</li>
<li><p><strong>【RAID 5——RAID中综合性能最佳】</strong></p>
<p><strong>原理：</strong>采用校验码冗余数据，校验块旋转地分布在多个磁盘上，当某个磁盘出现故障，可以使用其他磁盘上校验信息来恢复数据。</p>
<p><strong>优点：</strong>兼顾存储性能、数据安全和存储成本等；</p>
<p><strong>缺点：</strong>1、写入性能相对低；2、重建数据时，性能会受到较大的影响；</p>
</li>
</ul>
<h4 id="文件系统相关"><a href="#文件系统相关" class="headerlink" title="文件系统相关"></a>文件系统相关</h4><ul>
<li>真题:</li>
</ul>
<p>文件系统的实现需要考虑元数据（metadata）的处理，请回答跟元数据相关的下列问题：</p>
<p>（1）文件系统中的<code>inode</code>的作用是什么？<code>inode</code>中一般包含哪些信息？（4分）</p>
<p>（2）为了描述文件的大小，需要在元数据中给定指向数据的指针，指针一般分为直接指针（direct pointer）和间接指针（indirect pointer），假设数据块的大小为4KB，每个指针占用4字节的空间，那么10个直接指针和1个一级间接指针可以寻址的文件大小是多少？1个二级间接指针可以寻址的文件大小是多少？请给出分析和计算过程。（8分）</p>
<p><img src="/2022/06/14/OS%E6%9C%9F%E6%9C%AB%E9%93%A7%E9%94%BA%E7%A2%98/image-20220615145705046.png" alt="image-20220615145705046" style="zoom:80%;"></p>
<ul>
<li><p>直接指针间接指针的好坏(来不及了…略)</p>
<ul>
<li>主要就是直接指针数目多,索引快,但是指向的数据块小</li>
<li>间接指针需要额外的索引时间,但是数目少,指向的块的总大小很大</li>
</ul>
<p><img src="/2022/06/14/OS%E6%9C%9F%E6%9C%AB%E9%93%A7%E9%94%BA%E7%A2%98/image-20220615175410707.png" alt="image-20220615175410707" style="zoom:80%;"></p>
</li>
</ul>
<h4 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h4><p>日志记一下这五点吧,估计最多考这样</p>
<p><img src="/2022/06/14/OS%E6%9C%9F%E6%9C%AB%E9%93%A7%E9%94%BA%E7%A2%98/image-20220615175448501.png" alt="image-20220615175448501"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://puitar.github.io/2022/05/26/CSAPP-shlab-report/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Puitar">
      <meta itemprop="description" content="博客萌新时不时送来没什么软用的文章">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Puitar's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/26/CSAPP-shlab-report/" class="post-title-link" itemprop="url">CSAPP:shlab-report</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-05-26 23:31:03" itemprop="dateCreated datePublished" datetime="2022-05-26T23:31:03+08:00">2022-05-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-07-14 15:12:17" itemprop="dateModified" datetime="2022-07-14T15:12:17+08:00">2022-07-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/courses-learning/" itemprop="url" rel="index"><span itemprop="name">courses-learning</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/courses-learning/%E5%A4%A7%E4%BA%8C%E4%B8%8B%E6%9C%9F%E6%9C%AB/" itemprop="url" rel="index"><span itemprop="name">大二下期末</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="CSAPP-LAB4-SHELL-LAB-REPORT"><a href="#CSAPP-LAB4-SHELL-LAB-REPORT" class="headerlink" title="CSAPP-LAB4-SHELL-LAB-REPORT"></a>CSAPP-LAB4-SHELL-LAB-REPORT</h1><p>计科2002班</p>
<p>202001130329</p>
<p>杨铭</p>
<h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><p>通过这个实验能够更加深刻理解进程控制和信号控制的相关概念。本次实验我们要写一个自己的类linux/unix的shell程序，它能够支持工作的控制。</p>
<h2 id="实验平台准备"><a href="#实验平台准备" class="headerlink" title="实验平台准备"></a>实验平台准备</h2><ul>
<li>Ubuntu-32 VMfare虚拟机</li>
<li>typora编写实验报告(经授课老师许可)</li>
</ul>
<h2 id="Hand-Out-介绍"><a href="#Hand-Out-介绍" class="headerlink" title="Hand Out 介绍"></a>Hand Out 介绍</h2><p>首先解压实验文件，然后做如下工作：</p>
<ul>
<li>使用命令<code>tar xvf shlab-handout.tar</code>解压文件</li>
<li>使用命令<code>make</code>来编译和链接测试程序</li>
<li>输入(你的队员)没有队员，把你的大名写在<code>tsh.c</code>程序的顶部注释中</li>
</ul>
<p>注意到你的<code>tsh.c</code>(<em>tiny shell</em>)文件，你会看到它包含了一个简单Unix的shell的函数框架。为了简化实验，实际上题目已经帮我们实现了一些没那么有趣的函数。我们的任务就是完成剩下的空的函数。</p>
<p><strong>需要实现</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>目标函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>eval</td>
<td>主例程，用以分析和解释命令行（原型在课本8.4节）</td>
</tr>
<tr>
<td>builtin_cmd</td>
<td>执行bg和fg内置命令</td>
</tr>
<tr>
<td>waitfg</td>
<td>等待前台作业执行</td>
</tr>
<tr>
<td>sigchld_handler</td>
<td>响应处理SIGCHILD信号</td>
</tr>
<tr>
<td>sigint_handler</td>
<td>响应处理SIGINT（ctrl-c）信号</td>
</tr>
<tr>
<td>sigtstp_handler</td>
<td>响应处理SIGTP（ctrl-z）信号</td>
</tr>
</tbody>
</table>
</div>
<p>每一次修改<code>tsh.c</code>，都需要输入<code>make</code>来重编译它。运行你的<em>shell</em>，在命令行输入<code>tsh</code>如下</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unix&gt; ./tsh</span><br><span class="line">tsh&gt; [<span class="built_in">type</span> commands to your shell here]</span><br></pre></td></tr></table></figure>
<h2 id="普通的Unix-Shells概述"><a href="#普通的Unix-Shells概述" class="headerlink" title="普通的Unix Shells概述"></a>普通的Unix Shells概述</h2><p>一个<em>shell</em>是一个对于用户层面的交互程序，它能够对用户输入的命令行进行解析。一个<em>shell</em>通常会重复输出一个标识符（通常是’prompt‘），然后等待一个命令行输入或者<code>stdin</code>标准输入。一旦它取得了命令行之后就会用它的内容进行一系列的解析工作。</p>
<p>命令行是一个有序的ASCII字符序列，它们使用空格相隔。命令行的第一个单词通常是一个<em>shell</em>的内部命令或者一个可执行文件的路径名称。剩下的单词是命令行的参数。如果第一个单词是一个命令行的内部命令，<em>shell</em>会立即在当前进程（也就是<em>shell</em>）立即执行。否则的话，它是一个可执行文件的路径。在这个情况之下<em>shell</em>通过<code>fork</code>一个子进程，然后在子进程的上下文中加载并运行程序。由于解析一个命令行而创建的子进程又被称作是<code>job</code>（作业）。总的来说，一个job是由若干子进程组成的，这些子进程通过Unix管道进行连接。</p>
<p>如果一个命令行以“&amp;”符号结尾，那么这个job就会在<em>background</em>运行该程序。也就是在后台运行这个程序，这意味着<em>shell</em>不会等待这个子进程结束后才打印下一个prompt来解析下一条命令行。因此在任何时候，最多只有一个任务能够在前台运行。然而在后台可以运行任意数目的作业。</p>
<p>例如，输入命令行</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br></pre></td></tr></table></figure>
<p>会导致<em>shell</em>执行一个内置的作业命令。输入命令如下</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsh&gt; /bin/ls -l -d</span><br></pre></td></tr></table></figure>
<p>来在前台运行一个<code>ls</code>程序。按照惯例，<em>shell</em>确保当程序开始执行的时候，它的主例程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br></pre></td></tr></table></figure>
<p>这里的<code>argc</code>和<code>argv</code>拥有了如下值：</p>
<ul>
<li>argc ==  3，</li>
<li>argv[0] == “/bin/ls”,</li>
<li>argv[1] == “-l”,</li>
<li>argv[2] == “-d”.</li>
</ul>
<p>或者另一方面，我们输入命令行如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsh&gt; /bin/ls -l -d &amp;</span><br></pre></td></tr></table></figure>
<p>就会使得<code>ls</code>程序在后台运行。</p>
<p>Unix shells支持<code>job control</code>，它能够允许用户对将作业在前台和后台之间移动，同时也能够改变进程的状态（running, stopped, or terminated）。输入<code>ctrl-c</code>会导致产生一个SIGINT信号，它被发送到前台的每个作业。类似的，如果你输入一个<code>ctrl-z</code>会导致一个SIGTSTP信号产生，并被发送给每一个前台的工作。对于SIGTSTP的默认行为是设置一个进程为stopped状态，它会保持停止状态直到直到它收到SIGCONT信号后才被唤醒。Unix shells同样提供不同的内置命令来支持这种工作的控制。例如</p>
<ul>
<li><code>jobs</code>：列出正在运行的以及停止的的后台作业</li>
<li><code>bg &lt;job&gt;</code>：改变一个停止的后台作业为一个后台运行态作业</li>
<li><code>fg &lt;job&gt;</code>：改变一个停止或运行的后台作业为一个运行的前台作业</li>
<li><code>kill &lt;job&gt;</code>：终止一个作业</li>
</ul>
<h2 id="tsh的特点"><a href="#tsh的特点" class="headerlink" title="tsh的特点"></a>tsh的特点</h2><p>我们的<code>tsh</code>应该具备以下特点</p>
<ul>
<li>标志符prompt应该是字符串“tsh&gt;”</li>
<li>用户输入的字符串应该由一个可执行的程序或者内嵌的指令开头（<code>name</code>），然后紧跟着0个或者更若干个参数。它们由一个或者更更多的空格隔开。如果<code>name</code>是一个内置指令，tsh直接处理执行，然后等待下一条指令。否则<code>tsh</code>就会把这个<code>name</code>当成是一个可执行文件的路径，然后初始化一个子进程，然后在这个子进程的上下文中加载执行这个程序（在这种情况下，我们所说的作业通常指这个子进程）</li>
<li><code>tsh</code>不需要支持管道符（|）或者I/O的重定向（&lt;和&gt;）</li>
<li>输入ctrl-c（ctrl-z）应该导致SIGINT（SIGTSTP）信号产生然后被发送到当前的前台作业那里去，这些信号同样会被发送到这些前台进程的后代进程那里去。（例如它所派生的子进程）。如果没有任何前台进程，那么这个信号将不会有任何的效果</li>
<li>如果这个命令行是以&amp;结尾的，那么<code>tsh</code>应该让这个作业在后台运行。</li>
<li>每一个作业能够唯一的ID（PID）标识或者我们说这是一个作业ID（JID），它是一个<code>tsh</code>所分配的标识符。JIDs应该在命令行上用一个前缀’%‘来表示。例如：“%5”表示的是JID为5。（实验中提供了所有作业列表所需要的例程）</li>
<li><code>tsh</code>应该支持以下内置命令<ul>
<li><code>quit</code>命令用来终止<em>shell</em></li>
<li><code>jobs</code>用来列出所有后台作业</li>
<li><code>bg &lt;job&gt;</code>通过向<code>&lt;job&gt;</code>发送SIGCONT来重启它，然后让它运行在后台中，<code>&lt;job&gt;</code>参数可以用PID或者JID</li>
<li><code>fg &lt;job&gt;</code>命令通过发送SIGCONT信号给进程<code>&lt;job&gt;</code>，然后把它运行在前台中，<code>&lt;job&gt;</code>参数可以用PID或者JID</li>
</ul>
</li>
<li><code>tsh</code>应该回收它的所有僵尸孩子。如果任何作业因为接收到未捕获的信号而终止，则<code>tsh</code>应识别此事件并打印带有作业 PID 的消息和违规信号的描述</li>
</ul>
<h2 id="检查工作的正确性"><a href="#检查工作的正确性" class="headerlink" title="检查工作的正确性"></a>检查工作的正确性</h2><p>实验提供了一些工具来帮助我们检查工作是否正确。</p>
<p><strong>Reference solution.</strong><code>tshref</code>是一个Linux下的可执行文件为我们的<em>shell</em>提供了一个参考解决办法。运行这个程序来解决问题，看看我们的<code>tsh</code>执行的怎么样。你的<em>shell</em>应该提交输出和参考解决办法完全相同。</p>
<p><strong>Shell driver.</strong><code>sdriver.pl</code>程序将我们的<code>tsh</code>作为子进程执行，按照跟踪文件的指令向其发送命令和信号，并捕获显示<em>shell</em>的输出。使用<code>-h</code>。</p>
<p>我们有16个trace文件trace{01-16}.txt，用来和shell driver一起使用，用来测试我们的<em>shell</em>的正确性。那些数字小的trace文件做一些简单的测试，大的数字做的是更加复杂的测试。</p>
<p>可以简单通过</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unix&gt; make test01		<span class="comment">#执行test01</span></span><br><span class="line">unix&gt; make rtest01		<span class="comment">#用reference solution(tshref)执行test01</span></span><br></pre></td></tr></table></figure>
<p>看输出结果是否一致即可。</p>
<h2 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h2><p>为了保证实验的顺利进行，首先阅读课本第八章的内容。</p>
<p>根据实验指导书，这边建议根据trace文件来进行实验，trace给出你要做的事情的提示。</p>
<h3 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * main - The shell&#x27;s main routine </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">char</span> cmdline[MAXLINE];</span><br><span class="line">    <span class="type">int</span> emit_prompt = <span class="number">1</span>; <span class="comment">/* emit prompt (default) */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Redirect stderr to stdout (so that driver will get all output</span></span><br><span class="line"><span class="comment">     * on the pipe connected to stdout) */</span></span><br><span class="line">    dup2(<span class="number">1</span>, <span class="number">2</span>);	<span class="comment">// 把错误信息重定向到标准输出上，也就是输出到屏幕上</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Parse the command line */</span></span><br><span class="line">    <span class="comment">// 处理参数</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * -h 帮助文件</span></span><br><span class="line"><span class="comment">    * -v 发送额外的诊断信息</span></span><br><span class="line"><span class="comment">    * -p 不打印prompt</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">while</span> ((c = getopt(argc, argv, <span class="string">&quot;hvp&quot;</span>)) != EOF) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:             <span class="comment">/* print help message */</span></span><br><span class="line">            usage();</span><br><span class="line">	    <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;v&#x27;</span>:             <span class="comment">/* emit additional diagnostic info */</span></span><br><span class="line">            verbose = <span class="number">1</span>;</span><br><span class="line">	    <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;p&#x27;</span>:             <span class="comment">/* don&#x27;t print a prompt */</span></span><br><span class="line">            emit_prompt = <span class="number">0</span>;  <span class="comment">/* handy for automatic testing */</span></span><br><span class="line">	    <span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">            usage();</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Install the signal handlers */</span></span><br><span class="line">	<span class="comment">// 对各种信号进行处理</span></span><br><span class="line">    <span class="comment">/* These are the ones you will need to implement */</span></span><br><span class="line">    Signal(SIGINT,  sigint_handler);   <span class="comment">/* ctrl-c */</span></span><br><span class="line">    Signal(SIGTSTP, sigtstp_handler);  <span class="comment">/* ctrl-z */</span></span><br><span class="line">    Signal(SIGCHLD, sigchld_handler);  <span class="comment">/* Terminated or stopped child */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This one provides a clean way to kill the shell */</span></span><br><span class="line">    Signal(SIGQUIT, sigquit_handler); </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initialize the job list */</span></span><br><span class="line">    <span class="comment">// 初始化作业列表</span></span><br><span class="line">    initjobs(jobs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Execute the shell&#x27;s read/eval loop */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Read command line */</span></span><br><span class="line">    <span class="comment">// 打印一个prompt符</span></span><br><span class="line">	<span class="keyword">if</span> (emit_prompt) &#123;</span><br><span class="line">	    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, prompt);</span><br><span class="line">	    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 从标准获得命令行</span></span><br><span class="line">	<span class="keyword">if</span> ((fgets(cmdline, MAXLINE, <span class="built_in">stdin</span>) == <span class="literal">NULL</span>) &amp;&amp; ferror(<span class="built_in">stdin</span>))</span><br><span class="line">	    app_error(<span class="string">&quot;fgets error&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// EOF: 当输入ctrl-d的时候表示标准输入(文件)结束，此时直接退出</span></span><br><span class="line">	<span class="keyword">if</span> (feof(<span class="built_in">stdin</span>)) &#123; <span class="comment">/* End of file (ctrl-d) */</span></span><br><span class="line">	    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">	    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Evaluate the command line */</span></span><br><span class="line">	eval(cmdline);		<span class="comment">// 解析命令行</span></span><br><span class="line">	fflush(<span class="built_in">stdout</span>);</span><br><span class="line">	fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">/* control never reaches here */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码我们可以看出，<code>main</code>函数的主要工作就是从标准输出中读出命令行，然后把它交给<code>eval</code>来处理。</p>
<p>参考CSAPP官方网站上给出阉割版本的<em>shell.c</em>，我们可以看到eval主要工作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * eval - evaluate a command line</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">eval</span><span class="params">(<span class="type">char</span> *cmdline)</span> </span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">	<span class="comment">// 通过把argv传递给buildin_command让它判断是不是内置命令并执行</span></span><br><span class="line">    <span class="comment">// 如果不是返回零</span></span><br><span class="line">    <span class="keyword">if</span> (!builtin_command(argv)) &#123; </span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">* buildin_cmd</span></span><br><span class="line"><span class="comment">*/</span>  </span><br><span class="line"><span class="type">int</span> <span class="title function_">builtin_cmd</span><span class="params">(<span class="type">char</span> **argv)</span> </span><br><span class="line">&#123;</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>
<p>我们理清楚主要执行流程如下</p>
<p><img src="/2022/05/26/CSAPP-shlab-report/image-20220525154122346.png" alt="image-20220525154122346"></p>
<h3 id="test01"><a href="#test01" class="headerlink" title="test01"></a>test01</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest01</span><br><span class="line">./sdriver.pl -t trace01.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace01.txt - Properly terminate on EOF.</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure>
<p>我们参考第一个<code>test</code>，对<code>tshref</code>输出了如上结果。这个对于标准输入结束（EOF）的处理。实际上就是对ctrl-d的处理。我们观察到上面<code>main</code>函数中已经有包含对EOF的处理</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// EOF: 当输入ctrl-d的时候表示标准输入(文件)结束，此时直接退出</span></span><br><span class="line">	<span class="keyword">if</span> (feof(<span class="built_in">stdin</span>)) &#123; <span class="comment">/* End of file (ctrl-d) */</span></span><br><span class="line">	    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">	    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>因此我们不许要做什么，可以看到测试结果和参考一致。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make test01</span><br><span class="line">./sdriver.pl -t trace01.txt -s ./tsh -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace01.txt - Properly terminate on EOF.</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure>
<h3 id="test02"><a href="#test02" class="headerlink" title="test02"></a>test02</h3><p>这个一个明显需要做些什么。（不可能又帮你写好）</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest02</span><br><span class="line">./sdriver.pl -t trace02.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace02.txt - Process builtin quit command.</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure>
<p>这个测试要求我们完成对<code>tsh</code>的一条内嵌指令（quit）的处理。它完成的任务就是退出<code>tsh</code>。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ ./tsh</span><br><span class="line">tsh&gt; quit</span><br><span class="line">tsh&gt; </span><br></pre></td></tr></table></figure>
<p>我们可以看到如果什么都不做，是不能够退出的。</p>
<p>现在对这个<code>quit</code>指令的位置有两种思考方向。根据上面<code>main</code>的执行流程，我们说有两个后续处理的方向，一个就是放在eval里面处理，一个就是放在<code>buildin_cmd</code>里面。后者很好理解，这个<code>quit</code>本来就是内嵌指令，所以可以放在后者里面。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">builtin_cmd</span><span class="params">(<span class="type">char</span> **argv)</span>;</span><br></pre></td></tr></table></figure>
<p>可以看到<code>buildin_cmd</code>虽然是对内置指令的处理，这样一条<code>quit</code>非常简单，只要读到这条指令，直接<code>exit(0)</code>，就是它的全部逻辑了。</p>
<p>首先用到<code>parseline</code>来解析命令行，并建立<code>argv</code>，我们可以看到<code>parseline</code>函数的说明如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * parseline - Parse the command line and build the argv array.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Characters enclosed in single quotes are treated as a single</span></span><br><span class="line"><span class="comment"> * argument.  Return true if the user has requested a BG job, false if</span></span><br><span class="line"><span class="comment"> * the user has requested a FG job.  </span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>这个函数主要主要功能就是解析命令行字符串，然后建立<code>argv</code>参数数组，用来给后面execve使用等。</p>
<p>所以代码实现起来就是如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">eval</span><span class="params">(<span class="type">char</span> *cmdline)</span> </span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">// 参数字符串数组</span></span><br><span class="line">	<span class="type">char</span> *argv[MAXARGS]; <span class="comment">/* argv for execve() */</span></span><br><span class="line">	<span class="type">int</span> bg;              <span class="comment">/* should the job run in bg or fg? */</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* parse command line */</span></span><br><span class="line">    <span class="comment">// 解析cmdline获得argv</span></span><br><span class="line">    bg = parseline(cmdline, argv); </span><br><span class="line">	<span class="keyword">if</span> (!builtin_cmd(argv)) &#123; </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * builtin_cmd - If the user has typed a built-in command then execute</span></span><br><span class="line"><span class="comment"> *    it immediately.  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">builtin_cmd</span><span class="params">(<span class="type">char</span> **argv)</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;quit&quot;</span>))</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);  <span class="comment">/* terminate shell */</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>然后我们<code>make</code>编译以下，查看测试情况，</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make test02</span><br><span class="line">./sdriver.pl -t trace02.txt -s ./tsh -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace02.txt - Process builtin quit command.</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure>
<p>和参考一样，通关~</p>
<h3 id="test03-amp-test04"><a href="#test03-amp-test04" class="headerlink" title="test03 &amp; test04"></a>test03 &amp; test04</h3><p>测试3和测试4的内容放在一起讲好了，因为</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest03</span><br><span class="line">./sdriver.pl -t trace03.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace03.txt - Run a foreground job.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; quit</span><br><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest04</span><br><span class="line">./sdriver.pl -t trace04.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace04.txt - Run a background job.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./myspin 1 &amp;</span><br><span class="line">[1] (9950) ./myspin 1 &amp;</span><br></pre></td></tr></table></figure>
<p>可以看到参考程序中，对于测试3，它测试了前台运行<code>quit</code>，测试4在后台运行了<code>myspin</code>，<code>myspin</code>是自旋等待了1秒。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in `parseline`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* should the job run in the background? */</span></span><br><span class="line">    <span class="keyword">if</span> ((bg = (*argv[argc<span class="number">-1</span>] == <span class="string">&#x27;&amp;&#x27;</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">	argv[--argc] = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在<code>parseline</code>通过上面的步骤解析判断了是否需要讲进程运行在后台。主要是通过检索命令行末尾的字符是否是‘&amp;’</p>
<p><strong>前台工作需要等待工作执行完毕就好了。不论是前台还是后台程序，都需要加入到jobs</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* global variables */</span></span><br><span class="line"><span class="type">int</span> nextjid = <span class="number">1</span>;            <span class="comment">/* next job ID to allocate */</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">/* addjob - Add a job to the job list */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">addjob</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span> *jobs, <span class="type">pid_t</span> pid, <span class="type">int</span> state, <span class="type">char</span> *cmdline)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">1</span>)	<span class="comment">// 无效pid</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++) &#123;	</span><br><span class="line">        <span class="comment">/* 如果jobs数组里面有pid等于0等于0的表项，表示这个位置可以用，把这个作业放进去 */</span></span><br><span class="line">        <span class="keyword">if</span> (jobs[i].pid == <span class="number">0</span>) &#123;</span><br><span class="line">            jobs[i].pid = pid;</span><br><span class="line">            jobs[i].state = state;</span><br><span class="line">            jobs[i].jid = nextjid++;</span><br><span class="line">            <span class="keyword">if</span> (nextjid &gt; MAXJOBS)</span><br><span class="line">                nextjid = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">strcpy</span>(jobs[i].cmdline, cmdline);</span><br><span class="line">            <span class="keyword">if</span>(verbose)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Added job [%d] %d %s\n&quot;</span>, jobs[i].jid, jobs[i].pid, jobs[i].cmdline);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Tried to create too many jobs\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>addjob</code>的工作就是为PID为pid的子进程分配一个jid，然后把jid保存在进程结构中,然后根据全局变量JID来给这个子进程为<code>tsh</code>编写这个子进程的JID。通过是为了防止JID越界的情况，需要额外对的<code>nextjid</code>进行判断。我们对此更加加深了对jid的理解。jid就是现在一共有几个job在<code>tsh</code>下面运行。由于<code>jobs</code>数组是有限的，所以jid超过了MAXJOBS的话是需要重置的。如果发生这种事情的话，只有当一个作业结束，<code>jobs</code>才能让出位置来，这是后才可以再分配工作。值得一提的是，根据课本<em>shell.c</em>的代码，我们可以在这里加一个，如果<code>verbose</code>有效的话，打印详细信息（加入的作业是啥）</p>
<p>我们还需要等待前台运行的子进程运行完，所以我们还要解决<code>waitfg</code>函数的问题。这个函数是需要我们自己编写的。主要功能就是阻塞当前进程也就是<code>tsh</code>，直到我们pid命名的子进程结束。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* fgpid - Return PID of current foreground job, 0 if no such job */</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fgpid</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span> *jobs)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++)</span><br><span class="line">	<span class="keyword">if</span> (jobs[i].state == FG)</span><br><span class="line">	    <span class="keyword">return</span> jobs[i].pid;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这个函数就是循环查看当前前台工作的作业的pid是多少。知道了这个我们就可以写<code>waitfg</code>函数了。当<code>pid</code>对应的进程还是前台进程的时候就一直循环等待。指导书里面说可以用循环<code>sleep(0)</code>进行等待。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">waitfg</span><span class="params">(<span class="type">pid_t</span> pid)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (pid == fgpid(jobs))</span><br><span class="line">        sleep(<span class="number">0</span>); <span class="comment">// 这里是指主动让出CPU的意思</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具备上面的基础，我们可以写出代码如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in `eval`</span></span><br><span class="line">...  </span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> (!builtin_cmd(argv)) &#123; </span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) == <span class="number">0</span>) &#123;  <span class="comment">/* child */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Background jobs should ignore SIGINT (ctrl-c)  */</span></span><br><span class="line">        <span class="comment">/* and SIGTSTP (ctrl-z) */</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        if (bg) &#123;</span></span><br><span class="line"><span class="comment">            // 课本对SIG_IGN有详细解释</span></span><br><span class="line"><span class="comment">            // 如果信号的handler是SIG_IGN，会忽略这个信号</span></span><br><span class="line"><span class="comment">            Signal(SIGINT, SIG_IGN);</span></span><br><span class="line"><span class="comment">            Signal(SIGTSTP, SIG_IGN);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        </span><br><span class="line">		<span class="comment">// 前台执行</span></span><br><span class="line">        <span class="keyword">if</span> (execve(argv[<span class="number">0</span>], argv, environ) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s: Command not found.\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">            fflush(<span class="built_in">stdout</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">// 如果没有这个可执行程序，那么直接终止这个子进程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* parent waits for foreground job to terminate or stop */</span></span><br><span class="line">    addjob(jobs, pid, (bg == <span class="number">1</span> ? BG : FG), cmdline);</span><br><span class="line">    <span class="keyword">if</span> (!bg) <span class="comment">// 前台运行则等待子进程</span></span><br><span class="line">        waitfg(pid);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%d] (%d) %s&quot;</span>, pid2jid(pid), pid, cmdline);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到上面的函数<code>fork</code>出一个子进程，然后<code>execve</code>执行某个可执行程序。对于父进程，父进程把这个进程添加到jobs队列中去。然后如果这是一个前台程序，就调用<code>waitfg</code>等待子进程结束。如果子进程结束了。通过SIGCHLD信号给父进程发信息，唤醒父进程回收自己。</p>
<p>父进程回收处理程序如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * sigchld_handler - The kernel sends a SIGCHLD to the shell whenever</span></span><br><span class="line"><span class="comment"> *     a child job terminates (becomes a zombie), or stops because it</span></span><br><span class="line"><span class="comment"> *     received a SIGSTOP or SIGTSTP signal. The handler reaps all</span></span><br><span class="line"><span class="comment"> *     available zombie children, but doesn&#x27;t wait for any other</span></span><br><span class="line"><span class="comment"> *     currently running children to terminate.  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sigchld_handler</span><span class="params">(<span class="type">int</span> sig)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (verbose)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sigchld_handler: entering \n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    * 回收僵尸进程</span></span><br><span class="line"><span class="comment">    * 这里的WNOHANG是非常重要的。</span></span><br><span class="line"><span class="comment">    * 它的本意是如果所有孩子都没有僵尸(终止)状态的，直接退出</span></span><br><span class="line"><span class="comment">    * 这个能够避免在这里等待所有前台的running和stopped程序终止</span></span><br><span class="line"><span class="comment">    * 这样tsh就不能正常接受用户的输入了</span></span><br><span class="line"><span class="comment">    * WUNTRACED是等待直到有一个子进程变成僵尸退出，返回它的pid</span></span><br><span class="line"><span class="comment">    * 这个选项开启能够检查已终止和被停止的子进程</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">while</span> ((pid = waitpid(<span class="number">-1</span>, &amp;status, WNOHANG | WUNTRACED)) &gt; <span class="number">0</span>) &#123; </span><br><span class="line">        <span class="comment">// 这里不管是不是正常exit或者ctrl-c或者ctrl-z退出的</span></span><br><span class="line">        <span class="comment">// 子进程都结束了，都要回收资源</span></span><br><span class="line">        deletejob(jobs, pid);</span><br><span class="line">        <span class="keyword">if</span> (verbose)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;sigchld_handler: job %d deleted\n&quot;</span>, pid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (verbose)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sigchld_handler: exiting\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>像上面这样写看起来是没有什么问题了。但是课本519中提示了一种苛刻同步问题。如果子进程在父进程将自己加入到<code>jobs</code>之前就执行完毕，然后<code>exit</code>退出，就会触发父进程的回收<code>sigchld_handler</code>程序，实际上，这样的删除显然没有任何意义。后续又将这个工作<code>addjob</code>，这也是没有什么意义的。</p>
<p>因此我们还要对上面的<code>eval</code>进一步修改为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in `eval`</span></span><br><span class="line">...   </span><br><span class="line"><span class="type">sigset_t</span> mask;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> (!builtin_cmd(argv)) &#123;</span><br><span class="line">        Sigprocmask(SIG_BLOCK, &amp;mask, &amp;prev);  <span class="comment">/* 阻塞SIGCHLD */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((pid = fork()) == <span class="number">0</span>) &#123;   <span class="comment">/* Child runs user job */</span></span><br><span class="line">            <span class="comment">/* 给fork出来的子进程设置一个独立的组，</span></span><br><span class="line"><span class="comment">	 		 * 子进程是这个组的组长,组id为子进程的pid */</span></span><br><span class="line">            setpgid(<span class="number">0</span>, <span class="number">0</span>);	</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/* 对于子进程并不需要阻塞SIGCHLD的信号 */</span></span><br><span class="line">            Sigprocmask(SIG_UNBLOCK, &amp;prev, <span class="literal">NULL</span>);  <span class="comment">// unblock SIGCHLD</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">/* </span></span><br><span class="line"><span class="comment">            * 前台执行 </span></span><br><span class="line"><span class="comment">            * 如果没有这个可执行程序，那么直接终止这个子进程</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">if</span> (execve(argv[<span class="number">0</span>], argv, environ) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s: Command not found.\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">                _exit(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        addjob(jobs, pid, bg ? BG : FG, cmdline);</span><br><span class="line">        <span class="comment">/* 已经加到jobs了，解除阻塞 */</span></span><br><span class="line">        Sigprocmask(SIG_SETMASK, &amp;prev, <span class="literal">NULL</span>);  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Parent waits for foreground job to terminate */</span></span><br><span class="line">        <span class="keyword">if</span> (!bg)  <span class="comment">// 前台运行则等待子进程</span></span><br><span class="line">            waitfg(pid);</span><br><span class="line">        <span class="keyword">else</span>      <span class="comment">// background</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[%d] (%d) %s&quot;</span>, pid2jid(pid), pid, cmdline);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>测试以下我们的代码的正确性</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest03</span><br><span class="line">./sdriver.pl -t trace03.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace03.txt - Run a foreground job.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; quit</span><br><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make test03</span><br><span class="line">./sdriver.pl -t trace03.txt -s ./tsh -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace03.txt - Run a foreground job.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; quit</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest04</span><br><span class="line">./sdriver.pl -t trace04.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace04.txt - Run a background job.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./myspin 1 &amp;</span><br><span class="line">[1] (10488) ./myspin 1 &amp;</span><br><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make test04</span><br><span class="line">./sdriver.pl -t trace04.txt -s ./tsh -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace04.txt - Run a background job.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./myspin 1 &amp;</span><br><span class="line">[1] (10494) ./myspin 1 &amp;</span><br></pre></td></tr></table></figure>
<p>测试程序都相同了，成功~</p>
<h3 id="test05"><a href="#test05" class="headerlink" title="test05"></a>test05</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest05</span><br><span class="line">./sdriver.pl -t trace05.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace05.txt - Process jobs builtin command.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./myspin 2 &amp;</span><br><span class="line">[1] (10504) ./myspin 2 &amp;</span><br><span class="line">tsh&gt; ./myspin 3 &amp;</span><br><span class="line">[2] (10506) ./myspin 3 &amp;</span><br><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br><span class="line">[1] (10504) Running ./myspin 2 &amp;</span><br><span class="line">[2] (10506) Running ./myspin 3 &amp;</span><br></pre></td></tr></table></figure>
<p>这里的任务是完成内嵌指令<code>jobs</code>的工作。它能够列出作业列表中的所有作业。</p>
<p>这个很简单，起始只要用一个<code>listjobs</code>就可已完成这个工作了，这个函数是实验已经帮我们实现了的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* listjobs - Print the job list */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">listjobs</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span> *jobs)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (jobs[i].pid != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[%d] (%d) &quot;</span>, jobs[i].jid, jobs[i].pid);</span><br><span class="line">            <span class="keyword">switch</span> (jobs[i].state) &#123;</span><br><span class="line">                <span class="keyword">case</span> BG: </span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Running &quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> FG: </span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Foreground &quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> ST: </span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Stopped &quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;listjobs: Internal error: job[%d].state=%d &quot;</span>, </span><br><span class="line">                           i, jobs[i].state);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, jobs[i].cmdline);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在<code>builtin_cmd</code>中加入<code>jobs</code>命令的入口就好。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">builtin_cmd</span><span class="params">(<span class="type">char</span> **argv)</span> </span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// jobs command    </span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;jobs&quot;</span>)) &#123;        </span><br><span class="line">        listjobs(jobs);        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>我们看看测试结果</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest05</span><br><span class="line">./sdriver.pl -t trace05.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace05.txt - Process jobs builtin command.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./myspin 2 &amp;</span><br><span class="line">[1] (10613) ./myspin 2 &amp;</span><br><span class="line">tsh&gt; ./myspin 3 &amp;</span><br><span class="line">[2] (10615) ./myspin 3 &amp;</span><br><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br><span class="line">[1] (10613) Running ./myspin 2 &amp;</span><br><span class="line">[2] (10615) Running ./myspin 3 &amp;</span><br><span class="line"></span><br><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make test05</span><br><span class="line">./sdriver.pl -t trace05.txt -s ./tsh -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace05.txt - Process jobs builtin command.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./myspin 2 &amp;</span><br><span class="line">[1] (10622) ./myspin 2 &amp;</span><br><span class="line">tsh&gt; ./myspin 3 &amp;</span><br><span class="line">[2] (10624) ./myspin 3 &amp;</span><br><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br><span class="line">[1] (10622) Running ./myspin 2 &amp;</span><br><span class="line">[2] (10624) Running ./myspin 3 &amp;</span><br></pre></td></tr></table></figure>
<p>和参考一致，表示正确。这里你可能会被英文的实验指导书迷惑了，实际上列出的是工作列表的所有工作，而不是后台的所有工作。通关~</p>
<h3 id="test06-amp-test07-amp-test08"><a href="#test06-amp-test07-amp-test08" class="headerlink" title="test06 &amp; test07 &amp; test08"></a>test06 &amp; test07 &amp; test08</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest06</span><br><span class="line">./sdriver.pl -t trace06.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace06.txt - Forward SIGINT to foreground job.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./myspin 4</span><br><span class="line">Job [1] (10840) terminated by signal 2</span><br><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest07</span><br><span class="line">./sdriver.pl -t trace07.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace07.txt - Forward SIGINT only to foreground job.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./myspin 4 &amp;</span><br><span class="line">[1] (10846) ./myspin 4 &amp;</span><br><span class="line">tsh&gt; ./myspin 5</span><br><span class="line">Job [2] (10848) terminated by signal 2</span><br><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br><span class="line">[1] (10846) Running ./myspin 4 &amp;</span><br><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest08</span><br><span class="line">./sdriver.pl -t trace08.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace08.txt - Forward SIGTSTP only to foreground job.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./myspin 4 &amp;</span><br><span class="line">[1] (10856) ./myspin 4 &amp;</span><br><span class="line">tsh&gt; ./myspin 5</span><br><span class="line">Job [2] (10858) stopped by signal 20</span><br><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br><span class="line">[1] (10856) Running ./myspin 4 &amp;</span><br><span class="line">[2] (10858) Stopped ./myspin 5 </span><br></pre></td></tr></table></figure>
<p>测试678要完成的任务是对于SIGINT和SIGTSTP的处理。对于上面的测试，测试6启动一个自旋程序到前台并且发出SIGINT终止它。测试7启动两个自旋，一个在前台一个在后台，然后发出SIGINT，检测到只有前台进程被终止了。测试8类似。</p>
<p><img src="/2022/05/26/CSAPP-shlab-report/image-20220526003548830.png" alt="image-20220526003548830" style="zoom:67%;"></p>
<p>我们可以从课本上这幅图看到shell会给每一个子进程分配一个和PID一样的组id，这些shell的子进程的孩子都在这些子进程的组内。比如上图中的前台作业就是shell产生的子进程，但是它和shell不是一个组的，他自己独立成组，组id等于自己的pid，然后它的孩子都属于自己这个组。</p>
<p>首先需要完成SIGINT的处理，给前台进程的组的所有进程发送SIGINT信号(这里就是参数sig)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sigint_handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 这一步的保存和下一步的恢复，是由于在下面的kill系统调用中可能会覆盖errno的值</span></span><br><span class="line">    <span class="comment">// 导致现在的errno丢失</span></span><br><span class="line">    <span class="comment">// 而errno在sigchild_handler中还有使用到，为了避免产生这种错误需要在这里保存，在后面恢复</span></span><br><span class="line">    <span class="type">int</span> olderrno = errno;</span><br><span class="line">    <span class="comment">// get the foreground job pid</span></span><br><span class="line">    <span class="type">pid_t</span> fg_pid = fgpid(jobs);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * int kill(pid_t pid,int signo)</span></span><br><span class="line"><span class="comment"> 	* 功能: 向进程或进程组发送一个信号 （成功返回 0； 否则，返回 -1 ）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    kill(-fg_pid, sig); </span><br><span class="line">    <span class="comment">// -fg_pid表示向进程组号为pid的组中的每个进程发sig信号</span></span><br><span class="line">    <span class="comment">// 在这里就是向前台进程以及它的每一个子进程(子进程都在自己的父进程的pid为组id的组下)</span></span><br><span class="line">    errno = olderrno;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相同的原理，可以写出<code>sigtstp_handler</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sigtstp_handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 为了异步信号安全防止errno被覆盖</span></span><br><span class="line">    <span class="type">int</span> olderrno = errno;</span><br><span class="line">    <span class="comment">// get the foreground job pid</span></span><br><span class="line">    <span class="type">pid_t</span> fg_pid = fgpid(jobs);</span><br><span class="line">    <span class="comment">// kill the group in the foreground</span></span><br><span class="line">    kill(-fg_pid, sig);</span><br><span class="line">    errno = olderrno;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的两个函数就是信号处理过程。<code>sigchld_handler</code>里收到子进程终止或停止的消息后给出对应的输出然后改变其状态，对于终止的进程就在jobs里将其删除，对于停止的进程则设置其state为ST。</p>
<p><img src="/2022/05/26/CSAPP-shlab-report/image-20220526081536379.png" alt="image-20220526081536379" style="zoom:80%;"></p>
<p>主要流程如上图。</p>
<p>然后就是对<code>sigchld_handler</code>的修改。我们需要针对上面的代码进一步进行修改。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sigchld_handler - The kernel sends a SIGCHLD to the shell whenever</span></span><br><span class="line"><span class="comment"> *     a child job terminates (becomes a zombie), or stops because it</span></span><br><span class="line"><span class="comment"> *     received a SIGSTOP or SIGTSTP signal. The handler reaps all</span></span><br><span class="line"><span class="comment"> *     available zombie children, but doesn&#x27;t wait for any other</span></span><br><span class="line"><span class="comment"> *     currently running children to terminate.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sigchld_handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> old_errno = errno;</span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (verbose)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sigchld_handler: entering \n&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* </span></span><br><span class="line"><span class="comment">    * 回收僵尸进程</span></span><br><span class="line"><span class="comment">    * 这里的WNOHANG是非常重要的。</span></span><br><span class="line"><span class="comment">    * 它的本意是如果所有孩子都没有僵尸(终止)状态的，直接退出</span></span><br><span class="line"><span class="comment">    * 这个能够避免在这里等待所有前台的running和stopped程序终止</span></span><br><span class="line"><span class="comment">    * 这样tsh就不能正常接受用户的输入了</span></span><br><span class="line"><span class="comment">    * WUNTRACED是等待直到有一个子进程变成僵尸退出，返回它的pid</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">while</span> ((pid = waitpid(<span class="number">-1</span>, &amp;status, WNOHANG | WUNTRACED)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* 这里实验指导书说不能用while，但是不用会出现错误。他说的while和我的判断条件不一样 */</span></span><br><span class="line">        <span class="comment">// 子进程正常退出</span></span><br><span class="line">        <span class="keyword">if</span> (WIFEXITED(status)) &#123;</span><br><span class="line">            deletejob(jobs, pid);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 子进程因为ctrl-c退出</span></span><br><span class="line">        <span class="keyword">if</span> (WIFSIGNALED(status)) &#123; <span class="comment">// terminated by ctrl-c</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Job [%d] (%d) terminated by signal %2d\n&quot;</span>, </span><br><span class="line">                   pid2jid(pid), pid, WTERMSIG(status));</span><br><span class="line">            deletejob(jobs, pid); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (WIFSTOPPED(status)) &#123; <span class="comment">// stopped by ctrl-z</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Job [%d] (%d) stopped by signal %2d\n&quot;</span>,</span><br><span class="line">                   pid2jid(pid), pid, WSTOPSIG(status));</span><br><span class="line">            <span class="comment">// 修改子进程状态为ST</span></span><br><span class="line">            getjobpid(jobs, pid)-&gt;state = ST;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    errno = old_errno;</span><br><span class="line">    <span class="keyword">if</span> (verbose) </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sigchld_handler: exiting\n&quot;</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的程序，在子进程发送SIGCHLD时处于不同状态的子进程，已经有了不同的处理。</p>
<p>但是还存在一个问题，就是<code>printf</code>是异步不安全的。可能出现死锁现象。</p>
<p><strong>死锁（Deadlock）：</strong>当你存在多个逻辑流在等待永远不会发生的场景时就会出现死锁。比如在信号处理程序中使用异步信号不安全的<code>printf</code>函数就可能会出现死锁现象。在主程序中执行了<code>printf</code>函数，则该函数会请求某些资源的一个锁，当该<code>printf</code>函数请求这个锁时它被某个信号处理程序中断了，而在信号处理程序中也要执行一个<code>printf</code>函数，这个<code>printf</code>也试图请求那个锁，但是由于主程序中的<code>printf</code>函数持有那个锁，所以信号处理程序中的<code>printf</code>得不到那个锁，所以这个<code>printf</code>就在等待那个锁被释放的锁，但是主程序只有在信号处理程序返回时才可能释放那个锁，所以这里就造成了死锁。</p>
<p>这里是线程安全但是不可重入的异步安全问题，使用锁是不能够解决的。</p>
<p>所以我们再主线程也就是<code>main</code>里面已经使用过<code>printf</code>了，就要避免在信号处理程序中在使用<code>printf</code>的出现。</p>
<p>我提供下面两种解决手段。</p>
<ul>
<li>一种想法是在这里使用<code>printf</code>的时候屏蔽或者说阻塞SIGCHLD信号，这样主线程在使用<code>printf</code>就不会被中断。但是带来的问题就是这个中断处理信号会被忽略。可能出现处理遗漏的情况。</li>
<li>还有一种处理手段是使用异步信号安全的可重入函数，如下</li>
</ul>
<blockquote>
<p>CSAPP课本实例程序提供了一种线程安全且可重入的函数sio系列函数，使用它，不调用<code>printf</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* private functions */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sio_reverse</span><span class="params">(<span class="type">char</span> s[])</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sio_ltoa</span><span class="params">(<span class="type">long</span> v, <span class="type">char</span> s[], <span class="type">int</span> b)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">size_t</span> <span class="title function_">sio_strlen</span><span class="params">(<span class="type">char</span> s[])</span>;</span><br><span class="line"><span class="comment">/* public functions */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sio_puts</span><span class="params">(<span class="type">char</span> s[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sio_putl</span><span class="params">(<span class="type">long</span> v)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sio_error</span><span class="params">(<span class="type">char</span> s[])</span>;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>查看Linux手册可以知道<code>write</code>是异步信号安全的，使用<code>write</code>就可以实现异步安全的输出了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sio_puts</span><span class="params">(<span class="type">char</span> s[])</span> <span class="comment">/* Put string */</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> write(STDOUT_FILENO, s, <span class="built_in">strlen</span>(s));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我对上面的sio族进行封装形成Sio系列。</p>
<p>我们把<code>sigchld_handler</code>修改以下如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sigchld_handler - The kernel sends a SIGCHLD to the shell whenever</span></span><br><span class="line"><span class="comment"> *     a child job terminates (becomes a zombie), or stops because it</span></span><br><span class="line"><span class="comment"> *     received a SIGSTOP or SIGTSTP signal. The handler reaps all</span></span><br><span class="line"><span class="comment"> *     available zombie children, but doesn&#x27;t wait for any other</span></span><br><span class="line"><span class="comment"> *     currently running children to terminate.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sigchld_handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> old_errno = errno;</span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (verbose)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sigchld_handler: entering \n&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* </span></span><br><span class="line"><span class="comment">    * 回收僵尸进程</span></span><br><span class="line"><span class="comment">    * 这里的WNOHANG是非常重要的。</span></span><br><span class="line"><span class="comment">    * 它的本意是如果所有孩子都没有僵尸(终止)状态的，直接退出</span></span><br><span class="line"><span class="comment">    * 这个能够避免在这里等待所有前台的running和stopped程序终止</span></span><br><span class="line"><span class="comment">    * 这样tsh就不能正常接受用户的输入了</span></span><br><span class="line"><span class="comment">    * WUNTRACED是等待直到有一个子进程变成僵尸退出，返回它的pid</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">while</span> ((pid = waitpid(<span class="number">-1</span>, &amp;status, WNOHANG | WUNTRACED)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程正常退出</span></span><br><span class="line">        <span class="keyword">if</span> (WIFEXITED(status)) &#123;</span><br><span class="line">            deletejob(jobs, pid);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 子进程因为ctrl-c退出</span></span><br><span class="line">        <span class="keyword">if</span> (WIFSIGNALED(status)) &#123; <span class="comment">// terminated by ctrl-c</span></span><br><span class="line">            <span class="comment">/* printf(&quot;Job [%d] (%d) terminated by signal %2d\n&quot;, </span></span><br><span class="line"><span class="comment">                   pid2jid(pid), pid, WTERMSIG(status)); */</span> &#123;</span><br><span class="line">            	Sio_puts(<span class="string">&quot;Job [&quot;</span>);</span><br><span class="line">                Sio_putl(pid2jid(pid));</span><br><span class="line">                Sio_puts(<span class="string">&quot;] (&quot;</span>);</span><br><span class="line">                Sio_putl(pid);</span><br><span class="line">                Sio_puts(<span class="string">&quot;) terminated by signal &quot;</span>);</span><br><span class="line">                Sio_putl(WTERMSIG(status));</span><br><span class="line">                Sio_puts(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            deletejob(jobs, pid); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (WIFSTOPPED(status)) &#123; <span class="comment">// stopped by ctrl-z</span></span><br><span class="line">            <span class="comment">/* printf(&quot;Job [%d] (%d) stopped by signal %2d\n&quot;,</span></span><br><span class="line"><span class="comment">                   pid2jid(pid), pid, WSTOPSIG(status)); */</span> &#123;</span><br><span class="line">            	Sio_puts(<span class="string">&quot;Job [&quot;</span>);</span><br><span class="line">                Sio_putl(pid2jid(pid));</span><br><span class="line">                Sio_puts(<span class="string">&quot;] (&quot;</span>);</span><br><span class="line">                Sio_putl(pid);</span><br><span class="line">                Sio_puts(<span class="string">&quot;) stopped by signal &quot;</span>);</span><br><span class="line">                Sio_putl(WSTOPSIG(status));</span><br><span class="line">                Sio_puts(<span class="string">&quot;\n&quot;</span>);           </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 修改子进程状态为ST</span></span><br><span class="line">            getjobpid(jobs, pid)-&gt;state = ST;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    errno = old_errno;</span><br><span class="line">    <span class="keyword">if</span> (verbose) &#123;</span><br><span class="line">        <span class="comment">/* printf(&quot;sigchld_handler: exiting\n&quot;); */</span> &#123;</span><br><span class="line">        	Sio_puts(<span class="string">&quot;sigchld_handler: exiting\n&quot;</span>);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就不会在处理信号程序中使用异步信号不安全的<code>printf</code>了。</p>
<p>然后，<em>shell</em>程序本身是所有子进程的父进程，按照<code>fork</code>函数简单实现，会被分配在一个组中。如果收到了SIGINT，发送给子进程的组，那也会发送给自己（子进程就在自己的组中），那么自己又会收到SIGINT，然后又会发送给自己的所有子进程，然后自己又收到…就陷入循环中无法继续，或者崩溃退出。所以<em>shell</em>不可以和它的子进程在同一个组内，就是要给每个子进程单独的组，组的id就是子进程的pid。我们应该把这个操作放在<code>fork</code>之后，修改它的组id，然后执行<code>execve</code>。</p>
<p>修改<code>eval</code>这一部分代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((pid = fork()) == <span class="number">0</span>) &#123;  <span class="comment">/* child */</span></span><br><span class="line">	<span class="comment">/* 给fork出来的子进程设置一个独立的组，</span></span><br><span class="line"><span class="comment">	 * 子进程是这个组的组长,组id为子进程的pid */</span></span><br><span class="line">    setpgid(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>setpgid</code>函数在实验英文指导书有介绍，用于设置进程组id</p>
<p>表头文件 #include<unistd.h></unistd.h></p>
<p>定义函数 int setpgid(pid_t pid,pid_t pgid);</p>
<p>功能：设置pid所在的进程组的进程组id设置成pgid</p>
<p>setpgid(0, 0)的含义：</p>
<ul>
<li>第一个参数pid是0，则使用当前进程的pid</li>
<li>第二个参数pgid是0，则使用当前进程pid作为pgid</li>
</ul>
</blockquote>
<p>测试结果</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest06</span><br><span class="line">./sdriver.pl -t trace06.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace06.txt - Forward SIGINT to foreground job.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./myspin 4</span><br><span class="line">Job [1] (3427) terminated by signal 2</span><br><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make test06</span><br><span class="line">./sdriver.pl -t trace06.txt -s ./tsh -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace06.txt - Forward SIGINT to foreground job.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./myspin 4</span><br><span class="line">Job [1] (3433) terminated by signal 2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest07</span><br><span class="line">./sdriver.pl -t trace07.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace07.txt - Forward SIGINT only to foreground job.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./myspin 4 &amp;</span><br><span class="line">[1] (3440) ./myspin 4 &amp;</span><br><span class="line">tsh&gt; ./myspin 5</span><br><span class="line">Job [2] (3442) terminated by signal 2</span><br><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br><span class="line">[1] (3440) Running ./myspin 4 &amp;</span><br><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make test07</span><br><span class="line">./sdriver.pl -t trace07.txt -s ./tsh -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace07.txt - Forward SIGINT only to foreground job.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./myspin 4 &amp;</span><br><span class="line">[1] (3449) ./myspin 4 &amp;</span><br><span class="line">tsh&gt; ./myspin 5</span><br><span class="line">Job [2] (3451) terminated by signal 2</span><br><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br><span class="line">[1] (3449) Running ./myspin 4 &amp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest08</span><br><span class="line">./sdriver.pl -t trace08.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace08.txt - Forward SIGTSTP only to foreground job.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./myspin 4 &amp;</span><br><span class="line">[1] (3459) ./myspin 4 &amp;</span><br><span class="line">tsh&gt; ./myspin 5</span><br><span class="line">Job [2] (3461) stopped by signal 20</span><br><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br><span class="line">[1] (3459) Running ./myspin 4 &amp;</span><br><span class="line">[2] (3461) Stopped ./myspin 5 </span><br><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make test08</span><br><span class="line">./sdriver.pl -t trace08.txt -s ./tsh -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace08.txt - Forward SIGTSTP only to foreground job.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./myspin 4 &amp;</span><br><span class="line">[1] (3469) ./myspin 4 &amp;</span><br><span class="line">tsh&gt; ./myspin 5</span><br><span class="line">Job [2] (3471) terminated by signal 20</span><br><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br><span class="line">[1] (3469) Running ./myspin 4 &amp;</span><br><span class="line">[2] (3471) Stopped ./myspin 5 </span><br></pre></td></tr></table></figure>
<p>可以看到与参考输出一致，通关~</p>
<h3 id="test09-amp-test10"><a href="#test09-amp-test10" class="headerlink" title="test09 &amp; test10"></a>test09 &amp; test10</h3><p>第九个和第十个放在一起写。请往下看。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest09</span><br><span class="line">./sdriver.pl -t trace09.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace09.txt - Process bg builtin command</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./myspin 4 &amp;</span><br><span class="line">[1] (3480) ./myspin 4 &amp;</span><br><span class="line">tsh&gt; ./myspin 5</span><br><span class="line">Job [2] (3482) stopped by signal 20</span><br><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br><span class="line">[1] (3480) Running ./myspin 4 &amp;</span><br><span class="line">[2] (3482) Stopped ./myspin 5 </span><br><span class="line">tsh&gt; <span class="built_in">bg</span> %2</span><br><span class="line">[2] (3482) ./myspin 5 </span><br><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br><span class="line">[1] (3480) Running ./myspin 4 &amp;</span><br><span class="line">[2] (3482) Running ./myspin 5 </span><br></pre></td></tr></table></figure>
<p>我们先看看第九个测试的参考输出。我们可以看到我们需要构建的是<code>bg</code>内置命令的相关功能。</p>
<blockquote>
<p><code>bg &lt;job&gt;</code>通过向<code>&lt;job&gt;</code>发送SIGCONT来重启它，然后让它运行在后台中，<code>&lt;job&gt;</code>参数可以用PID或者JID</p>
<ul>
<li>如果参数是PID则直接输入pid即可</li>
<li>如果参数是JID则输入“%jid”</li>
</ul>
</blockquote>
<p>我们看到上面的测试。首先是开启一个后台自旋和一个前台自旋的程序。然后发起ctrl-z终止前台的进程。然后jobs可以看到两个进程以及状态。后台的进程仍然在正常运行，但是前台的进程由于SIGTSTP信号而进入stopped状态。然后使用<code>bg %2</code>指令，把第二个子进程（停止的“./myspin 5”）唤醒，然后放到后台执行。输入<code>jobs</code>指令可以看到两个都在执行，但是后者是后来被切换到后台的，所以没有它的cmdline还没有更新还是显示原来的“./myspin 5”。</p>
<p>再看看<code>rtest10</code>，第十个测试</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest10</span><br><span class="line">./sdriver.pl -t trace10.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace10.txt - Process fg builtin command. </span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./myspin 4 &amp;</span><br><span class="line">[1] (3510) ./myspin 4 &amp;</span><br><span class="line">tsh&gt; <span class="built_in">fg</span> %1</span><br><span class="line">Job [1] (3510) stopped by signal 20</span><br><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br><span class="line">[1] (3510) Stopped ./myspin 4 &amp;</span><br><span class="line">tsh&gt; <span class="built_in">fg</span> %1</span><br><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br></pre></td></tr></table></figure>
<p>它针对的是fg这个内置命令的处理。</p>
<blockquote>
<p><code>fg &lt;job&gt;</code>命令通过发送SIGCONT信号给进程<code>&lt;job&gt;</code>，然后把它运行在前台中，<code>&lt;job&gt;</code>参数可以用PID或者JID</p>
<ul>
<li>如果参数是PID则直接输入pid即可</li>
<li>如果参数是JID则输入“%jid”</li>
</ul>
</blockquote>
<p>可以看到上面的测试样例，一开始，是后台运行一个“./myspin 4”，然后把它放到前台运行，使用“fg %1”命令，切换到前台执行，<em>shell</em>等待它执行完毕。然后<code>jobs</code>查看看到有一个停止的工作，然后把它放到前台并开始运行。最后<code>jobs</code>查看，由于已经运行完了，所以没有输出。</p>
<p>对于这两个功能我们要实现的是<code>do_fgbg</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * do_bgfg - Execute the builtin bg and fg commands</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_bgfg</span><span class="params">(<span class="type">char</span>** argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">job_t</span>* <span class="title">job</span>;</span></span><br><span class="line">    <span class="type">char</span>* id = argv[<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断输入的是jid还是pid</span></span><br><span class="line">    <span class="keyword">if</span> (id[<span class="number">0</span>] == <span class="string">&#x27;%&#x27;</span>) &#123; <span class="comment">/* jid */</span></span><br><span class="line">        <span class="comment">//去掉&#x27;%&#x27;开始读jid，根据jid返回这个子进程的结构指针</span></span><br><span class="line">        <span class="type">int</span> jid = atoi(id + <span class="number">1</span>);</span><br><span class="line">        job = getjobjid(jobs, jid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;              <span class="comment">/* pid */</span></span><br><span class="line">        <span class="type">int</span> pid = atoi(id);</span><br><span class="line">        job = getjobpid(jobs, pid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    * kill不单是杀掉进程，还有发送信号的功能 </span></span><br><span class="line"><span class="comment">    * 这里唤醒job所在的组中的所有进程</span></span><br><span class="line"><span class="comment">    * 就是唤醒这个stopped的子进程，以及它派生的孙子进程</span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">    kill(-(job-&gt;pid), SIGCONT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;fg&quot;</span>)) &#123;  <span class="comment">// fg command</span></span><br><span class="line">        job-&gt;state = FG;</span><br><span class="line">        <span class="comment">// 等待该前台作业终止</span></span><br><span class="line">        waitfg(job-&gt;pid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;                         <span class="comment">// bg command</span></span><br><span class="line">        job-&gt;state = BG;</span><br><span class="line">        <span class="comment">/* 切换到bg后打印作业信息 */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%d] (%d) %s&quot;</span>, pid2jid(job-&gt;pid), job-&gt;pid, job-&gt;cmdline);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们在<code>builtin_cmd</code>中加入函数入口。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in `builtin_cmd`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// bg or fg command</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;bg&quot;</span>) || !<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;fg&quot;</span>)) &#123;</span><br><span class="line">    do_bgfg(argv);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查看测试结果</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest09</span><br><span class="line">./sdriver.pl -t trace09.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace09.txt - Process bg builtin command</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./myspin 4 &amp;</span><br><span class="line">[1] (3627) ./myspin 4 &amp;</span><br><span class="line">tsh&gt; ./myspin 5</span><br><span class="line">Job [2] (3629) stopped by signal 20</span><br><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br><span class="line">[1] (3627) Running ./myspin 4 &amp;</span><br><span class="line">[2] (3629) Stopped ./myspin 5 </span><br><span class="line">tsh&gt; <span class="built_in">bg</span> %2</span><br><span class="line">[2] (3629) ./myspin 5 </span><br><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br><span class="line">[1] (3627) Running ./myspin 4 &amp;</span><br><span class="line">[2] (3629) Running ./myspin 5 </span><br><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make test09</span><br><span class="line">./sdriver.pl -t trace09.txt -s ./tsh -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace09.txt - Process bg builtin command</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./myspin 4 &amp;</span><br><span class="line">[1] (3638) ./myspin 4 &amp;</span><br><span class="line">tsh&gt; ./myspin 5</span><br><span class="line">Job [2] (3640) terminated by signal 20</span><br><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br><span class="line">[1] (3638) Running ./myspin 4 &amp;</span><br><span class="line">[2] (3640) Stopped ./myspin 5 </span><br><span class="line">tsh&gt; <span class="built_in">bg</span> %2</span><br><span class="line">[2] (3640) ./myspin 5 </span><br><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br><span class="line">[1] (3638) Running ./myspin 4 &amp;</span><br><span class="line">[2] (3640) Running ./myspin 5 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest10</span><br><span class="line">./sdriver.pl -t trace10.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace10.txt - Process fg builtin command. </span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./myspin 4 &amp;</span><br><span class="line">[1] (7350) ./myspin 4 &amp;</span><br><span class="line">tsh&gt; <span class="built_in">fg</span> %1</span><br><span class="line">Job [1] (7350) stopped by signal 20</span><br><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br><span class="line">[1] (7350) Stopped ./myspin 4 &amp;</span><br><span class="line">tsh&gt; <span class="built_in">fg</span> %1</span><br><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make test10</span><br><span class="line">./sdriver.pl -t trace10.txt -s ./tsh -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace10.txt - Process fg builtin command. </span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./myspin 4 &amp;</span><br><span class="line">[1] (7361) ./myspin 4 &amp;</span><br><span class="line">tsh&gt; <span class="built_in">fg</span> %1</span><br><span class="line">Job [1] (7361) stopped by signal 20</span><br><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br><span class="line">[1] (7361) Stopped ./myspin 4 &amp;</span><br><span class="line">tsh&gt; <span class="built_in">fg</span> %1</span><br><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br></pre></td></tr></table></figure>
<p>与参考一致，通关~</p>
<h3 id="test11-amp-test12-amp-test13"><a href="#test11-amp-test12-amp-test13" class="headerlink" title="test11 &amp; test12 &amp; test13"></a>test11 &amp; test12 &amp; test13</h3><p>先看看test11</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest11</span><br><span class="line">./sdriver.pl -t trace11.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace11.txt - Forward SIGINT to every process in foreground process group</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure>
<p>要求我们接收到SIGINT的时候把它发送给前台进程所处的进程组的所有进程。这个在我们前面的代码中的<code>sigint_handler</code>就已经有所处理了。</p>
<p>然后看看test12</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest12</span><br><span class="line">./sdriver.pl -t trace12.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace12.txt - Forward SIGTSTP to every process in foreground process group</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure>
<p>和测试11类似，我们接受到SIGTSTP的时候要把信号发给前台进程所处的进程组的所有进程。这个在<code>sigtstp_handler</code>就已经处理了。</p>
<p>再看看test13</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest13</span><br><span class="line">./sdriver.pl -t trace13.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace13.txt - Restart every stopped process in process group</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure>
<p>这个测试检测的是能够重启一个进程(原来是stopped状态)，这个功能在对于内置指令<code>fg</code>以及<code>bg</code>的处理上已经实现了。</p>
<blockquote>
<p>对于Linux下的ps命令a参数表示显示所有的进程</p>
<p>状态码：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Here are the different values that the s, <span class="built_in">stat</span> and state output specifiers (header <span class="string">&quot;STAT&quot;</span> or <span class="string">&quot;S&quot;</span>) will display to describe the state of a process:</span><br><span class="line"></span><br><span class="line">        D    uninterruptible <span class="built_in">sleep</span> (usually IO)</span><br><span class="line">        R    running or runnable (on run queue)</span><br><span class="line">        S    interruptible <span class="built_in">sleep</span> (waiting <span class="keyword">for</span> an event to complete)</span><br><span class="line">        T    stopped by job control signal</span><br><span class="line">        t    stopped by debugger during the tracing</span><br><span class="line">        W    paging (not valid since the 2.6.xx kernel)</span><br><span class="line">        X    dead (should never be seen)</span><br><span class="line">        Z    defunct (<span class="string">&quot;zombie&quot;</span>) process, terminated but not reaped by its parent</span><br><span class="line"></span><br><span class="line">For BSD formats and when the <span class="built_in">stat</span> keyword is used, additional characters may be displayed:</span><br><span class="line">        &lt;    high-priority (not <span class="built_in">nice</span> to other <span class="built_in">users</span>)</span><br><span class="line">        N    low-priority (<span class="built_in">nice</span> to other <span class="built_in">users</span>)</span><br><span class="line">        L    has pages locked into memory (<span class="keyword">for</span> real-time and custom IO)</span><br><span class="line">        s    is a session leader</span><br><span class="line">        l    is multi-threaded (using CLONE_THREAD, like NPTL pthreads <span class="keyword">do</span>)</span><br><span class="line">           +    is <span class="keyword">in</span> the foreground process group</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>我们直接对比测试结果</strong></p>
<ul>
<li><strong>test11</strong></li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest11</span><br><span class="line">./sdriver.pl -t trace11.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace11.txt - Forward SIGINT to every process in foreground process group</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./mysplit 4</span><br><span class="line">Job [1] (7419) terminated by signal 2</span><br><span class="line">tsh&gt; /bin/ps a</span><br><span class="line">  PID TTY      STAT   TIME COMMAND</span><br><span class="line"> 1190 tty4     Ss+    0:00 /sbin/getty -8 38400 tty4</span><br><span class="line"> 1197 tty5     Ss+    0:00 /sbin/getty -8 38400 tty5</span><br><span class="line"> 1207 tty2     Ss+    0:00 /sbin/getty -8 38400 tty2</span><br><span class="line"> 1209 tty3     Ss+    0:00 /sbin/getty -8 38400 tty3</span><br><span class="line"> 1230 tty6     Ss+    0:00 /sbin/getty -8 38400 tty6</span><br><span class="line"> 1352 tty7     Ss+   23:36 /usr/bin/X :0 -auth /var/run/lightdm/root/:0 -nolisten tcp vt7 -novtswitch -background none</span><br><span class="line"> 1785 tty1     Ss+    0:00 /sbin/getty -8 38400 tty1</span><br><span class="line"> 6865 pts/0    Ss     0:00 bash</span><br><span class="line"> 6971 pts/1    Ss+    0:00 /bin/bash</span><br><span class="line"> 7255 pts/0    R     39:18 ./tsh -p</span><br><span class="line"> 7256 pts/0    Z      0:00 [<span class="built_in">echo</span>] &lt;defunct&gt;</span><br><span class="line"> 7414 pts/0    S+     0:00 make rtest11</span><br><span class="line"> 7415 pts/0    S+     0:00 /bin/sh -c ./sdriver.pl -t trace11.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"> 7416 pts/0    S+     0:00 /usr/bin/perl ./sdriver.pl -t trace11.txt -s ./tshref -a -p</span><br><span class="line"> 7417 pts/0    S+     0:00 ./tshref -p</span><br><span class="line"> 7422 pts/0    R      0:00 /bin/ps a</span><br><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make test11</span><br><span class="line">./sdriver.pl -t trace11.txt -s ./tsh -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace11.txt - Forward SIGINT to every process in foreground process group</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./mysplit 4</span><br><span class="line">Job [1] (7433) terminated by signal 2</span><br><span class="line">tsh&gt; /bin/ps a</span><br><span class="line">  PID TTY      STAT   TIME COMMAND</span><br><span class="line"> 1190 tty4     Ss+    0:00 /sbin/getty -8 38400 tty4</span><br><span class="line"> 1197 tty5     Ss+    0:00 /sbin/getty -8 38400 tty5</span><br><span class="line"> 1207 tty2     Ss+    0:00 /sbin/getty -8 38400 tty2</span><br><span class="line"> 1209 tty3     Ss+    0:00 /sbin/getty -8 38400 tty3</span><br><span class="line"> 1230 tty6     Ss+    0:00 /sbin/getty -8 38400 tty6</span><br><span class="line"> 1352 tty7     Ss+   23:37 /usr/bin/X :0 -auth /var/run/lightdm/root/:0 -nolisten tcp vt7 -novtswitch -background none</span><br><span class="line"> 1785 tty1     Ss+    0:00 /sbin/getty -8 38400 tty1</span><br><span class="line"> 6865 pts/0    Ss     0:00 bash</span><br><span class="line"> 6971 pts/1    Ss+    0:00 /bin/bash</span><br><span class="line"> 7255 pts/0    R     39:26 ./tsh -p</span><br><span class="line"> 7256 pts/0    Z      0:00 [<span class="built_in">echo</span>] &lt;defunct&gt;</span><br><span class="line"> 7428 pts/0    S+     0:00 make test11</span><br><span class="line"> 7429 pts/0    S+     0:00 /bin/sh -c ./sdriver.pl -t trace11.txt -s ./tsh -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"> 7430 pts/0    S+     0:00 /usr/bin/perl ./sdriver.pl -t trace11.txt -s ./tsh -a -p</span><br><span class="line"> 7431 pts/0    R+     0:02 ./tsh -p</span><br><span class="line"> 7436 pts/0    R      0:00 /bin/ps a</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>test12</strong>和<strong>test13</strong>略（答案太长了）</li>
</ul>
<h3 id="test14"><a href="#test14" class="headerlink" title="test14"></a>test14</h3><p>这个测试需要对<code>fg</code>和<code>bg</code>的输入参数进行一些错误处理。例如没有参数或参数非数值或所选任务或进程不存在等。修改<code>do_bgfg</code>函数如。（/<em> ADD PART </em>/带有这个标签的就是增加的功能）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * do_bgfg - Execute the builtin bg and fg commands</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_bgfg</span><span class="params">(<span class="type">char</span>** argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">job_t</span>* <span class="title">job</span>;</span></span><br><span class="line">    <span class="type">char</span>* id = argv[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ADD PART bg和fg后边不跟任何参数不执行直接返回 */</span></span><br><span class="line">    <span class="comment">// no argument for bg/fg</span></span><br><span class="line">    <span class="keyword">if</span> (id == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s command requires PID or %%jobid argument\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 判断输入的是jid还是pid</span></span><br><span class="line">    <span class="keyword">if</span> (id[<span class="number">0</span>] == <span class="string">&#x27;%&#x27;</span>) &#123; <span class="comment">/* jid */</span></span><br><span class="line">        <span class="comment">/* ADD PART 检查输入的jid是不是数字 */</span></span><br><span class="line">        <span class="keyword">if</span> (!checkNum(id + <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s: argument must be a PID or %%jobid\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//去掉&#x27;%&#x27;开始读jid，根据jid返回这个子进程的结构指针</span></span><br><span class="line">        <span class="type">int</span> jid = atoi(id + <span class="number">1</span>);</span><br><span class="line">        job = getjobjid(jobs, jid);</span><br><span class="line">        <span class="comment">/* ADD PART 找不到输入的这个作业 */</span></span><br><span class="line">        <span class="keyword">if</span> (job == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%%%d: No such job\n&quot;</span>, jid);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;              <span class="comment">/* pid */</span></span><br><span class="line">        <span class="comment">/* ADD PART  检查输入的pid是不是数字 */</span></span><br><span class="line">        <span class="keyword">if</span> (!checkNum(id)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s: argument must be a PID or %%jobid\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> pid = atoi(id);</span><br><span class="line">        job = getjobpid(jobs, pid);</span><br><span class="line">        <span class="comment">/* ADD PART 找不到这个作业 */</span></span><br><span class="line">        <span class="keyword">if</span> (job == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;(%d): No such process\n&quot;</span>, pid);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    * kill不单是杀掉进程，还有发送信号的功能 </span></span><br><span class="line"><span class="comment">    * 这里唤醒job所在的组中的所有进程</span></span><br><span class="line"><span class="comment">    * 就是唤醒这个stopped的子进程，以及它派生的孙子进程</span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">    kill(-(job-&gt;pid), SIGCONT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;fg&quot;</span>)) &#123;  <span class="comment">// fg command</span></span><br><span class="line">        job-&gt;state = FG;</span><br><span class="line">        <span class="comment">// 等待该前台作业终止</span></span><br><span class="line">        waitfg(job-&gt;pid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;                         <span class="comment">// bg command</span></span><br><span class="line">        job-&gt;state = BG;</span><br><span class="line">        <span class="comment">/* 切换到bg后打印作业信息 */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%d] (%d) %s&quot;</span>, pid2jid(job-&gt;pid), job-&gt;pid, job-&gt;cmdline);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查看参考输出</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest14</span><br><span class="line">./sdriver.pl -t trace14.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace14.txt - Simple error handling</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./bogus</span><br><span class="line">./bogus: Command not found</span><br><span class="line">tsh&gt; ./myspin 4 &amp;</span><br><span class="line">[1] (7521) ./myspin 4 &amp;</span><br><span class="line">tsh&gt; <span class="built_in">fg</span></span><br><span class="line"><span class="built_in">fg</span> <span class="built_in">command</span> requires PID or %jobid argument</span><br><span class="line">tsh&gt; <span class="built_in">bg</span></span><br><span class="line"><span class="built_in">bg</span> <span class="built_in">command</span> requires PID or %jobid argument</span><br><span class="line">tsh&gt; <span class="built_in">fg</span> a</span><br><span class="line"><span class="built_in">fg</span>: argument must be a PID or %jobid</span><br><span class="line">tsh&gt; <span class="built_in">bg</span> a</span><br><span class="line"><span class="built_in">bg</span>: argument must be a PID or %jobid</span><br><span class="line">tsh&gt; <span class="built_in">fg</span> 9999999</span><br><span class="line">(9999999): No such process</span><br><span class="line">tsh&gt; <span class="built_in">bg</span> 9999999</span><br><span class="line">(9999999): No such process</span><br><span class="line">tsh&gt; <span class="built_in">fg</span> %2</span><br><span class="line">%2: No such job</span><br><span class="line">tsh&gt; <span class="built_in">fg</span> %1</span><br><span class="line">Job [1] (7521) stopped by signal 20</span><br><span class="line">tsh&gt; <span class="built_in">bg</span> %2</span><br><span class="line">%2: No such job</span><br><span class="line">tsh&gt; <span class="built_in">bg</span> %1</span><br><span class="line">[1] (7521) ./myspin 4 &amp;</span><br><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br><span class="line">[1] (7521) Running ./myspin 4 &amp;</span><br><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make test14</span><br><span class="line">./sdriver.pl -t trace14.txt -s ./tsh -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace14.txt - Simple error handling</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./bogus</span><br><span class="line">tsh&gt; ./myspin 4 &amp;</span><br><span class="line">[1] (7540) ./myspin 4 &amp;</span><br><span class="line">tsh&gt; <span class="built_in">fg</span></span><br><span class="line"><span class="built_in">fg</span> <span class="built_in">command</span> requires PID or %jobid argument</span><br><span class="line">tsh&gt; <span class="built_in">bg</span></span><br><span class="line"><span class="built_in">bg</span> <span class="built_in">command</span> requires PID or %jobid argument</span><br><span class="line">tsh&gt; <span class="built_in">fg</span> a</span><br><span class="line"><span class="built_in">fg</span>: argument must be a PID or %jobid</span><br><span class="line">tsh&gt; <span class="built_in">bg</span> a</span><br><span class="line"><span class="built_in">bg</span>: argument must be a PID or %jobid</span><br><span class="line">tsh&gt; <span class="built_in">fg</span> 9999999</span><br><span class="line">(9999999): No such process</span><br><span class="line">tsh&gt; <span class="built_in">bg</span> 9999999</span><br><span class="line">(9999999): No such process</span><br><span class="line">tsh&gt; <span class="built_in">fg</span> %2</span><br><span class="line">%2: No such job</span><br><span class="line">tsh&gt; <span class="built_in">fg</span> %1</span><br><span class="line">Job [1] (7540) stopped by signal 20</span><br><span class="line">tsh&gt; <span class="built_in">bg</span> %2</span><br><span class="line">%2: No such job</span><br><span class="line">tsh&gt; <span class="built_in">bg</span> %1</span><br><span class="line">[1] (7540) ./myspin 4 &amp;</span><br><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br><span class="line">[1] (7540) Running ./myspin 4 &amp;</span><br></pre></td></tr></table></figure>
<p>对于输入的不合法的pid不是数字（例如44行）或者没有没有参数（42行）或者单纯没有这个pid（48行），都会进行处理并返回而不是崩溃。这个功能的晚上增强了<em>shell</em>的鲁棒性。</p>
<p>和参考基本一致，通关~</p>
<h3 id="test15-amp-test16"><a href="#test15-amp-test16" class="headerlink" title="test15 &amp; test16"></a>test15 &amp; test16</h3><p>我们看看测试的要求</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest15</span><br><span class="line">./sdriver.pl -t trace15.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace15.txt - Putting it all together</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure>
<p>测试15是要我们把所有的方法放在一起。这个都不要做，本来就在一个文件<code>tsh.c</code>下写的。。。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest16</span><br><span class="line">./sdriver.pl -t trace16.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace16.txt - Tests whether the shell can handle SIGTSTP and SIGINT</span></span><br><span class="line"><span class="comment">#     signals that come from other processes instead of the terminal.</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure>
<p>这个测试要我们测试<em>shell</em>收到SIGINT或者SIGTSTP的来源不是中断而是其他进程是否仍然能够正常工作。这个也不需要做什么。原因有二</p>
<ul>
<li>我们前面的<code>make testn</code>的时候，就是把我们的<code>tsh</code>作为<code>shell driver</code>的子进程，然后驱动给我们的<code>tsh</code>发送测试指令。其中就有SIGINT和SIGTSTP，我们能过够通过前面的，肯定是对的。</li>
<li>我们的<code>tsh</code>至始至终实现对的都是收到信号，然后对自己的孩子怎么处理。至于如何接受外部信号，是从中断收到还是其他的进程收到，我们实验过程中虽然没有关注到。但是我们在从unix的<em>shell</em>输入“./tsh”之后进入到<em>tsh</em>。<ul>
<li>这个过程是内核捕捉到SIGINT等信号发送给我们的unix shell，然后unix shell会把这些信号有发送给tsh，然后tsh又把它发送给子进程们。</li>
<li>关系如下图。</li>
</ul>
</li>
</ul>
<p><img src="/2022/05/26/CSAPP-shlab-report/image-20220526221432408.png" alt="image-20220526221432408" style="zoom:80%;"></p>
<p>还有一个小知识点：参考<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/5422831/what-is-the-difference-between-using-exit-exit-in-a-conventional-linux-fo">exit与_exit的区别</a>，可以知道<strong>在fork出的child中要用_exit来退出</strong>，否则exit会调用用atexit注册的函数并刷新父进程的缓冲区。一般来说在一个main函数中只调用一次exit或return。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in `eval`</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">/* </span></span><br><span class="line"><span class="comment">            * 前台执行 </span></span><br><span class="line"><span class="comment">            * 如果没有这个可执行程序，那么直接终止这个子进程</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">if</span> (execve(argv[<span class="number">0</span>], argv, environ) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s: Command not found.\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">                _exit(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>
<h3 id="tsh-c文件综合"><a href="#tsh-c文件综合" class="headerlink" title="tsh.c文件综合"></a>tsh.c文件综合</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * tsh - A tiny shell program with job control</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;Puitar&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Misc manifest constants */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLINE    1024   <span class="comment">/* max line size */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXARGS     128   <span class="comment">/* max args on a command line */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXJOBS      16   <span class="comment">/* max jobs at any point in time */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXJID    1&lt;&lt;16   <span class="comment">/* max job ID */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Job states */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNDEF 0 <span class="comment">/* undefined */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FG 1    <span class="comment">/* running in foreground */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BG 2    <span class="comment">/* running in background */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ST 3    <span class="comment">/* stopped */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Jobs states: FG (foreground), BG (background), ST (stopped)</span></span><br><span class="line"><span class="comment"> * Job state transitions and enabling actions:</span></span><br><span class="line"><span class="comment"> *     FG -&gt; ST  : ctrl-z</span></span><br><span class="line"><span class="comment"> *     ST -&gt; FG  : fg command</span></span><br><span class="line"><span class="comment"> *     ST -&gt; BG  : bg command</span></span><br><span class="line"><span class="comment"> *     BG -&gt; FG  : fg command</span></span><br><span class="line"><span class="comment"> * At most 1 job can be in the FG state.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Global variables */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span>** environ;      <span class="comment">/* defined in libc */</span></span><br><span class="line"><span class="type">char</span> prompt[] = <span class="string">&quot;tsh&gt; &quot;</span>;    <span class="comment">/* command line prompt (DO NOT CHANGE) */</span></span><br><span class="line"><span class="type">int</span> verbose = <span class="number">0</span>;            <span class="comment">/* if true, print additional output */</span></span><br><span class="line"><span class="type">int</span> nextjid = <span class="number">1</span>;            <span class="comment">/* next job ID to allocate */</span></span><br><span class="line"><span class="type">char</span> sbuf[MAXLINE];         <span class="comment">/* for composing sprintf messages */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> &#123;</span>              <span class="comment">/* The job struct */</span></span><br><span class="line">    <span class="type">pid_t</span> pid;              <span class="comment">/* job PID */</span></span><br><span class="line">    <span class="type">int</span> jid;                <span class="comment">/* job ID [1, 2, ...] */</span></span><br><span class="line">    <span class="type">int</span> state;              <span class="comment">/* UNDEF, BG, FG, or ST */</span></span><br><span class="line">    <span class="type">char</span> cmdline[MAXLINE];  <span class="comment">/* command line */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> <span class="title">jobs</span>[<span class="title">MAXJOBS</span>];</span> <span class="comment">/* The job list */</span></span><br><span class="line"><span class="comment">/* End global variables */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Function prototypes */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Here are the functions that you will implement */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">eval</span><span class="params">(<span class="type">char</span>* cmdline)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">builtin_cmd</span><span class="params">(<span class="type">char</span>** argv)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">do_bgfg</span><span class="params">(<span class="type">char</span>** argv)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">waitfg</span><span class="params">(<span class="type">pid_t</span> pid)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sigchld_handler</span><span class="params">(<span class="type">int</span> sig)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sigtstp_handler</span><span class="params">(<span class="type">int</span> sig)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sigint_handler</span><span class="params">(<span class="type">int</span> sig)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Here are helper routines that we&#x27;ve provided for you */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">parseline</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* cmdline, <span class="type">char</span>** argv)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sigquit_handler</span><span class="params">(<span class="type">int</span> sig)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">clearjob</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span>* job)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">initjobs</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span>* jobs)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">maxjid</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span>* jobs)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">addjob</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span>* jobs, <span class="type">pid_t</span> pid, <span class="type">int</span> state, <span class="type">char</span>* cmdline)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">deletejob</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span>* jobs, <span class="type">pid_t</span> pid)</span>;</span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fgpid</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span>* jobs)</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="type">job_t</span>* <span class="title function_">getjobpid</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span>* jobs, <span class="type">pid_t</span> pid)</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="type">job_t</span>* <span class="title function_">getjobjid</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span>* jobs, <span class="type">int</span> jid)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pid2jid</span><span class="params">(<span class="type">pid_t</span> pid)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">listjobs</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span>* jobs)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">usage</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">unix_error</span><span class="params">(<span class="type">char</span>* msg)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">app_error</span><span class="params">(<span class="type">char</span>* msg)</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> <span class="title function_">handler_t</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">handler_t</span>* <span class="title function_">Signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">handler_t</span>* handler)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// wrapper functions get from csapp.h</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Sigprocmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span>* <span class="built_in">set</span>, <span class="type">sigset_t</span>* oldset)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Sigemptyset</span><span class="params">(<span class="type">sigset_t</span>* <span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Sigaddset</span><span class="params">(<span class="type">sigset_t</span>* <span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sio package declaration from csapp.h</span></span><br><span class="line"><span class="comment">/* Sio (Signal-safe I/O) routines */</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">sio_puts</span><span class="params">(<span class="type">char</span> s[])</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">sio_putl</span><span class="params">(<span class="type">long</span> v)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sio_error</span><span class="params">(<span class="type">char</span> s[])</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Sio wrappers */</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">Sio_puts</span><span class="params">(<span class="type">char</span> s[])</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">Sio_putl</span><span class="params">(<span class="type">long</span> v)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Sio_error</span><span class="params">(<span class="type">char</span> s[])</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * main - The shell&#x27;s main routine</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">char</span> cmdline[MAXLINE];</span><br><span class="line">    <span class="type">int</span> emit_prompt = <span class="number">1</span>; <span class="comment">/* emit prompt (default) */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Redirect stderr to stdout (so that driver will get all output</span></span><br><span class="line"><span class="comment">     * on the pipe connected to stdout) */</span></span><br><span class="line">    dup2(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Parse the command line */</span></span><br><span class="line">    <span class="keyword">while</span> ((c = getopt(argc, argv, <span class="string">&quot;hvp&quot;</span>)) != EOF) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:             <span class="comment">/* print help message */</span></span><br><span class="line">                usage();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;v&#x27;</span>:             <span class="comment">/* emit additional diagnostic info */</span></span><br><span class="line">                verbose = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;p&#x27;</span>:             <span class="comment">/* don&#x27;t print a prompt */</span></span><br><span class="line">                emit_prompt = <span class="number">0</span>;  <span class="comment">/* handy for automatic testing */</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                usage();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Install the signal handlers */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* These are the ones you will need to implement */</span></span><br><span class="line">    Signal(SIGINT, sigint_handler);   <span class="comment">/* ctrl-c */</span></span><br><span class="line">    Signal(SIGTSTP, sigtstp_handler);  <span class="comment">/* ctrl-z */</span></span><br><span class="line">    Signal(SIGCHLD, sigchld_handler);  <span class="comment">/* Terminated or stopped child */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This one provides a clean way to kill the shell */</span></span><br><span class="line">    Signal(SIGQUIT, sigquit_handler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initialize the job list */</span></span><br><span class="line">    initjobs(jobs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Execute the shell&#x27;s read/eval loop */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Read command line */</span></span><br><span class="line">        <span class="keyword">if</span> (emit_prompt) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, prompt);</span><br><span class="line">            fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((fgets(cmdline, MAXLINE, <span class="built_in">stdin</span>) == <span class="literal">NULL</span>) &amp;&amp; ferror(<span class="built_in">stdin</span>))</span><br><span class="line">            app_error(<span class="string">&quot;fgets error&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (feof(<span class="built_in">stdin</span>)) &#123; <span class="comment">/* End of file (ctrl-d) */</span></span><br><span class="line">            fflush(<span class="built_in">stdout</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Evaluate the command line */</span></span><br><span class="line">        eval(cmdline);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">/* control never reaches here */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * eval - Evaluate the command line that the user has just typed in</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If the user has requested a built-in command (quit, jobs, bg or fg)</span></span><br><span class="line"><span class="comment"> * then execute it immediately. Otherwise, fork a child process and</span></span><br><span class="line"><span class="comment"> * run the job in the context of the child. If the job is running in</span></span><br><span class="line"><span class="comment"> * the foreground, wait for it to terminate and then return.  Note:</span></span><br><span class="line"><span class="comment"> * each child process must have a unique process group ID so that our</span></span><br><span class="line"><span class="comment"> * background children don&#x27;t receive SIGINT (SIGTSTP) from the kernel</span></span><br><span class="line"><span class="comment"> * when we type ctrl-c (ctrl-z) at the keyboard.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">eval</span><span class="params">(<span class="type">char</span>* cmdline)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>* argv[MAXARGS]; <span class="comment">/* argv for execve() */</span></span><br><span class="line">    <span class="type">int</span> bg;              <span class="comment">/* Should the job run in bg or fg? */</span></span><br><span class="line">    <span class="type">pid_t</span> pid;           <span class="comment">/* Process id */</span></span><br><span class="line">    <span class="type">sigset_t</span> mask, prev;</span><br><span class="line"></span><br><span class="line">    bg = parseline(cmdline, argv);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (argv[<span class="number">0</span>] == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;   <span class="comment">/* Ignore empty lines */</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 这里参考课本520的方法</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * sigemptyset是设置一个信号集</span></span><br><span class="line"><span class="comment">    * sigaddset是向mask中添加SIGCHLD信号</span></span><br><span class="line"><span class="comment">    * sigprocmask是保存现在的信号集到prev然后根据第一个参数设置信号集为mask</span></span><br><span class="line"><span class="comment">    *	第二个参数设置成当前阻塞信号集合</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    Sigemptyset(&amp;mask);</span><br><span class="line">    Sigaddset(&amp;mask, SIGCHLD);</span><br><span class="line">	</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!builtin_cmd(argv)) &#123;</span><br><span class="line">        Sigprocmask(SIG_BLOCK, &amp;mask, &amp;prev);  <span class="comment">/* 阻塞SIGCHLD */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((pid = fork()) == <span class="number">0</span>) &#123;   <span class="comment">/* Child runs user job */</span></span><br><span class="line">            <span class="comment">/* 给fork出来的子进程设置一个独立的组，</span></span><br><span class="line"><span class="comment">	 		 * 子进程是这个组的组长,组id为子进程的pid */</span></span><br><span class="line">            setpgid(<span class="number">0</span>, <span class="number">0</span>);	</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/* 对于子进程并不需要阻塞SIGCHLD的信号 */</span></span><br><span class="line">            Sigprocmask(SIG_UNBLOCK, &amp;prev, <span class="literal">NULL</span>);  <span class="comment">// unblock SIGCHLD</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">/* </span></span><br><span class="line"><span class="comment">            * 前台执行 </span></span><br><span class="line"><span class="comment">            * 如果没有这个可执行程序，那么直接终止这个子进程</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">if</span> (execve(argv[<span class="number">0</span>], argv, environ) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s: Command not found.\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">                _exit(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        addjob(jobs, pid, bg ? BG : FG, cmdline);</span><br><span class="line">        <span class="comment">/* 已经加到jobs了，解除阻塞 */</span></span><br><span class="line">        Sigprocmask(SIG_SETMASK, &amp;prev, <span class="literal">NULL</span>);  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Parent waits for foreground job to terminate */</span></span><br><span class="line">        <span class="keyword">if</span> (!bg)  <span class="comment">// 前台运行则等待子进程</span></span><br><span class="line">            waitfg(pid);</span><br><span class="line">        <span class="keyword">else</span>      <span class="comment">// background</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[%d] (%d) %s&quot;</span>, pid2jid(pid), pid, cmdline);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * parseline - Parse the command line and build the argv array.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Characters enclosed in single quotes are treated as a single</span></span><br><span class="line"><span class="comment"> * argument.  Return true if the user has requested a BG job, false if</span></span><br><span class="line"><span class="comment"> * the user has requested a FG job.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">parseline</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* cmdline, <span class="type">char</span>** argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> <span class="built_in">array</span>[MAXLINE]; <span class="comment">/* holds local copy of command line */</span></span><br><span class="line">    <span class="type">char</span>* buf = <span class="built_in">array</span>;          <span class="comment">/* ptr that traverses command line */</span></span><br><span class="line">    <span class="type">char</span>* delim;                <span class="comment">/* points to first space delimiter */</span></span><br><span class="line">    <span class="type">int</span> argc;                   <span class="comment">/* number of args */</span></span><br><span class="line">    <span class="type">int</span> bg;                     <span class="comment">/* background job? */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(buf, cmdline);</span><br><span class="line">    buf[<span class="built_in">strlen</span>(buf) - <span class="number">1</span>] = <span class="string">&#x27; &#x27;</span>;  <span class="comment">/* replace trailing &#x27;\n&#x27; with space */</span></span><br><span class="line">    <span class="keyword">while</span> (*buf &amp;&amp; (*buf == <span class="string">&#x27; &#x27;</span>)) <span class="comment">/* ignore leading spaces */</span></span><br><span class="line">        buf++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Build the argv list */</span></span><br><span class="line">    argc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (*buf == <span class="string">&#x27;\&#x27;&#x27;</span>) &#123;</span><br><span class="line">        buf++;</span><br><span class="line">        delim = <span class="built_in">strchr</span>(buf, <span class="string">&#x27;\&#x27;&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        delim = <span class="built_in">strchr</span>(buf, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (delim) &#123;</span><br><span class="line">        argv[argc++] = buf;</span><br><span class="line">        *delim = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        buf = delim + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (*buf &amp;&amp; (*buf == <span class="string">&#x27; &#x27;</span>)) <span class="comment">/* ignore spaces */</span></span><br><span class="line">            buf++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (*buf == <span class="string">&#x27;\&#x27;&#x27;</span>) &#123;</span><br><span class="line">            buf++;</span><br><span class="line">            delim = <span class="built_in">strchr</span>(buf, <span class="string">&#x27;\&#x27;&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            delim = <span class="built_in">strchr</span>(buf, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    argv[argc] = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">0</span>)  <span class="comment">/* ignore blank line */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* should the job run in the background? */</span></span><br><span class="line">    <span class="keyword">if</span> ((bg = (*argv[argc - <span class="number">1</span>] == <span class="string">&#x27;&amp;&#x27;</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">        argv[--argc] = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * builtin_cmd - If the user has typed a built-in command then execute</span></span><br><span class="line"><span class="comment"> *    it immediately.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">builtin_cmd</span><span class="params">(<span class="type">char</span>** argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// quit command</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;quit&quot;</span>))</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// jobs command</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;jobs&quot;</span>)) &#123;</span><br><span class="line">        listjobs(jobs);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bg or fg command</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;bg&quot;</span>) || !<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;fg&quot;</span>)) &#123;</span><br><span class="line">        do_bgfg(argv);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ignore singleton &amp; (不处理单独的 &#x27;&amp;&#x27;)</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;&amp;&quot;</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// not a build-in command</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// check if arg is a string of nums</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">checkNum</span><span class="params">(<span class="type">char</span>* arg)</span> &#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(arg);</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">isdigit</span>(arg[i])) <span class="comment">// not num</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * do_bgfg - Execute the builtin bg and fg commands</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_bgfg</span><span class="params">(<span class="type">char</span>** argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">job_t</span>* <span class="title">job</span>;</span></span><br><span class="line">    <span class="type">char</span>* id = argv[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// no argument for bg/fg</span></span><br><span class="line">    <span class="keyword">if</span> (id == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s command requires PID or %%jobid argument\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 判断输入的是jid还是pid</span></span><br><span class="line">    <span class="keyword">if</span> (id[<span class="number">0</span>] == <span class="string">&#x27;%&#x27;</span>) &#123; <span class="comment">/* jid */</span></span><br><span class="line">        <span class="keyword">if</span> (!checkNum(id + <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s: argument must be a PID or %%jobid\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//去掉&#x27;%&#x27;开始读jid，根据jid返回这个子进程的结构指针</span></span><br><span class="line">        <span class="type">int</span> jid = atoi(id + <span class="number">1</span>);</span><br><span class="line">        job = getjobjid(jobs, jid);</span><br><span class="line">        <span class="keyword">if</span> (job == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%%%d: No such job\n&quot;</span>, jid);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;              <span class="comment">/* pid */</span></span><br><span class="line">        <span class="keyword">if</span> (!checkNum(id)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s: argument must be a PID or %%jobid\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> pid = atoi(id);</span><br><span class="line">        job = getjobpid(jobs, pid);</span><br><span class="line">        <span class="keyword">if</span> (job == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;(%d): No such process\n&quot;</span>, pid);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    * kill不单是杀掉进程，还有发送信号的功能 </span></span><br><span class="line"><span class="comment">    * 这里唤醒job所在的组中的所有进程</span></span><br><span class="line"><span class="comment">    * 就是唤醒这个stopped的子进程，以及它派生的孙子进程</span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">    kill(-(job-&gt;pid), SIGCONT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;fg&quot;</span>)) &#123;  <span class="comment">// fg command</span></span><br><span class="line">        job-&gt;state = FG;</span><br><span class="line">        <span class="comment">// 等待该前台作业终止</span></span><br><span class="line">        waitfg(job-&gt;pid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;                         <span class="comment">// bg command</span></span><br><span class="line">        job-&gt;state = BG;</span><br><span class="line">        <span class="comment">/* 切换到bg后打印作业信息 */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%d] (%d) %s&quot;</span>, pid2jid(job-&gt;pid), job-&gt;pid, job-&gt;cmdline);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * waitfg - Block until process pid is no longer the foreground process</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">waitfg</span><span class="params">(<span class="type">pid_t</span> pid)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (pid == fgpid(jobs))</span><br><span class="line">        sleep(<span class="number">0</span>); <span class="comment">// 这里是主动让出CPU</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*****************</span></span><br><span class="line"><span class="comment"> * Signal handlers</span></span><br><span class="line"><span class="comment"> *****************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sigchld_handler - The kernel sends a SIGCHLD to the shell whenever</span></span><br><span class="line"><span class="comment"> *     a child job terminates (becomes a zombie), or stops because it</span></span><br><span class="line"><span class="comment"> *     received a SIGSTOP or SIGTSTP signal. The handler reaps all</span></span><br><span class="line"><span class="comment"> *     available zombie children, but doesn&#x27;t wait for any other</span></span><br><span class="line"><span class="comment"> *     currently running children to terminate.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sigchld_handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> old_errno = errno;</span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (verbose)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sigchld_handler: entering \n&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* </span></span><br><span class="line"><span class="comment">    * 回收僵尸进程</span></span><br><span class="line"><span class="comment">    * 这里的WNOHANG是非常重要的。</span></span><br><span class="line"><span class="comment">    * 它的本意是如果所有孩子都没有僵尸(终止)状态的，直接退出</span></span><br><span class="line"><span class="comment">    * 这个能够避免在这里等待所有前台的running和stopped程序终止</span></span><br><span class="line"><span class="comment">    * 这样tsh就不能正常接受用户的输入了</span></span><br><span class="line"><span class="comment">    * WUNTRACED是等待直到有一个子进程变成僵尸退出，返回它的pid</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">while</span> ((pid = waitpid(<span class="number">-1</span>, &amp;status, WNOHANG | WUNTRACED)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程正常退出</span></span><br><span class="line">        <span class="keyword">if</span> (WIFEXITED(status)) &#123;</span><br><span class="line">            deletejob(jobs, pid);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 子进程因为ctrl-c退出</span></span><br><span class="line">        <span class="keyword">if</span> (WIFSIGNALED(status)) &#123; <span class="comment">// terminated by ctrl-c</span></span><br><span class="line">            <span class="comment">/* printf(&quot;Job [%d] (%d) terminated by signal %2d\n&quot;, </span></span><br><span class="line"><span class="comment">                   pid2jid(pid), pid, WTERMSIG(status)); */</span> &#123;</span><br><span class="line">            	Sio_puts(<span class="string">&quot;Job [&quot;</span>);</span><br><span class="line">                Sio_putl(pid2jid(pid));</span><br><span class="line">                Sio_puts(<span class="string">&quot;] (&quot;</span>);</span><br><span class="line">                Sio_putl(pid);</span><br><span class="line">                Sio_puts(<span class="string">&quot;) terminated by signal &quot;</span>);</span><br><span class="line">                Sio_putl(WTERMSIG(status));</span><br><span class="line">                Sio_puts(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            deletejob(jobs, pid); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (WIFSTOPPED(status)) &#123; <span class="comment">// stopped by ctrl-z</span></span><br><span class="line">            <span class="comment">/* printf(&quot;Job [%d] (%d) stopped by signal %2d\n&quot;,</span></span><br><span class="line"><span class="comment">                   pid2jid(pid), pid, WSTOPSIG(status)); */</span> &#123;</span><br><span class="line">            	Sio_puts(<span class="string">&quot;Job [&quot;</span>);</span><br><span class="line">                Sio_putl(pid2jid(pid));</span><br><span class="line">                Sio_puts(<span class="string">&quot;] (&quot;</span>);</span><br><span class="line">                Sio_putl(pid);</span><br><span class="line">                Sio_puts(<span class="string">&quot;) stopped by signal &quot;</span>);</span><br><span class="line">                Sio_putl(WSTOPSIG(status));</span><br><span class="line">                Sio_puts(<span class="string">&quot;\n&quot;</span>);           </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 修改子进程状态为ST</span></span><br><span class="line">            getjobpid(jobs, pid)-&gt;state = ST;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    errno = old_errno;</span><br><span class="line">    <span class="keyword">if</span> (verbose) &#123;</span><br><span class="line">        <span class="comment">/* printf(&quot;sigchld_handler: exiting\n&quot;); */</span> &#123;</span><br><span class="line">        	Sio_puts(<span class="string">&quot;sigchld_handler: exiting\n&quot;</span>);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;      </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sigint_handler - The kernel sends a SIGINT to the shell whenver the</span></span><br><span class="line"><span class="comment"> *    user types ctrl-c at the keyboard.  Catch it and send it along</span></span><br><span class="line"><span class="comment"> *    to the foreground job.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sigint_handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> olderrno = errno;</span><br><span class="line">    <span class="comment">// get the foreground job pid</span></span><br><span class="line">    <span class="type">pid_t</span> fg_pid = fgpid(jobs);</span><br><span class="line">    <span class="comment">// kill the group in the foreground</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * int kill(pid_t pid,int signo)</span></span><br><span class="line"><span class="comment"> 	* 功能: 向进程或进程组发送一个信号 （成功返回 0； 否则，返回 -1 ）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    kill(-fg_pid, sig); </span><br><span class="line">    <span class="comment">// -fg_pid表示向进程组号为pid的组中的每个进程发sig信号</span></span><br><span class="line">    <span class="comment">// 在这里就是向前台进程以及它的每一个子进程(子进程都在自己的父进程的pid为组id的组下)</span></span><br><span class="line">    errno = olderrno;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sigtstp_handler - The kernel sends a SIGTSTP to the shell whenever</span></span><br><span class="line"><span class="comment"> *     the user types ctrl-z at the keyboard. Catch it and suspend the</span></span><br><span class="line"><span class="comment"> *     foreground job by sending it a SIGTSTP.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sigtstp_handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 为了异步信号安全防止errno被覆盖</span></span><br><span class="line">    <span class="type">int</span> olderrno = errno;</span><br><span class="line">    <span class="comment">// get the foreground job pid</span></span><br><span class="line">    <span class="type">pid_t</span> fg_pid = fgpid(jobs);</span><br><span class="line">    <span class="comment">// kill the group in the foreground</span></span><br><span class="line">    kill(-fg_pid, sig);</span><br><span class="line">    errno = olderrno;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********************</span></span><br><span class="line"><span class="comment"> * End signal handlers</span></span><br><span class="line"><span class="comment"> *********************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************************************</span></span><br><span class="line"><span class="comment">  * Helper routines that manipulate the job list</span></span><br><span class="line"><span class="comment">  **********************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* clearjob - Clear the entries in a job struct */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">clearjob</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span>* job)</span> &#123;</span><br><span class="line">    job-&gt;pid = <span class="number">0</span>;</span><br><span class="line">    job-&gt;jid = <span class="number">0</span>;</span><br><span class="line">    job-&gt;state = UNDEF;</span><br><span class="line">    job-&gt;cmdline[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* initjobs - Initialize the job list */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">initjobs</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span>* jobs)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++)</span><br><span class="line">        clearjob(&amp;jobs[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* maxjid - Returns largest allocated job ID */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">maxjid</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span>* jobs)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, max = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++)</span><br><span class="line">        <span class="keyword">if</span> (jobs[i].jid &gt; max)</span><br><span class="line">            max = jobs[i].jid;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* addjob - Add a job to the job list */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">addjob</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span>* jobs, <span class="type">pid_t</span> pid, <span class="type">int</span> state, <span class="type">char</span>* cmdline)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++) &#123;</span><br><span class="line">        <span class="comment">/* 如果jobs数组里面有pid等于0等于0的表项，表示这个位置可以用，把这个作业放进去 */</span></span><br><span class="line">        <span class="keyword">if</span> (jobs[i].pid == <span class="number">0</span>) &#123;</span><br><span class="line">            jobs[i].pid = pid;</span><br><span class="line">            jobs[i].state = state;</span><br><span class="line">            jobs[i].jid = nextjid++;</span><br><span class="line">            <span class="keyword">if</span> (nextjid &gt; MAXJOBS)</span><br><span class="line">                nextjid = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">strcpy</span>(jobs[i].cmdline, cmdline);</span><br><span class="line">            <span class="keyword">if</span> (verbose) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Added job [%d] %d %s\n&quot;</span>, jobs[i].jid, jobs[i].pid, jobs[i].cmdline);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Tried to create too many jobs\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* deletejob - Delete a job whose PID=pid from the job list */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">deletejob</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span>* jobs, <span class="type">pid_t</span> pid)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (jobs[i].pid == pid) &#123;</span><br><span class="line">            clearjob(&amp;jobs[i]);</span><br><span class="line">            nextjid = maxjid(jobs) + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* fgpid - Return PID of current foreground job, 0 if no such job */</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fgpid</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span>* jobs)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++)</span><br><span class="line">        <span class="keyword">if</span> (jobs[i].state == FG)</span><br><span class="line">            <span class="keyword">return</span> jobs[i].pid;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* getjobpid  - Find a job (by PID) on the job list */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="type">job_t</span>* <span class="title function_">getjobpid</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span>* jobs, <span class="type">pid_t</span> pid)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++)</span><br><span class="line">        <span class="keyword">if</span> (jobs[i].pid == pid)</span><br><span class="line">            <span class="keyword">return</span> &amp;jobs[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* getjobjid  - Find a job (by JID) on the job list */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="type">job_t</span>* <span class="title function_">getjobjid</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span>* jobs, <span class="type">int</span> jid)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (jid &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++)</span><br><span class="line">        <span class="keyword">if</span> (jobs[i].jid == jid)</span><br><span class="line">            <span class="keyword">return</span> &amp;jobs[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* pid2jid - Map process ID to job ID */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pid2jid</span><span class="params">(<span class="type">pid_t</span> pid)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++)</span><br><span class="line">        <span class="keyword">if</span> (jobs[i].pid == pid) &#123;</span><br><span class="line">            <span class="keyword">return</span> jobs[i].jid;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* listjobs - Print the job list */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">listjobs</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span>* jobs)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (jobs[i].pid != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[%d] (%d) &quot;</span>, jobs[i].jid, jobs[i].pid);</span><br><span class="line">            <span class="keyword">switch</span> (jobs[i].state) &#123;</span><br><span class="line">                <span class="keyword">case</span> BG:</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Running &quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> FG:</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Foreground &quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> ST:</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Stopped &quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;listjobs: Internal error: job[%d].state=%d &quot;</span>,</span><br><span class="line">                           i, jobs[i].state);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, jobs[i].cmdline);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment"> * end job list helper routines</span></span><br><span class="line"><span class="comment"> ******************************/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************</span></span><br><span class="line"><span class="comment">  * Other helper routines</span></span><br><span class="line"><span class="comment">  ***********************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   * usage - print a help message</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">usage</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Usage: shell [-hvp]\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;   -h   print this message\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;   -v   print additional diagnostic information\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;   -p   do not emit a command prompt\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * unix_error - unix-style error routine</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">unix_error</span><span class="params">(<span class="type">char</span>* msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;%s: %s\n&quot;</span>, msg, strerror(errno));</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * app_error - application-style error routine</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">app_error</span><span class="params">(<span class="type">char</span>* msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;%s\n&quot;</span>, msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Signal - wrapper for the sigaction function</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">handler_t</span>* <span class="title function_">Signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">handler_t</span>* handler)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">action</span>, <span class="title">old_action</span>;</span></span><br><span class="line"></span><br><span class="line">    action.sa_handler = handler;</span><br><span class="line">    sigemptyset(&amp;action.sa_mask); <span class="comment">/* block sigs of type being handled */</span></span><br><span class="line">    action.sa_flags = SA_RESTART; <span class="comment">/* restart syscalls if possible */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sigaction(signum, &amp;action, &amp;old_action) &lt; <span class="number">0</span>)</span><br><span class="line">        unix_error(<span class="string">&quot;Signal error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> (old_action.sa_handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sigquit_handler - The driver program can gracefully terminate the</span></span><br><span class="line"><span class="comment"> *    child shell by sending it a SIGQUIT signal.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sigquit_handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Terminating after receipt of SIGQUIT signal\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// The following function are from csapp.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment"> * Wrappers for blocking signals</span></span><br><span class="line"><span class="comment"> *************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Sigemptyset</span><span class="params">(<span class="type">sigset_t</span>* <span class="built_in">set</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (sigemptyset(<span class="built_in">set</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        unix_error(<span class="string">&quot;Sigemptyset error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Sigprocmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span>* <span class="built_in">set</span>, <span class="type">sigset_t</span>* oldset)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (sigprocmask(how, <span class="built_in">set</span>, oldset) &lt; <span class="number">0</span>)</span><br><span class="line">        unix_error(<span class="string">&quot;Sigprocmask error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Sigaddset</span><span class="params">(<span class="type">sigset_t</span>* <span class="built_in">set</span>, <span class="type">int</span> signum)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (sigaddset(<span class="built_in">set</span>, signum) &lt; <span class="number">0</span>)</span><br><span class="line">        unix_error(<span class="string">&quot;Sigaddset error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment"> * The Sio (Signal-safe I/O) package - simple reentrant output</span></span><br><span class="line"><span class="comment"> * functions that are safe for signal handlers.</span></span><br><span class="line"><span class="comment"> *************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Private sio functions */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* $begin sioprivate */</span></span><br><span class="line"><span class="comment">/* sio_reverse - Reverse a string (from K&amp;R) */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sio_reverse</span><span class="params">(<span class="type">char</span> s[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> c, i, j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, j = <span class="built_in">strlen</span>(s) - <span class="number">1</span>; i &lt; j; i++, j--) &#123;</span><br><span class="line">        c = s[i];</span><br><span class="line">        s[i] = s[j];</span><br><span class="line">        s[j] = c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* sio_ltoa - Convert long to base b string (from K&amp;R) */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sio_ltoa</span><span class="params">(<span class="type">long</span> v, <span class="type">char</span> s[], <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> c, i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> neg = v &lt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (neg)</span><br><span class="line">        v = -v;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        s[i++] = ((c = (v % b)) &lt; <span class="number">10</span>) ? c + <span class="string">&#x27;0&#x27;</span> : c - <span class="number">10</span> + <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> ((v /= b) &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (neg)</span><br><span class="line">        s[i++] = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    s[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    sio_reverse(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* sio_strlen - Return length of string (from K&amp;R) */</span></span><br><span class="line"><span class="type">static</span> <span class="type">size_t</span> <span class="title function_">sio_strlen</span><span class="params">(<span class="type">char</span> s[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (s[i] != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">        ++i;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* $end sioprivate */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Public Sio functions */</span></span><br><span class="line"><span class="comment">/* $begin siopublic */</span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">sio_puts</span><span class="params">(<span class="type">char</span> s[])</span> <span class="comment">/* Put string */</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> write(STDOUT_FILENO, s, sio_strlen(s)); <span class="comment">//line:csapp:siostrlen</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">sio_putl</span><span class="params">(<span class="type">long</span> v)</span> <span class="comment">/* Put long */</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> s[<span class="number">128</span>];</span><br><span class="line"></span><br><span class="line">    sio_ltoa(v, s, <span class="number">10</span>); <span class="comment">/* Based on K&amp;R itoa() */</span>  <span class="comment">//line:csapp:sioltoa</span></span><br><span class="line">    <span class="keyword">return</span> sio_puts(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sio_error</span><span class="params">(<span class="type">char</span> s[])</span> <span class="comment">/* Put error message and exit */</span></span><br><span class="line">&#123;</span><br><span class="line">    sio_puts(s);</span><br><span class="line">    _exit(<span class="number">1</span>);                                      <span class="comment">//line:csapp:sioexit</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* $end siopublic */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************************</span></span><br><span class="line"><span class="comment"> * Wrappers for the SIO routines</span></span><br><span class="line"><span class="comment"> ******************************/</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">Sio_putl</span><span class="params">(<span class="type">long</span> v)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">ssize_t</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((n = sio_putl(v)) &lt; <span class="number">0</span>)</span><br><span class="line">        sio_error(<span class="string">&quot;Sio_putl error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">Sio_puts</span><span class="params">(<span class="type">char</span> s[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">ssize_t</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((n = sio_puts(s)) &lt; <span class="number">0</span>)</span><br><span class="line">        sio_error(<span class="string">&quot;Sio_puts error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Sio_error</span><span class="params">(<span class="type">char</span> s[])</span></span><br><span class="line">&#123;</span><br><span class="line">    sio_error(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h2><p>通过这次实验，才算是比较彻底理解了，信号的相关知识。</p>
<ul>
<li>包括信号的发送和捕捉</li>
<li>异步的思考方式</li>
<li>信号的阻塞</li>
<li>拓展：异步安全问题</li>
<li>信号处理程序的编写和使用</li>
<li><code>signal</code>函数和<code>kill</code>以及相关的函数的使用等</li>
</ul>
<p>这个是本课程最后一个实验的，综合难度并不是最大的。但是是知识体系最为复杂的。总的来说非常喜欢这门课的实验。做完之后能够感觉到和知识的紧密连接。感谢陪伴~</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://puitar.github.io/2022/05/19/OS-thread-homework/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Puitar">
      <meta itemprop="description" content="博客萌新时不时送来没什么软用的文章">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Puitar's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/19/OS-thread-homework/" class="post-title-link" itemprop="url">OS-thread-homework</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-05-19 22:26:30" itemprop="dateCreated datePublished" datetime="2022-05-19T22:26:30+08:00">2022-05-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-07-14 15:12:04" itemprop="dateModified" datetime="2022-07-14T15:12:04+08:00">2022-07-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/courses-learning/" itemprop="url" rel="index"><span itemprop="name">courses-learning</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/courses-learning/%E5%A4%A7%E4%BA%8C%E4%B8%8B%E6%9C%9F%E6%9C%AB/" itemprop="url" rel="index"><span itemprop="name">大二下期末</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="操作系统第三部分作业"><a href="#操作系统第三部分作业" class="headerlink" title="操作系统第三部分作业"></a>操作系统第三部分作业</h1><h2 id="作业范围"><a href="#作业范围" class="headerlink" title="作业范围"></a>作业范围</h2><ul>
<li>第26章1、2、3、4题</li>
<li>第28章1、2、3、4、5、6、7题</li>
<li>第30章1、2、4、8、9、10、11题</li>
<li>第31章1、2、4、5、6题</li>
</ul>
<h2 id="第26章"><a href="#第26章" class="headerlink" title="第26章"></a>第26章</h2><h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3><p>首先查看这个程序，得到结果如下</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sh&gt; <span class="built_in">cat</span> loop.s</span><br><span class="line"><span class="comment"># 段符号</span></span><br><span class="line">.main</span><br><span class="line">.top</span><br><span class="line"><span class="comment"># 重点看下面这4句</span></span><br><span class="line">sub  <span class="variable">$1</span>,%dx		<span class="comment"># %dx = %dx - 1</span></span><br><span class="line"><span class="built_in">test</span> <span class="variable">$0</span>,%dx		<span class="comment"># %dx &amp; $0 不改变%dx的值，仅仅改变标志位</span></span><br><span class="line">jgte .top		<span class="comment"># 表示如果大于等于就跳到.top</span></span><br><span class="line">halt			<span class="comment"># 停机</span></span><br></pre></td></tr></table></figure>
<p>现在我们理解了<code>loop.s</code>句子的含义。现在我们看看题目，假设dx的初始值是0，很快就可以计算出每个指令执行的时候dx的值。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ./x86.py -p loop.s -t 1 -i 100 -R dx</span><br><span class="line">...</span><br><span class="line">   dx          Thread 0</span><br><span class="line">    0</span><br><span class="line">   -1   1000 sub  <span class="variable">$1</span>,%dx</span><br><span class="line">   -1   1001 <span class="built_in">test</span> <span class="variable">$0</span>,%dx</span><br><span class="line">   -1   1002 jgte .top</span><br><span class="line">   -1   1003 halt</span><br></pre></td></tr></table></figure>
<p>dx作为循环变量判断是否跳出循环，上述语句可以写成c语言的语句如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = n;</span><br><span class="line"><span class="keyword">while</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">	i--;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以它的价值就在于循环递减变量以及循环变量判断是否跳出循环。</p>
<h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h3><p>现在运行相同的代码，但是使用如下标志，但是设定了寄存器的初始值如<code>-a</code>后面所赋值。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">$ ./x86.py -p loop.s -t 2 -i 100 -a dx=3,dx=3 -R dx</span><br><span class="line">...</span><br><span class="line">   dx          Thread 0                Thread 1</span><br><span class="line">    3</span><br><span class="line">    2   1000 sub  <span class="variable">$1</span>,%dx</span><br><span class="line">    2   1001 <span class="built_in">test</span> <span class="variable">$0</span>,%dx</span><br><span class="line">    2   1002 jgte .top</span><br><span class="line">    1   1000 sub  <span class="variable">$1</span>,%dx</span><br><span class="line">    1   1001 <span class="built_in">test</span> <span class="variable">$0</span>,%dx</span><br><span class="line">    1   1002 jgte .top</span><br><span class="line">    0   1000 sub  <span class="variable">$1</span>,%dx</span><br><span class="line">    0   1001 <span class="built_in">test</span> <span class="variable">$0</span>,%dx</span><br><span class="line">    0   1002 jgte .top</span><br><span class="line">   -1   1000 sub  <span class="variable">$1</span>,%dx</span><br><span class="line">   -1   1001 <span class="built_in">test</span> <span class="variable">$0</span>,%dx</span><br><span class="line">   -1   1002 jgte .top</span><br><span class="line">   -1   1003 halt</span><br><span class="line">    3   ----- Halt;Switch -----  ----- Halt;Switch -----</span><br><span class="line">    2                            1000 sub  <span class="variable">$1</span>,%dx</span><br><span class="line">    2                            1001 <span class="built_in">test</span> <span class="variable">$0</span>,%dx</span><br><span class="line">    2                            1002 jgte .top</span><br><span class="line">    1                            1000 sub  <span class="variable">$1</span>,%dx</span><br><span class="line">    1                            1001 <span class="built_in">test</span> <span class="variable">$0</span>,%dx</span><br><span class="line">    1                            1002 jgte .top</span><br><span class="line">    0                            1000 sub  <span class="variable">$1</span>,%dx</span><br><span class="line">    0                            1001 <span class="built_in">test</span> <span class="variable">$0</span>,%dx</span><br><span class="line">    0                            1002 jgte .top</span><br><span class="line">   -1                            1000 sub  <span class="variable">$1</span>,%dx</span><br><span class="line">   -1                            1001 <span class="built_in">test</span> <span class="variable">$0</span>,%dx</span><br><span class="line">   -1                            1002 jgte .top</span><br><span class="line">   -1                            1003 halt</span><br></pre></td></tr></table></figure>
<p>在这种情况下，多线程不会影响结果的运行，因为两个线程执行的时候不是共享同一个<code>edx</code>的。这种情况下，两个线程只使用自己的dx的值，dx在每个线程从3到-1。并且在中断前halt跳出循环。</p>
<p>至于这段代码是否有竞态条件？首先要弄清楚什么叫竞态条件等两个基本概念。</p>
<blockquote>
<ul>
<li>临界区：访问共享资源的一段代码，资源通常是一个变量或数据结构。</li>
<li>竞态条件：出现在多个执行线程同时进入临界区时，他们都试图更新共享的数据结构导致了不确定结果</li>
</ul>
</blockquote>
<p>这一段<code>loop.s</code>中对共享资源更新的部分的代码就是<code>sub</code>指令这一条。因此因此我们可以看临界区就是这一段<code>loop.s</code>或者就是<code>sub</code>这一句。很明显从在这种情况下，线程每100条指令中断1次，而还没到100条指令就已经跳出循环了。这种情况下可以看出来，两段代码是没有竞态条件的。</p>
<h3 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h3><p>这一组测试使得中断间隔非常小而且随机，使用不同的种子<code>-s</code>查看不同的交替。中断频率是否会改变这个程序的行为。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">$ ./x86.py -p loop.s -t 2 -i 3 -r -a dx=3,dx=3 -R dx</span><br><span class="line">...</span><br><span class="line">   dx          Thread 0                Thread 1</span><br><span class="line">    3</span><br><span class="line">    2   1000 sub  <span class="variable">$1</span>,%dx</span><br><span class="line">    2   1001 <span class="built_in">test</span> <span class="variable">$0</span>,%dx</span><br><span class="line">    2   1002 jgte .top</span><br><span class="line">    3   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    2                            1000 sub  <span class="variable">$1</span>,%dx</span><br><span class="line">    2                            1001 <span class="built_in">test</span> <span class="variable">$0</span>,%dx</span><br><span class="line">    2                            1002 jgte .top</span><br><span class="line">    2   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    1   1000 sub  <span class="variable">$1</span>,%dx</span><br><span class="line">    1   1001 <span class="built_in">test</span> <span class="variable">$0</span>,%dx</span><br><span class="line">    2   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    1                            1000 sub  <span class="variable">$1</span>,%dx</span><br><span class="line">    1   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    1   1002 jgte .top</span><br><span class="line">    0   1000 sub  <span class="variable">$1</span>,%dx</span><br><span class="line">    1   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    1                            1001 <span class="built_in">test</span> <span class="variable">$0</span>,%dx</span><br><span class="line">    1                            1002 jgte .top</span><br><span class="line">    0   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    0   1001 <span class="built_in">test</span> <span class="variable">$0</span>,%dx</span><br><span class="line">    0   1002 jgte .top</span><br><span class="line">   -1   1000 sub  <span class="variable">$1</span>,%dx</span><br><span class="line">    1   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    0                            1000 sub  <span class="variable">$1</span>,%dx</span><br><span class="line">   -1   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">   -1   1001 <span class="built_in">test</span> <span class="variable">$0</span>,%dx</span><br><span class="line">   -1   1002 jgte .top</span><br><span class="line">    0   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    0                            1001 <span class="built_in">test</span> <span class="variable">$0</span>,%dx</span><br><span class="line">    0                            1002 jgte .top</span><br><span class="line">   -1   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">   -1   1003 halt</span><br><span class="line">    0   ----- Halt;Switch -----  ----- Halt;Switch -----</span><br><span class="line">   -1                            1000 sub  <span class="variable">$1</span>,%dx</span><br><span class="line">   -1                            1001 <span class="built_in">test</span> <span class="variable">$0</span>,%dx</span><br><span class="line">   -1   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">   -1                            1002 jgte .top</span><br><span class="line">   -1                            1003 halt</span><br></pre></td></tr></table></figure>
<p>再看看不同的随机种子下是什么样的结果。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">$ ./x86.py -p loop.s -t 2 -i 3 -r -a dx=3,dx=3 -R dx -c -s 1</span><br><span class="line">...</span><br><span class="line">   dx          Thread 0                Thread 1</span><br><span class="line">    3</span><br><span class="line">    2   1000 sub  <span class="variable">$1</span>,%dx</span><br><span class="line">    3   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    2                            1000 sub  <span class="variable">$1</span>,%dx</span><br><span class="line">    2                            1001 <span class="built_in">test</span> <span class="variable">$0</span>,%dx</span><br><span class="line">    2                            1002 jgte .top</span><br><span class="line">    2   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    2   1001 <span class="built_in">test</span> <span class="variable">$0</span>,%dx</span><br><span class="line">    2   1002 jgte .top</span><br><span class="line">    1   1000 sub  <span class="variable">$1</span>,%dx</span><br><span class="line">    2   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    1                            1000 sub  <span class="variable">$1</span>,%dx</span><br><span class="line">    1   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    1   1001 <span class="built_in">test</span> <span class="variable">$0</span>,%dx</span><br><span class="line">    1   1002 jgte .top</span><br><span class="line">    1   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    1                            1001 <span class="built_in">test</span> <span class="variable">$0</span>,%dx</span><br><span class="line">    1                            1002 jgte .top</span><br><span class="line">    1   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    0   1000 sub  <span class="variable">$1</span>,%dx</span><br><span class="line">    0   1001 <span class="built_in">test</span> <span class="variable">$0</span>,%dx</span><br><span class="line">    1   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    0                            1000 sub  <span class="variable">$1</span>,%dx</span><br><span class="line">    0                            1001 <span class="built_in">test</span> <span class="variable">$0</span>,%dx</span><br><span class="line">    0                            1002 jgte .top</span><br><span class="line">    0   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    0   1002 jgte .top</span><br><span class="line">    0   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">   -1                            1000 sub  <span class="variable">$1</span>,%dx</span><br><span class="line">    0   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">   -1   1000 sub  <span class="variable">$1</span>,%dx</span><br><span class="line">   -1   1001 <span class="built_in">test</span> <span class="variable">$0</span>,%dx</span><br><span class="line">   -1   1002 jgte .top</span><br><span class="line">   -1   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">   -1                            1001 <span class="built_in">test</span> <span class="variable">$0</span>,%dx</span><br><span class="line">   -1                            1002 jgte .top</span><br><span class="line">   -1   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">   -1   1003 halt</span><br><span class="line">   -1   ----- Halt;Switch -----  ----- Halt;Switch -----</span><br><span class="line">   -1                            1003 halt</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">./x86.py -p loop.s -t 2 -i 3 -r -a dx=3,dx=3 -R dx -c -s 2</span><br><span class="line">...</span><br><span class="line">   dx          Thread 0                Thread 1</span><br><span class="line">    3</span><br><span class="line">    2   1000 sub  <span class="variable">$1</span>,%dx</span><br><span class="line">    2   1001 <span class="built_in">test</span> <span class="variable">$0</span>,%dx</span><br><span class="line">    2   1002 jgte .top</span><br><span class="line">    3   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    2                            1000 sub  <span class="variable">$1</span>,%dx</span><br><span class="line">    2                            1001 <span class="built_in">test</span> <span class="variable">$0</span>,%dx</span><br><span class="line">    2                            1002 jgte .top</span><br><span class="line">    2   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    1   1000 sub  <span class="variable">$1</span>,%dx</span><br><span class="line">    2   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    1                            1000 sub  <span class="variable">$1</span>,%dx</span><br><span class="line">    1   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    1   1001 <span class="built_in">test</span> <span class="variable">$0</span>,%dx</span><br><span class="line">    1   1002 jgte .top</span><br><span class="line">    0   1000 sub  <span class="variable">$1</span>,%dx</span><br><span class="line">    1   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    1                            1001 <span class="built_in">test</span> <span class="variable">$0</span>,%dx</span><br><span class="line">    1                            1002 jgte .top</span><br><span class="line">    0                            1000 sub  <span class="variable">$1</span>,%dx</span><br><span class="line">    0   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    0   1001 <span class="built_in">test</span> <span class="variable">$0</span>,%dx</span><br><span class="line">    0   1002 jgte .top</span><br><span class="line">   -1   1000 sub  <span class="variable">$1</span>,%dx</span><br><span class="line">    0   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    0                            1001 <span class="built_in">test</span> <span class="variable">$0</span>,%dx</span><br><span class="line">   -1   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">   -1   1001 <span class="built_in">test</span> <span class="variable">$0</span>,%dx</span><br><span class="line">   -1   1002 jgte .top</span><br><span class="line">    0   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    0                            1002 jgte .top</span><br><span class="line">   -1                            1000 sub  <span class="variable">$1</span>,%dx</span><br><span class="line">   -1   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">   -1   1003 halt</span><br><span class="line">   -1   ----- Halt;Switch -----  ----- Halt;Switch -----</span><br><span class="line">   -1                            1001 <span class="built_in">test</span> <span class="variable">$0</span>,%dx</span><br><span class="line">   -1   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">   -1                            1002 jgte .top</span><br><span class="line">   -1   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">   -1                            1003 halt</span><br></pre></td></tr></table></figure>
<p>总体看来，两个线程仍然是执行了从3到-1的循环操作，但是由于中断具有随机性，因此也就不能够确定什么时候执行完毕。从工作执行总量上看没有发生改变，但就工作执行的先后以及连续性上，改变了行为。</p>
<h3 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h3><p>第四题是访问一个公共变量而不是寄存器，在前面3题中，每个线程都有自己的专属寄存器。在中断的时候，线程的寄存器会保存，在恢复中断恢复的时候寄存器的值会被恢复。因此在循环上不会被破坏。但是现在的公共资源是一个变量，这可能引起某些变化。具体见下面。</p>
<p>首先看看这个程序<code>looping-race-nolock.s</code>是什么意思</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ cat looping-race-nolock.s</span><br><span class="line"># assumes %bx has loop count in it</span><br><span class="line"></span><br><span class="line">.main</span><br><span class="line">.top</span><br><span class="line"># critical section 临界区</span><br><span class="line">mov 2000, %ax  # get &#x27;value&#x27; at address 2000</span><br><span class="line">add $1, %ax    # increment it: ax += 1</span><br><span class="line">mov %ax, 2000  # store it back</span><br><span class="line"></span><br><span class="line"># see if we&#x27;re still looping</span><br><span class="line">sub  $1, %bx</span><br><span class="line">test $0, %bx</span><br><span class="line">jgt .top</span><br><span class="line"></span><br><span class="line">halt</span><br></pre></td></tr></table></figure>
<p>可以看出来bx是循环变量，要对ax进行加一操作，可以写出程序的c语言表达如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = n;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> *p;</span><br><span class="line"><span class="keyword">while</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    *p = x;</span><br><span class="line">    *p--;</span><br><span class="line">    i--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们再来看看下面这段执行情况。显然除了<code>mov %ax 2000</code>这个语句会更新2000地址的变量x的值，其余时刻都不会更新。因此结果如下。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ ./x86.py -p looping-race-nolock.s -t 1 -M 2000</span><br><span class="line">...</span><br><span class="line"> 2000          Thread 0</span><br><span class="line">    0</span><br><span class="line">    0   1000 mov 2000, %ax</span><br><span class="line">    0   1001 add <span class="variable">$1</span>, %ax</span><br><span class="line">    1   1002 mov %ax, 2000</span><br><span class="line">    1   1003 sub  <span class="variable">$1</span>, %bx</span><br><span class="line">    1   1004 <span class="built_in">test</span> <span class="variable">$0</span>, %bx</span><br><span class="line">    1   1005 jgt .top</span><br><span class="line">    1   1006 halt</span><br></pre></td></tr></table></figure>
<h2 id="第28章"><a href="#第28章" class="headerlink" title="第28章"></a>第28章</h2><p>这一章的习题同样是一个用python写的x86模拟器，它能够运行<code>.s</code>格式的文件。</p>
<p>在这里，我们有四个常用的寄存器ax、bx、cx、dx，还有一个程序计数器PC。还有足够小但是能够满足我们需求的汇编指令。我们也加了一些额外的寄存器，例如ex和fx，这不见得能够与x86是对应的。但是这并没有什么问题。</p>
<h3 id="1-1"><a href="#1-1" class="headerlink" title="1."></a>1.</h3><p>这题要我们用./x86运行<code>flag.s</code>文件。首先理解一下<code>flag.s</code>到底说了什么。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> flag.s</span><br><span class="line">.var flag</span><br><span class="line">.var count</span><br><span class="line"></span><br><span class="line">.main</span><br><span class="line">.top</span><br><span class="line"></span><br><span class="line">.acquire</span><br><span class="line">mov  flag, %ax      <span class="comment"># get flag</span></span><br><span class="line"><span class="built_in">test</span> <span class="variable">$0</span>, %ax        <span class="comment"># if we get 0 back: lock is free!</span></span><br><span class="line">jne  .acquire       <span class="comment"># if not, try again</span></span><br><span class="line">mov  <span class="variable">$1</span>, flag       <span class="comment"># store 1 into flag</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># critical section</span></span><br><span class="line">mov  count, %ax     <span class="comment"># get the value at the address</span></span><br><span class="line">add  <span class="variable">$1</span>, %ax        <span class="comment"># increment it</span></span><br><span class="line">mov  %ax, count     <span class="comment"># store it back</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># release lock</span></span><br><span class="line">mov  <span class="variable">$0</span>, flag       <span class="comment"># clear the flag now</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># see if we&#x27;re still looping</span></span><br><span class="line">sub  <span class="variable">$1</span>, %bx</span><br><span class="line"><span class="built_in">test</span> <span class="variable">$0</span>, %bx</span><br><span class="line">jgt .top</span><br><span class="line"></span><br><span class="line">halt</span><br></pre></td></tr></table></figure>
<p>上面这部分汇编代码其实很好理解，根据上面的注释，我们可以写出c语言版本</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> <span class="type">mutex_t</span>;</span><br><span class="line"><span class="type">mutex_t</span> flag = <span class="number">0x0</span>;</span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> i = n;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">mian</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">/* 上锁 */</span></span><br><span class="line">        <span class="keyword">while</span> (flag != <span class="number">0x0</span>)</span><br><span class="line">            ; <span class="comment">// 自选等待锁空闲</span></span><br><span class="line">        <span class="comment">/* lock */</span></span><br><span class="line">        flag = <span class="number">0x1</span>;</span><br><span class="line">        <span class="comment">/* 临界区代码 */</span></span><br><span class="line">        count++;</span><br><span class="line">        <span class="comment">/* unlock */</span></span><br><span class="line">        flag = <span class="number">0x0</span>;</span><br><span class="line">        <span class="comment">/* 判断是否继续循环 */</span></span><br><span class="line">        i--;	</span><br><span class="line">    &#125; <span class="keyword">while</span> (i &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="comment">/* halt */</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以<code>flag.s</code>的功能就是在循环变量被减到0之前不断申请上锁，然后对公共资源count++，然后释放锁的过程。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">$./x86.py -p flag.s</span><br><span class="line">...</span><br><span class="line">       Thread 0                Thread 1</span><br><span class="line"></span><br><span class="line">1000 mov  flag, %ax</span><br><span class="line">1001 <span class="built_in">test</span> <span class="variable">$0</span>, %ax</span><br><span class="line">1002 jne  .acquire</span><br><span class="line">1003 mov  <span class="variable">$1</span>, flag</span><br><span class="line">1004 mov  count, %ax</span><br><span class="line">1005 add  <span class="variable">$1</span>, %ax</span><br><span class="line">1006 mov  %ax, count</span><br><span class="line">1007 mov  <span class="variable">$0</span>, flag</span><br><span class="line">1008 sub  <span class="variable">$1</span>, %bx</span><br><span class="line">1009 <span class="built_in">test</span> <span class="variable">$0</span>, %bx</span><br><span class="line">1010 jgt .top</span><br><span class="line">1011 halt</span><br><span class="line">----- Halt;Switch -----  ----- Halt;Switch -----</span><br><span class="line">                         1000 mov  flag, %ax</span><br><span class="line">                         1001 <span class="built_in">test</span> <span class="variable">$0</span>, %ax</span><br><span class="line">                         1002 jne  .acquire</span><br><span class="line">                         1003 mov  <span class="variable">$1</span>, flag</span><br><span class="line">                         1004 mov  count, %ax</span><br><span class="line">                         1005 add  <span class="variable">$1</span>, %ax</span><br><span class="line">                         1006 mov  %ax, count</span><br><span class="line">                         1007 mov  <span class="variable">$0</span>, flag</span><br><span class="line">                         1008 sub  <span class="variable">$1</span>, %bx</span><br><span class="line">                         1009 <span class="built_in">test</span> <span class="variable">$0</span>, %bx</span><br><span class="line">                         1010 jgt .top</span><br><span class="line">                         1011 halt</span><br></pre></td></tr></table></figure>
<p>和上面的26的作业类似，在中断时间片较短的时候，两个线程都能够完成各自的工作。这个时候，count能够获得两个线程的累加工作，并获得确定的答案。既能够获得某个线程两倍的累加量。</p>
<h3 id="2-1"><a href="#2-1" class="headerlink" title="2."></a>2.</h3><p>上面其实已经解释了。答案是会的，能够按照预期工作。我们可以详细跟踪各个变量和寄存器的值看看</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">$./x86.py -p flag.s -R ax,bx -M flag,count -c</span><br><span class="line">...</span><br><span class="line"> flag count      ax    bx          Thread 0                Thread 1</span><br><span class="line"></span><br><span class="line">    0     0       0     0</span><br><span class="line">    0     0       0     0   1000 mov  flag, %ax</span><br><span class="line">    0     0       0     0   1001 <span class="built_in">test</span> <span class="variable">$0</span>, %ax</span><br><span class="line">    0     0       0     0   1002 jne  .acquire</span><br><span class="line">    1     0       0     0   1003 mov  <span class="variable">$1</span>, flag</span><br><span class="line">    1     0       0     0   1004 mov  count, %ax</span><br><span class="line">    1     0       1     0   1005 add  <span class="variable">$1</span>, %ax</span><br><span class="line">    1     1       1     0   1006 mov  %ax, count</span><br><span class="line">    0     1       1     0   1007 mov  <span class="variable">$0</span>, flag</span><br><span class="line">    0     1       1    -1   1008 sub  <span class="variable">$1</span>, %bx</span><br><span class="line">    0     1       1    -1   1009 <span class="built_in">test</span> <span class="variable">$0</span>, %bx</span><br><span class="line">    0     1       1    -1   1010 jgt .top</span><br><span class="line">    0     1       1    -1   1011 halt</span><br><span class="line">    0     1       0     0   ----- Halt;Switch -----  ----- Halt;Switch -----</span><br><span class="line">    0     1       0     0                            1000 mov  flag, %ax</span><br><span class="line">    0     1       0     0                            1001 <span class="built_in">test</span> <span class="variable">$0</span>, %ax</span><br><span class="line">    0     1       0     0                            1002 jne  .acquire</span><br><span class="line">    1     1       0     0                            1003 mov  <span class="variable">$1</span>, flag</span><br><span class="line">    1     1       1     0                            1004 mov  count, %ax</span><br><span class="line">    1     1       2     0                            1005 add  <span class="variable">$1</span>, %ax</span><br><span class="line">    1     2       2     0                            1006 mov  %ax, count</span><br><span class="line">    0     2       2     0                            1007 mov  <span class="variable">$0</span>, flag</span><br><span class="line">    0     2       2    -1                            1008 sub  <span class="variable">$1</span>, %bx</span><br><span class="line">    0     2       2    -1                            1009 <span class="built_in">test</span> <span class="variable">$0</span>, %bx</span><br><span class="line">    0     2       2    -1                            1010 jgt .top</span><br><span class="line">    0     2       2    -1                            1011 halt</span><br></pre></td></tr></table></figure>
<p>可以看到两个线程的循环变量寄存器都是bx，它们都是1，说明可以各自累加一次。count的初始值是0，所以最终各自累加一次，可以看到最后count的值恰好是2，证明了可以按照预期工作。</p>
<h3 id="3-1"><a href="#3-1" class="headerlink" title="3."></a>3.</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">$./x86.py -p flag.s -R ax,bx -M flag,count -c -a bx=2,bx=2</span><br><span class="line">...</span><br><span class="line"> flag count      ax    bx          Thread 0                Thread 1</span><br><span class="line"></span><br><span class="line">    0     0       0     2</span><br><span class="line">    0     0       0     2   1000 mov  flag, %ax</span><br><span class="line">    0     0       0     2   1001 <span class="built_in">test</span> <span class="variable">$0</span>, %ax</span><br><span class="line">    0     0       0     2   1002 jne  .acquire</span><br><span class="line">    1     0       0     2   1003 mov  <span class="variable">$1</span>, flag</span><br><span class="line">    1     0       0     2   1004 mov  count, %ax</span><br><span class="line">    1     0       1     2   1005 add  <span class="variable">$1</span>, %ax</span><br><span class="line">    1     1       1     2   1006 mov  %ax, count</span><br><span class="line">    0     1       1     2   1007 mov  <span class="variable">$0</span>, flag</span><br><span class="line">    0     1       1     1   1008 sub  <span class="variable">$1</span>, %bx</span><br><span class="line">    0     1       1     1   1009 <span class="built_in">test</span> <span class="variable">$0</span>, %bx</span><br><span class="line">    0     1       1     1   1010 jgt .top</span><br><span class="line">    0     1       0     1   1000 mov  flag, %ax</span><br><span class="line">    0     1       0     1   1001 <span class="built_in">test</span> <span class="variable">$0</span>, %ax</span><br><span class="line">    0     1       0     1   1002 jne  .acquire</span><br><span class="line">    1     1       0     1   1003 mov  <span class="variable">$1</span>, flag</span><br><span class="line">    1     1       1     1   1004 mov  count, %ax</span><br><span class="line">    1     1       2     1   1005 add  <span class="variable">$1</span>, %ax</span><br><span class="line">    1     2       2     1   1006 mov  %ax, count</span><br><span class="line">    0     2       2     1   1007 mov  <span class="variable">$0</span>, flag</span><br><span class="line">    0     2       2     0   1008 sub  <span class="variable">$1</span>, %bx</span><br><span class="line">    0     2       2     0   1009 <span class="built_in">test</span> <span class="variable">$0</span>, %bx</span><br><span class="line">    0     2       2     0   1010 jgt .top</span><br><span class="line">    0     2       2     0   1011 halt</span><br><span class="line">    0     2       0     2   ----- Halt;Switch -----  ----- Halt;Switch -----</span><br><span class="line">    0     2       0     2                            1000 mov  flag, %ax</span><br><span class="line">    0     2       0     2                            1001 <span class="built_in">test</span> <span class="variable">$0</span>, %ax</span><br><span class="line">    0     2       0     2                            1002 jne  .acquire</span><br><span class="line">    1     2       0     2                            1003 mov  <span class="variable">$1</span>, flag</span><br><span class="line">    1     2       2     2                            1004 mov  count, %ax</span><br><span class="line">    1     2       3     2                            1005 add  <span class="variable">$1</span>, %ax</span><br><span class="line">    1     3       3     2                            1006 mov  %ax, count</span><br><span class="line">    0     3       3     2                            1007 mov  <span class="variable">$0</span>, flag</span><br><span class="line">    0     3       3     1                            1008 sub  <span class="variable">$1</span>, %bx</span><br><span class="line">    0     3       3     1                            1009 <span class="built_in">test</span> <span class="variable">$0</span>, %bx</span><br><span class="line">    0     3       3     1                            1010 jgt .top</span><br><span class="line">    0     3       0     1                            1000 mov  flag, %ax</span><br><span class="line">    0     3       0     1                            1001 <span class="built_in">test</span> <span class="variable">$0</span>, %ax</span><br><span class="line">    0     3       0     1                            1002 jne  .acquire</span><br><span class="line">    1     3       0     1                            1003 mov  <span class="variable">$1</span>, flag</span><br><span class="line">    1     3       3     1                            1004 mov  count, %ax</span><br><span class="line">    1     3       4     1                            1005 add  <span class="variable">$1</span>, %ax</span><br><span class="line">    1     4       4     1                            1006 mov  %ax, count</span><br><span class="line">    0     4       4     1                            1007 mov  <span class="variable">$0</span>, flag</span><br><span class="line">    0     4       4     0                            1008 sub  <span class="variable">$1</span>, %bx</span><br><span class="line">    0     4       4     0                            1009 <span class="built_in">test</span> <span class="variable">$0</span>, %bx</span><br><span class="line">    0     4       4     0                            1010 jgt .top</span><br><span class="line">    0     4       4     0                            1011 halt</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>和前面的题目一样，实际就是两个线程分别进行两次累加，可以看到到目前为止，都能够正确完成累加。原因是中断切换线程执行的时候，两个线程都能够完成所有的累加，就不会出现存在竞态条件的情况。</p>
<h3 id="4-1"><a href="#4-1" class="headerlink" title="4."></a>4.</h3><p>这里我让循环为50次</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$./x86.py -p flag.s -R ax,bx -M flag,count -c -a bx=50,bx=50 -i 3</span><br><span class="line">...</span><br><span class="line"> flag count      ax    bx          Thread 0                Thread 1</span><br><span class="line"></span><br><span class="line">    0     0       0     2</span><br><span class="line">    0     0       0     2   1000 mov  flag, %ax</span><br><span class="line">    0     0       0     2   1001 <span class="built_in">test</span> <span class="variable">$0</span>, %ax</span><br><span class="line">    0     0       0     2   1002 jne  .acquire</span><br><span class="line">    1     0       0     2   1003 mov  <span class="variable">$1</span>, flag</span><br><span class="line">    1     0       0     2   1004 mov  count, %ax</span><br><span class="line">    1     0       1     2   1005 add  <span class="variable">$1</span>, %ax</span><br><span class="line">    1     1       1     2   1006 mov  %ax, count</span><br><span class="line">    0     1       1     2   1007 mov  <span class="variable">$0</span>, flag</span><br><span class="line">...</span><br><span class="line">  	1    57      57     1   1006 mov  %ax, count</span><br><span class="line">    0    57      57     1   1007 mov  <span class="variable">$0</span>, flag</span><br><span class="line">    0    57      57     1   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    0    57      57     0   1008 sub  <span class="variable">$1</span>, %bx</span><br><span class="line">    0    57      57     0   1009 <span class="built_in">test</span> <span class="variable">$0</span>, %bx</span><br><span class="line">    0    57      57     0   1010 jgt .top</span><br><span class="line">    0    57      57     0   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    0    57      57     0   1011 halt</span><br></pre></td></tr></table></figure>
<p>你能够看到两个线程循环50次，应该要能够累加100次，但是最后的结果是只累加了57次。此时我们说出现了不确定现象。</p>
<p>由于以flag作为锁，它的加锁和解锁本身没有原子性，所以并不能够起到保护共享资源的作用。所以随着<code>bx</code>增大，<code>i</code>减小，越容易产生不好的结果。反过来<code>bx</code>减小，<code>i</code>增大越趋向于产生确定的好的结果。</p>
<h3 id="5"><a href="#5" class="headerlink" title="5."></a>5.</h3><p>现在我们研究另外一个文件，它是个使用硬件原语<code>test-and-set</code>的指令，详细看看：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> test-and-set.s</span><br><span class="line">.var mutex</span><br><span class="line">.var count</span><br><span class="line"></span><br><span class="line">.main</span><br><span class="line">.top</span><br><span class="line"></span><br><span class="line">.acquire</span><br><span class="line">mov  <span class="variable">$1</span>, %ax</span><br><span class="line">xchg %ax, mutex     <span class="comment"># atomic swap of 1 and mutex</span></span><br><span class="line"><span class="built_in">test</span> <span class="variable">$0</span>, %ax        <span class="comment"># if we get 0 back: lock is free!</span></span><br><span class="line">jne  .acquire       <span class="comment"># if not, try again</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># critical section</span></span><br><span class="line">mov  count, %ax     <span class="comment"># get the value at the address</span></span><br><span class="line">add  <span class="variable">$1</span>, %ax        <span class="comment"># increment it</span></span><br><span class="line">mov  %ax, count     <span class="comment"># store it back</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># release lock</span></span><br><span class="line">mov  <span class="variable">$0</span>, mutex</span><br><span class="line"></span><br><span class="line"><span class="comment"># see if we&#x27;re still looping</span></span><br><span class="line">sub  <span class="variable">$1</span>, %bx</span><br><span class="line"><span class="built_in">test</span> <span class="variable">$0</span>, %bx</span><br><span class="line">jgt .top</span><br><span class="line"></span><br><span class="line">halt</span><br></pre></td></tr></table></figure>
<p>同样针对上面的汇编代码我们写出c语言版本</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> <span class="type">mutex_t</span>;</span><br><span class="line"><span class="type">mutex_t</span> mutex;</span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> i = n;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">/* 等待锁空闲，如果有空闲锁就上锁 */</span></span><br><span class="line">        <span class="keyword">while</span> (test_and_set(&amp;mutex, <span class="number">0x1</span>) != <span class="number">0x0</span>)</span><br><span class="line">            ; <span class="comment">// spin</span></span><br><span class="line">        <span class="comment">/* 临界区 */</span></span><br><span class="line">        count++;</span><br><span class="line">        <span class="comment">/* 解锁 */</span></span><br><span class="line">        mutex = <span class="number">0x0</span>;</span><br><span class="line">        i--;</span><br><span class="line">    &#125; <span class="keyword">while</span> (i &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="comment">/* halt */</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中获取锁部分：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 等待锁空闲，如果有空闲锁就上锁 */</span></span><br><span class="line"><span class="keyword">while</span> (test_and_set(&amp;mutex, <span class="number">0x1</span>) != <span class="number">0x0</span>)</span><br><span class="line">    ; <span class="comment">// spin</span></span><br><span class="line">=&gt;</span><br><span class="line">.acquire</span><br><span class="line">mov  $<span class="number">1</span>, %ax</span><br><span class="line">xchg %ax, mutex     <span class="meta"># atomic swap of 1 and mutex</span></span><br><span class="line">test $<span class="number">0</span>, %ax        <span class="meta"># <span class="keyword">if</span> we get 0 back: lock is free!</span></span><br><span class="line">jne  .acquire       <span class="meta"># <span class="keyword">if</span> not, try again</span></span><br></pre></td></tr></table></figure>
<p>释放锁部分：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 解锁 */</span></span><br><span class="line">mutex = <span class="number">0x0</span>;</span><br><span class="line">=&gt;</span><br><span class="line">mov  $<span class="number">0</span>, mutex</span><br></pre></td></tr></table></figure>
<h3 id="6"><a href="#6" class="headerlink" title="6."></a>6.</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ ./x86.py -p test-and-set.s -i 3 -a bx=50,bx=50 -M mutex,count -R ax,bx -c</span><br><span class="line">...</span><br><span class="line">mutex count      ax    bx          Thread 0                Thread 1</span><br><span class="line"></span><br><span class="line">    0     0       0    50</span><br><span class="line">    0     0       1    50   1000 mov  <span class="variable">$1</span>, %ax</span><br><span class="line">    1     0       0    50   1001 xchg %ax, mutex</span><br><span class="line">    1     0       0    50   1002 <span class="built_in">test</span> <span class="variable">$0</span>, %ax</span><br><span class="line">    1     0       0    50   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    1     0       1    50                            1000 mov  <span class="variable">$1</span>, %ax</span><br><span class="line">    1     0       1    50                            1001 xchg %ax, mutex</span><br><span class="line">    1     0       1    50                            1002 <span class="built_in">test</span> <span class="variable">$0</span>, %ax</span><br><span class="line">    1     0       0    50   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">... </span><br><span class="line">   	0   100     100     0                            1008 sub  <span class="variable">$1</span>, %bx</span><br><span class="line">    0   100     100     0   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    0   100     100     0                            1009 <span class="built_in">test</span> <span class="variable">$0</span>, %bx</span><br><span class="line">    0   100     100     0                            1010 jgt .top</span><br><span class="line">    0   100     100     0                            1011 halt</span><br></pre></td></tr></table></figure>
<p>可以看到在这种<code>test-and-set</code>的硬件原语支持下，能够保证原子性。所以最后计算的结果能够满足预期。但是可以从上面的代码中的看出，虽然保证了加锁的原子性，进而控制了了每次只能有一个线程在临界区。但是，由于当线程没有抢占到锁，就会在while中自旋等待，倘若拥有锁定的线程迟迟不释放锁，其他大量的线程就可能都处于自选等待的状态。而如果线程间调度采用的是类似轮转这样的算法，那么就会有大量的CPU资源用来自选。这种自选显然不是我们想要的，因此由于分时共享CPU的存在，CPU的使用率虽然比较高，但是做的有用功却不是很高，大部分时间在做自选等待。</p>
<p>现在考虑如何量化这样的CPU使用率的描述。就比如上面的示例代码两个线程一共做了100次累加，每次累加只有下面3条指令是经行累加的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># critical section</span><br><span class="line">mov  count, %ax     # get the value at the address</span><br><span class="line">add  $1, %ax        # increment it</span><br><span class="line">mov  %ax, count     # store it back</span><br></pre></td></tr></table></figure>
<p>因此也就只有3*100 = 300条指令做有用功，剩下的通通是无用功。可以统计上面的计算共有2010行。由于整个计算过程CPU都处于工作状态。因此使用率100%。但是有效使用率仅有300/2010 = 14.93%</p>
<h3 id="7"><a href="#7" class="headerlink" title="7."></a>7.</h3><p>首先我们需要通过增加<code>-P</code>属性来规定执行的顺序。例如：<code>-P 1100111000111000111000</code>就会依次按照t1，t1，t0，t0，t1，…，t0，t0，t0的顺序执行线程</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ ./x86.py -p test-and-set.s -i 10 -R ax,bx -M mutex,count -a bx=5 -P 1100111000111000111000 -c</span><br><span class="line">...</span><br><span class="line">mutex count      ax    bx          Thread 0                Thread 1</span><br><span class="line"></span><br><span class="line">    0     0       0     5</span><br><span class="line">    0     0       1     5                            1000 mov  <span class="variable">$1</span>, %ax</span><br><span class="line">    1     0       0     5                            1001 xchg %ax, mutex</span><br><span class="line">    1     0       0     5   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    1     0       1     5   1000 mov  <span class="variable">$1</span>, %ax</span><br><span class="line">    1     0       1     5   1001 xchg %ax, mutex</span><br><span class="line">    1     0       0     5   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    1     0       0     5                            1002 <span class="built_in">test</span> <span class="variable">$0</span>, %ax</span><br><span class="line">    1     0       0     5                            1003 jne  .acquire</span><br><span class="line">...</span><br><span class="line">    1    10      10     1   1006 mov  %ax, count</span><br><span class="line">    0    10      10     1   1007 mov  <span class="variable">$0</span>, mutex</span><br><span class="line">    0    10      10     0   1008 sub  <span class="variable">$1</span>, %bx</span><br><span class="line">    0    10      10     0   1009 <span class="built_in">test</span> <span class="variable">$0</span>, %bx</span><br><span class="line">    0    10      10     0   1010 jgt .top</span><br><span class="line">    0    10      10     0   1011 halt</span><br></pre></td></tr></table></figure>
<p>可以看到最后结果是正确的，由于上面的获取锁过程是具有原子性的，也就是说每一次只能有一个线程执行成功(成功把flag从0变成1)获得锁。因此也就保证了正确性。</p>
<h2 id="第30章"><a href="#第30章" class="headerlink" title="第30章"></a>第30章</h2><p>由于第30章中文版课本上没有题目，因此在这里放出英文课本原题。</p>
<h3 id="1-2"><a href="#1-2" class="headerlink" title="1."></a>1.</h3><p><img src="/2022/05/19/OS-thread-homework/image-20220516082241930.png" alt="image-20220516082241930"></p>
<p>这个题目要我们专注于文件<code>main-two-cvs-while.c</code>。首先需要先了解代码的含义，理解代码运行会发生什么。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* src: main-two-cvs-while.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common_threads.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pc-header.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是用于生产者消费者的信号量</span></span><br><span class="line"><span class="comment">// empty 用于通知生产者复工</span></span><br><span class="line"><span class="comment">// fill  用于通知消费者消费</span></span><br><span class="line"><span class="comment">// m     锁</span></span><br><span class="line"><span class="type">pthread_cond_t</span> empty  = PTHREAD_COND_INITIALIZER;</span><br><span class="line"><span class="type">pthread_cond_t</span> fill   = PTHREAD_COND_INITIALIZER;</span><br><span class="line"><span class="type">pthread_mutex_t</span> m     = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main-header.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 填充函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_fill</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="comment">// 确保在这个函数使用前buffer[fill_ptr]是空的</span></span><br><span class="line">    <span class="comment">// 否则打印错误讯息</span></span><br><span class="line">    ensure(buffer[fill_ptr] == EMPTY, <span class="string">&quot;error: tried to fill a non-empty buffer&quot;</span>);</span><br><span class="line">    <span class="comment">// 填充缓冲区特定位置</span></span><br><span class="line">    buffer[fill_ptr] = value;</span><br><span class="line">    <span class="comment">// 填充指针指向下一位置</span></span><br><span class="line">    fill_ptr = (fill_ptr + <span class="number">1</span>) % max;</span><br><span class="line">    <span class="comment">// 已经填充数量加一</span></span><br><span class="line">    num_full++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">do_get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取特定位置的值</span></span><br><span class="line">    <span class="type">int</span> tmp = buffer[use_ptr];</span><br><span class="line">    <span class="comment">// 确保缓冲区有值</span></span><br><span class="line">    <span class="comment">// 否则打印错误讯息</span></span><br><span class="line">    ensure(tmp != EMPTY, <span class="string">&quot;error: tried to get an empty buffer&quot;</span>);</span><br><span class="line">    <span class="comment">// 取完商品把这个位置置空</span></span><br><span class="line">    buffer[use_ptr] = EMPTY;</span><br><span class="line">    <span class="comment">// 使用指针指向下一位置</span></span><br><span class="line">    use_ptr = (use_ptr + <span class="number">1</span>) % max;</span><br><span class="line">    <span class="comment">// 已经填充数量减一</span></span><br><span class="line">    num_full--;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者函数</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">producer</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="comment">// 根据arg所指的数值设置生产者的id</span></span><br><span class="line">    <span class="type">int</span> id = (<span class="type">int</span>) arg;</span><br><span class="line">    <span class="comment">// 确保每一个生产者能够生产自己专属的值(与id关联)</span></span><br><span class="line">    <span class="type">int</span> base = id * loops;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loops; i++) &#123;   p0;	<span class="comment">// 循环生产商品</span></span><br><span class="line">        Mutex_lock(&amp;m);             p1;	<span class="comment">// 获取锁</span></span><br><span class="line">        <span class="keyword">while</span> (num_full == max) &#123;   p2;	<span class="comment">// 如果货架满了</span></span><br><span class="line">            Cond_wait(&amp;empty, &amp;m);  p3;	<span class="comment">// 则睡眠等待货架再次为空时复工</span></span><br><span class="line">        &#125;</span><br><span class="line">        do_fill(base + i);          p4;	<span class="comment">// 进行一次货架填充</span></span><br><span class="line">        Cond_signal(&amp;fill);         p5;	<span class="comment">// 通知消费者可消费</span></span><br><span class="line">        Mutex_unlock(&amp;m);           p6;	<span class="comment">// 释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">consumer</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="comment">// 消费者根据arg产生唯一id</span></span><br><span class="line">    <span class="type">int</span> id = (<span class="type">int</span>) arg;					</span><br><span class="line">    <span class="type">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> consumed_count = <span class="number">0</span>;			   <span class="comment">// 消费数量</span></span><br><span class="line">    <span class="keyword">while</span> (tmp != END_OF_STREAM) &#123; c0; <span class="comment">// 循环直到生产商品流的最后元素</span></span><br><span class="line">        Mutex_lock(&amp;m);            c1; <span class="comment">// 获取锁</span></span><br><span class="line">        <span class="keyword">while</span> (num_full == <span class="number">0</span>) &#123;    c2; <span class="comment">// 如果货架空了</span></span><br><span class="line">            Cond_wait(&amp;fill, &amp;m);  c3; <span class="comment">// 等待生产者填充货架</span></span><br><span class="line">        &#125;</span><br><span class="line">        tmp = do_get();            c4; <span class="comment">// 获取货物</span></span><br><span class="line">        Cond_signal(&amp;empty);       c5; <span class="comment">// </span></span><br><span class="line">        Mutex_unlock(&amp;m);          c6; <span class="comment">// 释放锁</span></span><br><span class="line">        consumed_count++;			   <span class="comment">// 消费数量加一</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回consumer_count-1是因为END_OF_STREAM并不是有效商品</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span> *) (<span class="type">long</span> <span class="type">long</span>) (consumed_count - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置控制信号</span></span><br><span class="line"><span class="type">pthread_cond_t</span> *fill_cv = &amp;fill;</span><br><span class="line"><span class="type">pthread_cond_t</span> *empty_cv = &amp;empty;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有代码使用这个文件里的东西</span></span><br><span class="line"><span class="comment">// 包括主函数等启动问题程序</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main-common.c&quot;</span></span></span><br></pre></td></tr></table></figure>
<p>对上面的代码我们做出了解析，如注释所示。我们的生产者会调用<code>do_fill</code>进行生产活动，一次只生产一个货物到空货架上。消费者会调用<code>do_get</code>获取货物，一次只获得一个商品。货架是一个数组，上面依次存取商品，由<code>fill_ptr</code>指明放入位置，由<code>use_ptr</code>知名从哪个位置取商品。</p>
<h3 id="2-2"><a href="#2-2" class="headerlink" title="2."></a>2.</h3><p><img src="/2022/05/19/OS-thread-homework/image-20220516085555854.png" alt="image-20220516085555854"></p>
<p>运行一个生产者一个消费者程序，然后让生产者生产一些特定的值。一开始我们只是使用一个长度大小只有1的buffer，然后慢慢增长它。当货架增大，程序代码会做和行为？你认为<code>num_full</code>会随着buffer的容量变大有什么不同（例如可以设成-<code>l 100</code>），当你改变消费者字符串，从默认的不睡眠到<code>-C 0,0,0,0,0,0,1</code>会发生什么？</p>
<p>这是一个项目程序，我们应该先编译他们：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh&gt; make</span><br></pre></td></tr></table></figure>
<p>编译完成生成了几个可执行的程序，现在我们让buffer长度为1，然后仅仅看看一个生产者和一个消费者的情况</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/ostep-homework/threads-cv</span><br><span class="line">$ ./main-two-cvs-while -p 1 -c1 -m 1 -v</span><br><span class="line"> NF         P0 C0 </span><br><span class="line">  0 [*--- ]    c0</span><br><span class="line">  0 [*--- ] p0</span><br><span class="line">  0 [*--- ]    c1</span><br><span class="line">  0 [*--- ]    c2</span><br><span class="line">  0 [*--- ] p1</span><br><span class="line">  1 [*  0 ] p4</span><br><span class="line">  1 [*  0 ] p5</span><br><span class="line">  1 [*  0 ] p6</span><br><span class="line">  1 [*  0 ]    c3</span><br><span class="line">  0 [*--- ]    c4</span><br><span class="line">  0 [*--- ]    c5</span><br><span class="line">  1 [*EOS ] [main: added end-of-stream marker]</span><br><span class="line">  1 [*EOS ]    c6</span><br><span class="line">  1 [*EOS ]    c0</span><br><span class="line">  1 [*EOS ]    c1</span><br><span class="line">  0 [*--- ]    c4</span><br><span class="line">  0 [*--- ]    c5</span><br><span class="line">  0 [*--- ]    c6</span><br><span class="line"></span><br><span class="line">Consumer consumption:</span><br><span class="line">  C0 -&gt; 1</span><br></pre></td></tr></table></figure>
<p>上面的数码做了一件事：[]中放的是buffer的内容，再往左是buffer的<code>full_num</code>。然后是对应的生产者消费者执行的步骤。（具体请见上面c代码）首先消费者执行c0，然后是消费者执行p0。然后消费者执行c1获取锁。然后while判断货架为空准备进入等待并释放锁。然后生产者获取锁，while判断货架为空跳过等待进行生产，然后唤醒消费者并释放锁。然后消费者苏醒获取锁，进行消费。此时以达到生产线最后元素（EOS）。然后消费者退出循环并返回。最后我们可以看到消费者C0消费了一个商品。上面过程没有出现什么问题。</p>
<p>接下来我们增大buffer尺寸。比如加到10</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/ostep-homework/threads-cv</span><br><span class="line">$ ./main-two-cvs-while -p 1 -c1 -m 10 -v</span><br><span class="line"> NF                                                      P0 C0 </span><br><span class="line">  0 [*---  ---  ---  ---  ---  ---  ---  ---  ---  --- ]    c0</span><br><span class="line">  0 [*---  ---  ---  ---  ---  ---  ---  ---  ---  --- ] p0</span><br><span class="line">  0 [*---  ---  ---  ---  ---  ---  ---  ---  ---  --- ] p1</span><br><span class="line">  1 [u  0 f---  ---  ---  ---  ---  ---  ---  ---  --- ] p4</span><br><span class="line">  1 [u  0 f---  ---  ---  ---  ---  ---  ---  ---  --- ] p5</span><br><span class="line">  1 [u  0 f---  ---  ---  ---  ---  ---  ---  ---  --- ] p6</span><br><span class="line">  1 [u  0 f---  ---  ---  ---  ---  ---  ---  ---  --- ]    c1</span><br><span class="line">  0 [ --- *---  ---  ---  ---  ---  ---  ---  ---  --- ]    c4</span><br><span class="line">  0 [ --- *---  ---  ---  ---  ---  ---  ---  ---  --- ]    c5</span><br><span class="line">  1 [ --- uEOS f---  ---  ---  ---  ---  ---  ---  --- ] [main: added end-of-stream marker]</span><br><span class="line">  1 [ --- uEOS f---  ---  ---  ---  ---  ---  ---  --- ]    c6</span><br><span class="line">  1 [ --- uEOS f---  ---  ---  ---  ---  ---  ---  --- ]    c0</span><br><span class="line">  1 [ --- uEOS f---  ---  ---  ---  ---  ---  ---  --- ]    c1</span><br><span class="line">  0 [ ---  --- *---  ---  ---  ---  ---  ---  ---  --- ]    c4</span><br><span class="line">  0 [ ---  --- *---  ---  ---  ---  ---  ---  ---  --- ]    c5</span><br><span class="line">  0 [ ---  --- *---  ---  ---  ---  ---  ---  ---  --- ]    c6</span><br><span class="line"></span><br><span class="line">Consumer consumption:</span><br><span class="line">  C0 -&gt; 1</span><br></pre></td></tr></table></figure>
<p>可以看到<code>-l</code>不发生变化，实际上和前面差不多，都没有什么问题。</p>
<p>然后我们现在增加生产次数</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/ostep-homework/threads-cv$ ./main-two-cvs-while -p 1 -c1 -m 10 -l 100  -v</span><br><span class="line"> NF                                                      P0 C0 </span><br><span class="line">  0 [*---  ---  ---  ---  ---  ---  ---  ---  ---  --- ] p0</span><br><span class="line">  0 [*---  ---  ---  ---  ---  ---  ---  ---  ---  --- ]    c0</span><br><span class="line">  0 [*---  ---  ---  ---  ---  ---  ---  ---  ---  --- ] p1</span><br><span class="line">  1 [u  0 f---  ---  ---  ---  ---  ---  ---  ---  --- ] p4</span><br><span class="line">  1 [u  0 f---  ---  ---  ---  ---  ---  ---  ---  --- ] p5</span><br><span class="line">  1 [u  0 f---  ---  ---  ---  ---  ---  ---  ---  --- ] p6</span><br><span class="line">...</span><br><span class="line">  1 [f---  ---  ---  ---  ---  ---  ---  ---  --- u 99 ] p5</span><br><span class="line">  1 [f---  ---  ---  ---  ---  ---  ---  ---  --- u 99 ] p6</span><br><span class="line">  1 [f---  ---  ---  ---  ---  ---  ---  ---  --- u 99 ]    c1</span><br><span class="line">  0 [*---  ---  ---  ---  ---  ---  ---  ---  ---  --- ]    c4</span><br><span class="line">  0 [*---  ---  ---  ---  ---  ---  ---  ---  ---  --- ]    c5</span><br><span class="line">  1 [uEOS f---  ---  ---  ---  ---  ---  ---  ---  --- ] [main: added end-of-stream marker]</span><br><span class="line">  1 [uEOS f---  ---  ---  ---  ---  ---  ---  ---  --- ]    c6</span><br><span class="line">  1 [uEOS f---  ---  ---  ---  ---  ---  ---  ---  --- ]    c0</span><br><span class="line">  1 [uEOS f---  ---  ---  ---  ---  ---  ---  ---  --- ]    c1</span><br><span class="line">  0 [ --- *---  ---  ---  ---  ---  ---  ---  ---  --- ]    c4</span><br><span class="line">  0 [ --- *---  ---  ---  ---  ---  ---  ---  ---  --- ]    c5</span><br><span class="line">  0 [ --- *---  ---  ---  ---  ---  ---  ---  ---  --- ]    c6</span><br><span class="line"></span><br><span class="line">Consumer consumption:</span><br><span class="line">  C0 -&gt; 100</span><br></pre></td></tr></table></figure>
<p>可以看到消费者都能够正常获得商品。</p>
<p>现在改变消费者睡眠字符串</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/ostep-homework/threads-cv$ ./main-two-cvs-while -p 1 -c1 -m 10 -l 100  -v</span><br><span class="line"> NF                                                      P0 C0 </span><br><span class="line">  0 [*---  ---  ---  ---  ---  ---  ---  ---  ---  --- ] p0</span><br><span class="line">  0 [*---  ---  ---  ---  ---  ---  ---  ---  ---  --- ]    c0</span><br><span class="line">  0 [*---  ---  ---  ---  ---  ---  ---  ---  ---  --- ] p1</span><br><span class="line">  1 [u  0 f---  ---  ---  ---  ---  ---  ---  ---  --- ] p4</span><br><span class="line">  1 [u  0 f---  ---  ---  ---  ---  ---  ---  ---  --- ] p5</span><br><span class="line">  1 [u  0 f---  ---  ---  ---  ---  ---  ---  ---  --- ] p6</span><br><span class="line">  1 [u  0 f---  ---  ---  ---  ---  ---  ---  ---  --- ]    c1</span><br><span class="line">  0 [ --- *---  ---  ---  ---  ---  ---  ---  ---  --- ]    c4</span><br><span class="line">  0 [ --- *---  ---  ---  ---  ---  ---  ---  ---  --- ] p0</span><br><span class="line">  0 [ --- *---  ---  ---  ---  ---  ---  ---  ---  --- ]    c5</span><br><span class="line">  0 [ --- *---  ---  ---  ---  ---  ---  ---  ---  --- ]    c6</span><br><span class="line">  0 [ --- *---  ---  ---  ---  ---  ---  ---  ---  --- ] p1</span><br><span class="line">  0 [ --- *---  ---  ---  ---  ---  ---  ---  ---  --- ]    c0</span><br><span class="line">  1 [ --- u  1 f---  ---  ---  ---  ---  ---  ---  --- ] p4</span><br><span class="line">  1 [ --- u  1 f---  ---  ---  ---  ---  ---  ---  --- ] p5</span><br><span class="line">...</span><br><span class="line"> 0 [ ---  ---  ---  ---  --- *---  ---  ---  ---  --- ] p1</span><br><span class="line">  1 [ ---  ---  ---  ---  --- u 25 f---  ---  ---  --- ] p4</span><br><span class="line">  1 [ ---  ---  ---  ---  --- u 25 f---  ---  ---  --- ]    c0</span><br><span class="line">  1 [ ---  ---  ---  ---  --- u 25 f---  ---  ---  --- ] p5</span><br><span class="line">  1 [ ---  ---  ---  ---  --- u 25 f---  ---  ---  --- ] p6</span><br><span class="line">  1 [ ---  ---  ---  ---  --- u 25 f---  ---  ---  --- ]    c1</span><br><span class="line">  1 [ ---  ---  ---  ---  --- u 25 f---  ---  ---  --- ] p0</span><br><span class="line">  0 [ ---  ---  ---  ---  ---  --- *---  ---  ---  --- ]    c4</span><br><span class="line">  0 [ ---  ---  ---  ---  ---  --- *---  ---  ---  --- ]    c5</span><br><span class="line">  0 [ ---  ---  ---  ---  ---  --- *---  ---  ---  --- ]    c6</span><br><span class="line">  0 [ ---  ---  ---  ---  ---  --- *---  ---  ---  --- ] p1</span><br><span class="line">  1 [ ---  ---  ---  ---  ---  --- u 26 f---  ---  --- ] p4</span><br><span class="line">  1 [ ---  ---  ---  ---  ---  --- u 26 f---  ---  --- ]    c0</span><br><span class="line">  1 [ ---  ---  ---  ---  ---  --- u 26 f---  ---  --- ] p5</span><br><span class="line">  1 [ ---  ---  ---  ---  ---  --- u 26 f---  ---  --- ] p6</span><br><span class="line">  1 [ ---  ---  ---  ---  ---  --- u 26 f---  ---  --- ] p0</span><br><span class="line">  1 [ ---  ---  ---  ---  ---  --- u 26 f---  ---  --- ]    c1</span><br><span class="line">  0 [ ---  ---  ---  ---  ---  ---  --- *---  ---  --- ]    c4</span><br><span class="line">  0 [ ---  ---  ---  ---  ---  ---  --- *---  ---  --- ]    c5</span><br><span class="line">  0 [ ---  ---  ---  ---  ---  ---  --- *---  ---  --- ]    c6</span><br><span class="line">  0 [ ---  ---  ---  ---  ---  ---  --- *---  ---  --- ] p1</span><br><span class="line">  0 [ ---  ---  ---  ---  ---  ---  --- *---  ---  --- ]    c0</span><br><span class="line">  1 [ ---  ---  ---  ---  ---  ---  --- u 27 f---  --- ] p4</span><br><span class="line">  1 [ ---  ---  ---  ---  ---  ---  --- u 27 f---  --- ] p5</span><br><span class="line">  1 [ ---  ---  ---  ---  ---  ---  --- u 27 f---  --- ] p6</span><br><span class="line">  1 [ ---  ---  ---  ---  ---  ---  --- u 27 f---  --- ]    c1</span><br><span class="line">  1 [ ---  ---  ---  ---  ---  ---  --- u 27 f---  --- ] p0</span><br><span class="line">  0 [ ---  ---  ---  ---  ---  ---  ---  --- *---  --- ]    c4</span><br><span class="line">...</span><br><span class="line">  9 [f--- u  1    2    3    4    5    6    7    8    9 ] p0</span><br><span class="line">  9 [f--- u  1    2    3    4    5    6    7    8    9 ] p1</span><br><span class="line"> 10 [  10 *  1    2    3    4    5    6    7    8    9 ] p4</span><br><span class="line"> 10 [  10 *  1    2    3    4    5    6    7    8    9 ] p5</span><br><span class="line"> 10 [  10 *  1    2    3    4    5    6    7    8    9 ] p6</span><br><span class="line"> 10 [  10 *  1    2    3    4    5    6    7    8    9 ] p0</span><br><span class="line"> 10 [  10 *  1    2    3    4    5    6    7    8    9 ] p1</span><br><span class="line"> 10 [  10 *  1    2    3    4    5    6    7    8    9 ] p2</span><br><span class="line"> 10 [  10 *  1    2    3    4    5    6    7    8    9 ]    c0</span><br><span class="line"> 10 [  10 *  1    2    3    4    5    6    7    8    9 ]    c1</span><br><span class="line">  9 [  10 f--- u  2    3    4    5    6    7    8    9 ]    c4</span><br><span class="line">  9 [  10 f--- u  2    3    4    5    6    7    8    9 ]    c5</span><br><span class="line">  9 [  10 f--- u  2    3    4    5    6    7    8    9 ]    c6</span><br><span class="line">  9 [  10 f--- u  2    3    4    5    6    7    8    9 ] p3</span><br><span class="line">...</span><br><span class="line">  1 [uEOS f---  ---  ---  ---  ---  ---  ---  ---  --- ]    c0</span><br><span class="line">  1 [uEOS f---  ---  ---  ---  ---  ---  ---  ---  --- ]    c1</span><br><span class="line">  0 [ --- *---  ---  ---  ---  ---  ---  ---  ---  --- ]    c4</span><br><span class="line">  0 [ --- *---  ---  ---  ---  ---  ---  ---  ---  --- ]    c5</span><br><span class="line">  0 [ --- *---  ---  ---  ---  ---  ---  ---  ---  --- ]    c6</span><br><span class="line"></span><br><span class="line">Consumer consumption:</span><br><span class="line">  C0 -&gt; 100</span><br></pre></td></tr></table></figure>
<p>看到上面的代码，生产f总是在使用u之前。</p>
<p>同时消费者总是等到缓冲区满了才开始消费。然后消费一个就通知生产者生产直到生产完毕。</p>
<p>此时一切生产消费活动都处于正常状态。</p>
<h3 id="4-2"><a href="#4-2" class="headerlink" title="4."></a>4.</h3><p><img src="/2022/05/19/OS-thread-homework/image-20220516100021157.png" alt="image-20220516100021157"></p>
<p>如果只有一个生产者，三个消费者，只有一个单一入口的buffer，每个消费者在c3指令执行的时候入睡要一秒钟（-C 0,0,0,1,0,0,0）</p>
<p>我们输入指令看看情况发生了什么？</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/ostep-homework/threads-cv</span><br><span class="line">$ ./main-two-cvs-while -p 1 -c 3 -m 1 -C 0,0,0,1,0,0,0:0,0,0,1,0,0,0:0,0,0,1,0,0,0 -l 10 -v -t</span><br><span class="line"> NF         P0 C0 C1 C2 </span><br><span class="line">  0 [*--- ]    c0</span><br><span class="line">  0 [*--- ] p0</span><br><span class="line">  0 [*--- ]       c0</span><br><span class="line">  0 [*--- ]          c0</span><br><span class="line">  0 [*--- ]    c1</span><br><span class="line">  0 [*--- ]    c2</span><br><span class="line">  0 [*--- ] p1</span><br><span class="line">  1 [*  0 ] p4</span><br><span class="line">  1 [*  0 ] p5</span><br><span class="line">  1 [*  0 ] p6</span><br><span class="line">  1 [*  0 ]       c1</span><br><span class="line">...</span><br><span class="line">Consumer consumption:</span><br><span class="line">  C0 -&gt; 0</span><br><span class="line">  C1 -&gt; 10</span><br><span class="line">  C2 -&gt; 0</span><br><span class="line"></span><br><span class="line">Total time: 13.07 seconds</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Consumer consumption:</span><br><span class="line">  C0 -&gt; 9</span><br><span class="line">  C1 -&gt; 0</span><br><span class="line">  C2 -&gt; 1</span><br><span class="line"></span><br><span class="line">Total time: 12.08 seconds</span><br></pre></td></tr></table></figure>
<p>不同次运行同样的命令，每次的运行时间不一致。但至少10s，因为消费者会取出10个数据。每取一个都会有1s的休眠。</p>
<p>可以看到上面的代码能够保证生产10个消费10个，但是存在消费者会被饿死的情况。</p>
<h3 id="8"><a href="#8" class="headerlink" title="8."></a>8.</h3><p><img src="/2022/05/19/OS-thread-homework/image-20220516101427280.png" alt="image-20220516101427280"></p>
<p>现在看看<code>main-one-cv-while.c</code>，现在我们要写一个睡眠字符串，在只有一个生产者和一个消费者和一个缓冲区只有1大小的情况下产生问题。</p>
<p>一个生产者一个消费者不会产生什么问题，因为通信的只有生产者和消费者。但是如果出现两个生产者或者两个消费者的时候，一个条件变量就会不清楚通知的是生产者还是消费者。</p>
<h3 id="9"><a href="#9" class="headerlink" title="9."></a>9.</h3><p><img src="/2022/05/19/OS-thread-homework/image-20220516103344533.png" alt="image-20220516103344533"></p>
<p>这个问题是课本257页表格表示的只有一个条件变量的问题。因为条件变量只有一个，所以所以可能存在一个消费者消费完试图唤醒生产者，但是不是唤醒生产者而是唤醒另外一个消费者，最终造成发出信号的消费者睡着，生产者没有醒过来，另外一个消费者醒过来发现没有东西消费，然后又睡着的情况。最终三个人都睡着了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生产者</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loops; i++) &#123;   p0;	<span class="comment">// 循环生产商品</span></span><br><span class="line">        Mutex_lock(&amp;m);             p1;	<span class="comment">// 获取锁</span></span><br><span class="line">        <span class="keyword">while</span> (num_full == max) &#123;   p2;	<span class="comment">// 如果货架满了</span></span><br><span class="line">            Cond_wait(&amp;empty, &amp;m);  p3;	<span class="comment">// 则睡眠等待货架再次为空时复工</span></span><br><span class="line">        &#125;</span><br><span class="line">        do_fill(base + i);          p4;	<span class="comment">// 进行一次货架填充</span></span><br><span class="line">        Cond_signal(&amp;fill);         p5;	<span class="comment">// 通知消费者可消费</span></span><br><span class="line">        Mutex_unlock(&amp;m);           p6;	<span class="comment">// 释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 消费者</span></span><br><span class="line"><span class="keyword">while</span> (tmp != END_OF_STREAM) &#123; c0; <span class="comment">// 循环直到生产商品流的最后元素</span></span><br><span class="line">        Mutex_lock(&amp;m);            c1; <span class="comment">// 获取锁</span></span><br><span class="line">        <span class="keyword">while</span> (num_full == <span class="number">0</span>) &#123;    c2; <span class="comment">// 如果货架空了</span></span><br><span class="line">            Cond_wait(&amp;fill, &amp;m);  c3; <span class="comment">// 等待生产者填充货架</span></span><br><span class="line">        &#125;</span><br><span class="line">        tmp = do_get();            c4; <span class="comment">// 获取货物</span></span><br><span class="line">        Cond_signal(&amp;empty);       c5; <span class="comment">// </span></span><br><span class="line">        Mutex_unlock(&amp;m);          c6; <span class="comment">// 释放锁</span></span><br></pre></td></tr></table></figure>
<p>我们可以看到p3是进行苏醒的，我们让它睡久一点，就能够触发问题了。比如这里我们让他睡五秒。</p>
<p>得到结果如下</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/ostep-homework/threads-cv</span><br><span class="line">$ ./main-one-cv-while -m 1 -l 5 -c 2 -p 1 -P 0,0,0,10,0,0,0 -v -t</span><br><span class="line"> NF         P0 C0 C1 </span><br><span class="line">  0 [*--- ]       c0</span><br><span class="line">  0 [*--- ] p0</span><br><span class="line">  0 [*--- ]    c0</span><br><span class="line">  0 [*--- ] p1</span><br><span class="line">  1 [*  0 ] p4</span><br><span class="line">...</span><br><span class="line">  0 [*--- ]       c5</span><br><span class="line">  0 [*--- ]       c6</span><br><span class="line"></span><br><span class="line">Consumer consumption:</span><br><span class="line">  C0 -&gt; 5</span><br><span class="line">  C1 -&gt; 0</span><br></pre></td></tr></table></figure>
<p><img src="/2022/05/19/OS-thread-homework/image-20220516105426143.png" alt="image-20220516105426143"></p>
<p>可以看到上面蓝色框框的部分C0消费完，不是唤醒P0，而是唤醒C1。</p>
<p>但是由于它编写的调度器总会在所有程序睡眠后调用生产者进行生产。所以可以看到蓝色框框下面又出现了生产者进行生产。但是实际上如果它的调度程序不这么智慧的话，三个线程都会进入睡眠状态。</p>
<h3 id="10"><a href="#10" class="headerlink" title="10."></a>10.</h3><p><img src="/2022/05/19/OS-thread-homework/image-20220516105828890.png" alt="image-20220516105828890"></p>
<p>这个题目要我们运行<code>main-two-cvs-if.c</code>文件。这个文件对等待函数是用<code>if</code>，也就是说仅仅进行一次判定。要我们考虑一个生产者一个消费者的情况，然后增加消费者的数量。试图产生问题。</p>
<p>我们说一个生产者一个消费者是不会有任何问题的。</p>
<p>但是如果有一个消费者或者以上，那么问题就出现了。这个问题其实就是书本255页介绍的问题。就是说只是进行一次等待判断，但是在两个消费者的时候，可能一个消费者判断有货物可取，然后再在它取之前发生中断，然后另外一个消费者也看到了这个货物，然后它一口气取完了。然后前面一个消费者还蒙在鼓里，以为自己还有货物，实际上已经没有货物了。</p>
<p>所以我们在其中一个消费者的去货物之前让它睡久一点就好，可以看到到c4是去货物所以试着构造这样的字符串</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-C 0,0,0,0,5,0,0:0,0,0,0,0,0,0</span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/ostep-homework/threads-cv</span><br><span class="line">$ ./main-two-cvs-if -m 1 -l 5 -c 2 -p 1 -C 0,0,0,0,5,0,0:0,0,0,0,0,0,0 -v -t</span><br><span class="line"> NF        P0 C0 C1 </span><br><span class="line">  0 [*--- ]    c0</span><br><span class="line">  0 [*--- ] p0</span><br><span class="line">  0 [*--- ]    c1</span><br><span class="line">  0 [*--- ]       c0</span><br><span class="line">  0 [*--- ]    c2</span><br><span class="line">  0 [*--- ] p1</span><br><span class="line">  1 [*  0 ] p4</span><br><span class="line">  1 [*  0 ] p5</span><br><span class="line">  1 [*  0 ] p6</span><br><span class="line">  1 [*  0 ]       c1</span><br><span class="line">  1 [*  0 ] p0</span><br><span class="line">  0 [*--- ]       c4</span><br><span class="line">  0 [*--- ]       c5</span><br><span class="line">  0 [*--- ]       c6</span><br><span class="line">  0 [*--- ]    c3</span><br><span class="line">  0 [*--- ]       c0</span><br><span class="line">error: tried to get an empty buffer</span><br></pre></td></tr></table></figure>
<p>我们很容易就出发了这个错误。问题就是消费者2消费的速度明显更快，然后在15行的地方很快消费了货物，但是消费者1在c3的地方苏醒过来，没有再次判断是不是“假唤醒”（课本260页提示，所谓假唤醒就是唤醒你，但是你但是你没有货物），然后它认为它是有货物取得，所以在20行本来应该是消费者1进行取货c4操作，但是没有货物引起报错。</p>
<h3 id="11"><a href="#11" class="headerlink" title="11."></a>11.</h3><p><img src="/2022/05/19/OS-thread-homework/image-20220516112113947.png" alt="image-20220516112113947"></p>
<p>我们最后考察一个这样的程序<code>main-two-cvs-while-extra-unlock.c</code>。考察它会发生什么样的问题。如果你在放一个货物或者取一个货物之前就释放锁会发生什么。你可依托这一点给出一个睡眠字符串吗？分析发生了什么不好的事情。</p>
<p>和前面的代码不同的地方就在于它的生产者和消费者函数，是在释放锁之后才取资源。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">do_fill</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="comment">// ensure empty before usage</span></span><br><span class="line">    ensure(buffer[fill_ptr] == EMPTY, <span class="string">&quot;error: tried to fill a non-empty buffer&quot;</span>);</span><br><span class="line">    buffer[fill_ptr] = value;</span><br><span class="line">    fill_ptr = (fill_ptr + <span class="number">1</span>) % max;</span><br><span class="line">    num_full++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">do_get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> tmp = buffer[use_ptr];</span><br><span class="line">    ensure(tmp != EMPTY, <span class="string">&quot;error: tried to get an empty buffer&quot;</span>);</span><br><span class="line">    buffer[use_ptr] = EMPTY; </span><br><span class="line">    use_ptr = (use_ptr + <span class="number">1</span>) % max;</span><br><span class="line">    num_full--;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">producer</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="type">int</span> id = (<span class="type">int</span>) arg;</span><br><span class="line">    <span class="comment">// make sure each producer produces unique values</span></span><br><span class="line">    <span class="type">int</span> base = id * loops; </span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loops; i++) &#123;   p0;</span><br><span class="line">        Mutex_lock(&amp;m);             p1;</span><br><span class="line">        <span class="keyword">while</span> (num_full == max) &#123;   p2;</span><br><span class="line">            Cond_wait(&amp;empty, &amp;m);  p3;</span><br><span class="line">        &#125;</span><br><span class="line">        Mutex_unlock(&amp;m);</span><br><span class="line">        do_fill(base + i);          p4;</span><br><span class="line">        Mutex_lock(&amp;m);</span><br><span class="line">        Cond_signal(&amp;fill);         p5;</span><br><span class="line">        Mutex_unlock(&amp;m);           p6;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">                                                                               </span><br><span class="line"><span class="type">void</span> *<span class="title function_">consumer</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="type">int</span> id = (<span class="type">int</span>) arg;</span><br><span class="line">    <span class="type">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> consumed_count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (tmp != END_OF_STREAM) &#123; c0;</span><br><span class="line">        Mutex_lock(&amp;m);            c1;</span><br><span class="line">        <span class="keyword">while</span> (num_full == <span class="number">0</span>) &#123;    c2;</span><br><span class="line">            Cond_wait(&amp;fill, &amp;m);  c3;</span><br><span class="line">        &#125;</span><br><span class="line">        Mutex_unlock(&amp;m);</span><br><span class="line">        tmp = do_get();            c4;</span><br><span class="line">        Mutex_lock(&amp;m);</span><br><span class="line">        Cond_signal(&amp;empty);       c5;</span><br><span class="line">        Mutex_unlock(&amp;m);          c6;</span><br><span class="line">        consumed_count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// return consumer_count-1 because END_OF_STREAM does not count</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span> *) (<span class="type">long</span> <span class="type">long</span>) (consumed_count - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们的公共资源就是buffer，但是把<code>do_fill</code>和<code>do_get</code>放在锁的外面，这个锁就不起作用了。</p>
<p>如果只有一个消费者和生产者由于条件变量和full_num的共同作用，能够保证生产时消费者在睡，消费时生产者在睡。但是，如果有多个生产者和多个消费者的情况下，由于只能保证一个生产者和一个消费者互斥。所以其他的就可以对公共资源进行改写。比如在一个消费者取货物之前可能另外一个生产者覆盖了这个货物。</p>
<p><img src="/2022/05/19/OS-thread-homework/image-20220516114048979.png" alt="image-20220516114048979"></p>
<p>比如这里的2是被消费者0消费了，但是它很可能在c4消费之前，他消费的东西就被别的消费者覆盖了。</p>
<p>我们可以让c4执行慢一点，刚好让别的生产者抢占锁</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-C 0,0,0,0,5,0,0:0,0,0,0,5,0,0</span><br></pre></td></tr></table></figure>
<h2 id="第31章"><a href="#第31章" class="headerlink" title="第31章"></a>第31章</h2><h3 id="1-3"><a href="#1-3" class="headerlink" title="1."></a>1.</h3><p><img src="/2022/05/19/OS-thread-homework/image-20220517094824131.png" alt="image-20220517094824131"></p>
<p>第一题要我们实现fork/join问题，要求自己写一个线程fork-join的程序，你要工作的是作业目录下的<code>fork-join.c</code>文件。同时在<code>child</code>添加<code>sleep(1)</code>试着确定他的正确性。</p>
<p>和课本266页一致，但是要注意几点：</p>
<ul>
<li><code>child</code>释放<code>post</code>信号量应该在孩子已经工作完的情况下</li>
<li>创建完子线程之后，主线程等待子线程完毕</li>
</ul>
<p>下面书写代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common_threads.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">sem_t</span> s; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">child</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child\n&quot;</span>);</span><br><span class="line">    sleep(<span class="number">1</span>); <span class="comment">// 验证父线程是否等待子线程完成</span></span><br><span class="line">    <span class="comment">// use semaphore here</span></span><br><span class="line">    Sem_post(&amp;s)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;parent: begin\n&quot;</span>);</span><br><span class="line">    <span class="comment">// init semaphore here</span></span><br><span class="line">    Sem_init(&amp;s, <span class="number">0</span>)</span><br><span class="line">    Pthread_create(&amp;p, <span class="literal">NULL</span>, child, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// use semaphore here</span></span><br><span class="line">    Sem_wait(&amp;s)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;parent: end\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于上述代码有几点说明：</p>
<ul>
<li>这里关于信号量的使用用的是宏定义函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> Sem_init(sem, value)                             assert(sem_init(sem, 0, value) == 0);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Sem_wait(sem)                                    assert(sem_wait(sem) == 0);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Sem_post(sem)                                    assert(sem_post(sem) == 0);</span></span><br></pre></td></tr></table></figure>
<ul>
<li>运行编译时，需要加上<code>-pthread</code>的<code>tag</code>运行结果如下</li>
</ul>
<p>​    <img src="/2022/05/19/OS-thread-homework/image-20220517114856648.png" alt="image-20220517114856648"></p>
<ul>
<li>当加入<code>sleep(1)</code>的时候同样运行正确，验证代码正确性。</li>
</ul>
<h3 id="2-3"><a href="#2-3" class="headerlink" title="2."></a>2.</h3><p><img src="/2022/05/19/OS-thread-homework/image-20220517115033332.png" alt="image-20220517115033332"></p>
<p>现在看看<code>rendezvous</code>问题。这个问题表述如下：你有两个线程，每一个线程都将要进入到<code>rendezvous</code>点执行代码。每一部分都不会在其他线程进入这个代码的时候退出，而是等待。思考使用两个信号量实现这个过程。详见<code>rendezvous.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common_threads.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果编写的代码正确，每一个子线程会打印各自的before信息，然后再打印各自的after信息</span></span><br><span class="line"><span class="comment">// 加入sleep(1)测试程序正确性</span></span><br><span class="line"></span><br><span class="line"><span class="type">sem_t</span> s1, s2;</span><br><span class="line"><span class="comment">// 两个信号量用于分别管理child1和child2的等待和继续</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">child_1</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child 1: before\n&quot;</span>);</span><br><span class="line">    <span class="comment">// what goes here?</span></span><br><span class="line">    Sem_wait(&amp;s1)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child 1: after\n&quot;</span>);</span><br><span class="line">    Sem_post(&amp;s2)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">child_2</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">	sleep(<span class="number">1</span>);	<span class="comment">// 先睡一会在工作</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child 2: before\n&quot;</span>);</span><br><span class="line">    <span class="comment">// what goes here?</span></span><br><span class="line">    Sem_post(&amp;s1)</span><br><span class="line">    Sem_wait(&amp;s2)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child 2: after\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> p1, p2;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;parent: begin\n&quot;</span>);</span><br><span class="line">    <span class="comment">// init semaphores here</span></span><br><span class="line">    Sem_init(&amp;s1, <span class="number">0</span>)</span><br><span class="line">    Sem_init(&amp;s2, <span class="number">0</span>)</span><br><span class="line">    Pthread_create(&amp;p1, <span class="literal">NULL</span>, child_1, <span class="literal">NULL</span>);</span><br><span class="line">    Pthread_create(&amp;p2, <span class="literal">NULL</span>, child_2, <span class="literal">NULL</span>);</span><br><span class="line">    Pthread_join(p1, <span class="literal">NULL</span>);</span><br><span class="line">    Pthread_join(p2, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;parent: end\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一点说明：这里把信号量作为条件变量使用，当条件变量发生变化，可以继续执行。可以看到如果<code>child1</code>先工作，它打印完它的before信息之后，会等待s1的讯息。然后<code>child2</code>输出它的before信息，然后它唤醒<code>child1</code>，然后自己进入睡眠等待<code>child1</code>打印它的after信息，然后<code>child1</code>打印完会唤醒<code>child2</code>，<code>child2</code>打印after讯息。最终实现次序打印。</p>
<p>结果如下：</p>
<p><img src="/2022/05/19/OS-thread-homework/image-20220517121316512.png" alt="image-20220517121316512"></p>
<h3 id="4-3"><a href="#4-3" class="headerlink" title="4."></a>4.</h3><p><img src="/2022/05/19/OS-thread-homework/image-20220517123707241.png" alt="image-20220517123707241"></p>
<p>这道题要求我们自己编写读写锁的详细代码。在这里我们不需要考虑饿死的问题。</p>
<p>代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common_threads.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Your code goes in the structure and functions below</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">rwlock_t</span> &#123;</span></span><br><span class="line">    <span class="type">sem_t</span> lock;						<span class="comment">// 二值信号量，用作基础锁，保证对readers操作的原子性</span></span><br><span class="line">    <span class="type">sem_t</span> writelock;				<span class="comment">// 写锁</span></span><br><span class="line">    <span class="type">int</span> readers;					<span class="comment">// 读者的数量</span></span><br><span class="line">&#125; <span class="type">rwlock_t</span>;</span><br><span class="line"></span><br><span class="line">			</span><br><span class="line"><span class="type">void</span> <span class="title function_">rwlock_init</span><span class="params">(<span class="type">rwlock_t</span> *rw)</span> &#123;</span><br><span class="line">    rw-&gt;readers = <span class="number">0</span>;				<span class="comment">// 读者的数量</span></span><br><span class="line">    Sem_init(&amp;rw-&gt;lock, <span class="number">1</span>)			<span class="comment">// 基础锁初始化</span></span><br><span class="line">    Sem_init(&amp;rw-&gt;writelock, <span class="number">1</span>)		<span class="comment">// 写锁初始化</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rwlock_acquire_readlock</span><span class="params">(<span class="type">rwlock_t</span> *rw)</span> &#123;</span><br><span class="line">    Sem_wait(&amp;rw-&gt;lock)</span><br><span class="line">    rw-&gt;readers++;</span><br><span class="line">    <span class="keyword">if</span> (rw-&gt;readers == <span class="number">1</span>)</span><br><span class="line">        Sem_wait(&amp;rw-&gt;writelock)</span><br><span class="line">    Sem_post(&amp;rw-&gt;lock)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rwlock_release_readlock</span><span class="params">(<span class="type">rwlock_t</span> *rw)</span> &#123;</span><br><span class="line">    Sem_wait(&amp;rw-&gt;lock)</span><br><span class="line">    rw-&gt;readers--;</span><br><span class="line">    <span class="keyword">if</span> (rw-&gt;readers == <span class="number">0</span>)</span><br><span class="line">        Sem_post(&amp;rw-&gt;writelock)</span><br><span class="line">    Sem_post(&amp;rw-&gt;lock)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rwlock_acquire_writelock</span><span class="params">(<span class="type">rwlock_t</span> *rw)</span> &#123;</span><br><span class="line">    Sem_wait(&amp;rw-&gt;writelock)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rwlock_release_writelock</span><span class="params">(<span class="type">rwlock_t</span> *rw)</span> &#123;</span><br><span class="line">    Sem_post(&amp;rw-&gt;writelock)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Don&#x27;t change the code below (just use it!)</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> loops;</span><br><span class="line"><span class="type">int</span> value = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">rwlock_t</span> lock;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">reader</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loops; i++) &#123;</span><br><span class="line">        rwlock_acquire_readlock(&amp;lock);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;read %d\n&quot;</span>, value);</span><br><span class="line">        rwlock_release_readlock(&amp;lock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">writer</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loops; i++) &#123;</span><br><span class="line">        rwlock_acquire_writelock(&amp;lock);</span><br><span class="line">        value++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;write %d\n&quot;</span>, value);</span><br><span class="line">        rwlock_release_writelock(&amp;lock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="comment">// 获取参数</span></span><br><span class="line">    assert(argc == <span class="number">4</span>);</span><br><span class="line">    <span class="type">int</span> num_readers = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="type">int</span> num_writers = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">    loops = atoi(argv[<span class="number">3</span>]);</span><br><span class="line">    <span class="comment">// 创建进程池</span></span><br><span class="line">    <span class="type">pthread_t</span> pr[num_readers], pw[num_writers];</span><br><span class="line">    <span class="comment">// 读写锁初始化</span></span><br><span class="line">    rwlock_init(&amp;lock);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;begin\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 创建所有读者和写着</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_readers; i++)</span><br><span class="line">        Pthread_create(&amp;pr[i], <span class="literal">NULL</span>, reader, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_writers; i++)</span><br><span class="line">        Pthread_create(&amp;pw[i], <span class="literal">NULL</span>, writer, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 主线程等待所有读者写者完成任务</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_readers; i++)</span><br><span class="line">        Pthread_join(pr[i], <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_writers; i++)</span><br><span class="line">        Pthread_join(pw[i], <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;end: value %d\n&quot;</span>, value);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下</p>
<p><img src="/2022/05/19/OS-thread-homework/image-20220517131624836.png" alt="image-20220517131624836"></p>
<p>存在读者饿死写着的问题。看到上面的实验结果显示只有读者全部读完了才开始写。根据代码我们也可以看出来。第一个读者获取写锁，所以任何写者都不可以写，而在第一个读者获得写锁后，其他的读者是可以获得读锁的。一旦某一个读者抢到了写锁，其他的读者都会蜂拥而入（它们不受任何阻碍）然后执行读操作。而写者呢？它们很不幸，如果它们没有任何一个读者快抢到<code>writelock</code>，则它们不能够执行写，因为<code>writelock</code>还在第一个读者手上(<code>writelock</code>移交到最后一个读者手上了才释放)，所以这些读者只能够等待几乎所有读者读完才能够进行写操作。同时还要保证在它们被最后一个读者唤醒之后没有其他读者和他们竞争，才能够安稳进行写操作。</p>
<h3 id="5-1"><a href="#5-1" class="headerlink" title="5."></a>5.</h3><p><img src="/2022/05/19/OS-thread-homework/image-20220517133750012.png" alt="image-20220517133750012"></p>
<p>现在我们要写一个没有上面描述到的饥饿问题的程序。实际上我们需要做到的是：如何能够在有写者等待的时候，避免有更多的读者进入并持有锁。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common_threads.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Your code goes in the structure and functions below</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">rwlock_t</span> &#123;</span></span><br><span class="line">    <span class="type">sem_t</span> lock;						<span class="comment">// 二值信号量，用作基础锁</span></span><br><span class="line">    								<span class="comment">// 保证对writers和readers操作的原子性</span></span><br><span class="line">    <span class="type">sem_t</span> writelock;				<span class="comment">// 写锁</span></span><br><span class="line">    <span class="type">int</span> readers;					<span class="comment">// 读者的数量</span></span><br><span class="line">    <span class="type">int</span> writers;</span><br><span class="line">&#125; <span class="type">rwlock_t</span>;</span><br><span class="line"></span><br><span class="line">			</span><br><span class="line"><span class="type">void</span> <span class="title function_">rwlock_init</span><span class="params">(<span class="type">rwlock_t</span> *rw)</span> &#123;</span><br><span class="line">    rw-&gt;readers = <span class="number">0</span>;				<span class="comment">// 读者的数量</span></span><br><span class="line">    rw-&gt;writers = <span class="number">0</span>;				<span class="comment">// 等待写的写者数量</span></span><br><span class="line">    Sem_init(&amp;rw-&gt;lock, <span class="number">1</span>)			<span class="comment">// 基础锁初始化</span></span><br><span class="line">    Sem_init(&amp;rw-&gt;writelock, <span class="number">1</span>)		<span class="comment">// 写锁初始化</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rwlock_acquire_readlock</span><span class="params">(<span class="type">rwlock_t</span> *rw)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    Sem_wait(&amp;rw-&gt;lock)</span><br><span class="line">    <span class="keyword">while</span> (rw-&gt;writers &gt; <span class="number">0</span>)			<span class="comment">// 判断是否有写者进行等待</span></span><br><span class="line">        ; <span class="comment">// spin					// 自旋等待</span></span><br><span class="line">    rw-&gt;readers++;</span><br><span class="line">    <span class="keyword">if</span> (rw-&gt;readers == <span class="number">1</span>)</span><br><span class="line">        Sem_wait(&amp;rw-&gt;writelock)</span><br><span class="line">    Sem_post(&amp;rw-&gt;lock)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rwlock_release_readlock</span><span class="params">(<span class="type">rwlock_t</span> *rw)</span> &#123;</span><br><span class="line">    Sem_wait(&amp;rw-&gt;lock)</span><br><span class="line">    rw-&gt;readers--;</span><br><span class="line">    <span class="keyword">if</span> (rw-&gt;readers == <span class="number">0</span>)</span><br><span class="line">        Sem_post(&amp;rw-&gt;writelock)</span><br><span class="line">    Sem_post(&amp;rw-&gt;lock)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rwlock_acquire_writelock</span><span class="params">(<span class="type">rwlock_t</span> *rw)</span> &#123;</span><br><span class="line">    <span class="comment">// 写者申请写锁前先将等待数目加一</span></span><br><span class="line">    Sem_wait(&amp;rw-&gt;lock)</span><br><span class="line">    rw-&gt;writers++;</span><br><span class="line">    Sem_post(&amp;rw-&gt;lock)</span><br><span class="line">    <span class="comment">// 申请写锁</span></span><br><span class="line">    Sem_wait(&amp;rw-&gt;writelock)</span><br><span class="line">    <span class="comment">// 写者获得写锁把等待数目减一</span></span><br><span class="line">    Sem_wait(&amp;rw-&gt;lock)</span><br><span class="line">    rw-&gt;writers--;</span><br><span class="line">    Sem_post(&amp;rw-&gt;lock)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rwlock_release_writelock</span><span class="params">(<span class="type">rwlock_t</span> *rw)</span> &#123;</span><br><span class="line">    Sem_post(&amp;rw-&gt;writelock)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面的代码和上面的文件没有什么区别</span></span><br></pre></td></tr></table></figure>
<p>这种策略实际上是一种写者优先的策略。由于读写锁的策略是针对多数读者少数写者的情况。这里我采用简单的自旋技术，让读者在申请锁之前总需要先判断一下是否有写者等待，如果有读者自选等待。然后在<code>rwlock_acquire_writelock</code>的代码中对<code>writers</code>的改写需要保证原子性，所以需要上锁。但是我们需要把锁的范围缩小到上面的仅对加减<code>writers</code>的操作上锁解锁。从第51行到第53行可能发生中断，使得尽管写者已经释放了锁，但是等待数目没有来得及减。但是此时所有读者仍然在等待减完才能抢占CPU。这一点在这里不用担心。</p>
<p>最后我们看一种夸张的情况，每一个读者在抢占锁之前都睡眠一秒钟。结果显示能够让写者先进行写操作。说明我们解决了饥饿的问题。</p>
<p><img src="/2022/05/19/OS-thread-homework/image-20220517145756037.png" alt="image-20220517145756037"></p>
<h3 id="6-1"><a href="#6-1" class="headerlink" title="6."></a>6.</h3><p><img src="/2022/05/19/OS-thread-homework/image-20220517145842415.png" alt="image-20220517145842415"></p>
<p>现在要用信号量实现没有饥饿问题的互斥量也就是锁。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common_threads.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Here, you have to write (almost) ALL the code. Oh no!</span></span><br><span class="line"><span class="comment">// How can you show that a thread does not starve</span></span><br><span class="line"><span class="comment">// when attempting to acquire this mutex you build?</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">ns_mutex_t</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> ticket;</span><br><span class="line">	<span class="type">int</span> turn;</span><br><span class="line">	<span class="type">sem_t</span> stic;</span><br><span class="line">	<span class="type">sem_t</span> stur;</span><br><span class="line">&#125; <span class="type">ns_mutex_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ns_mutex_init</span><span class="params">(<span class="type">ns_mutex_t</span> *m)</span> &#123;</span><br><span class="line">	Sem_init(&amp;m-&gt;stic, <span class="number">1</span>)</span><br><span class="line">	Sem_init(&amp;m-&gt;stur, <span class="number">1</span>)</span><br><span class="line">	m-&gt;ticket = <span class="number">0</span>;</span><br><span class="line">	m-&gt;turn = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ns_mutex_acquire</span><span class="params">(<span class="type">ns_mutex_t</span> *m)</span> &#123;</span><br><span class="line">	<span class="comment">// FetchAndAdd(&amp;m-&gt;stic)</span></span><br><span class="line">	Sem_wait(&amp;m-&gt;stic)</span><br><span class="line">	<span class="type">int</span> myturn = m-&gt;ticket++;</span><br><span class="line">	Sem_post(&amp;m-&gt;stic)</span><br><span class="line">    <span class="comment">// 自旋等待轮询到自己</span></span><br><span class="line">	<span class="keyword">while</span> (m-&gt;turn != myturn)</span><br><span class="line">		; <span class="comment">// spin</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ns_mutex_release</span><span class="params">(<span class="type">ns_mutex_t</span> *m)</span> &#123;</span><br><span class="line">	<span class="comment">// FetchAndAdd(&amp;m-&gt;stur)</span></span><br><span class="line">	Sem_wait(&amp;m-&gt;stur)</span><br><span class="line">	m-&gt;turn++;</span><br><span class="line">	Sem_post(&amp;m-&gt;stur)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> value = <span class="number">0</span>;</span><br><span class="line"><span class="type">ns_mutex_t</span> lock;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">worker</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">	ns_mutex_acquire(&amp;lock);</span><br><span class="line">	<span class="type">int</span> tmp = value++;</span><br><span class="line">	ns_mutex_release(&amp;lock);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;tid: %ld &gt; %d\n&quot;</span>, pthread_self(), tmp);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">	assert(argc == <span class="number">2</span>);</span><br><span class="line">	<span class="type">int</span> num_workers = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">	</span><br><span class="line">	<span class="type">pthread_t</span> pool[num_workers];</span><br><span class="line">	ns_mutex_init(&amp;lock);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;parent: begin\n&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_workers; i++)</span><br><span class="line">		Pthread_create(&amp;pool[i], <span class="literal">NULL</span>, worker, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_workers; i++)</span><br><span class="line">		Pthread_join(pool[i], <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;parent: end\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于上面的代码，我们需要的是公平性，我们可以通过学习Mellor-Crummey和Michael Scott提出来的ticket和turn的机制（课本228页）写出代码如上。主要是用了这种turn的轮询机制。通过锁的全局<code>ticket</code>和<code>turn</code>，以及每个线程申请时的<code>myturn</code>来实现公平。课本上主要使用原语<code>FetchAndAdd</code>实现对<code>lock-&gt;turn</code>和<code>lock-&gt;ticket</code>原子操作，这里我们用信号量生成的锁来实现这种原语。其实上面带有<code>FetchAndAdd</code>的注释的地方的代码相当于下面</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FetchAndAdd(sema) &#123;</span></span><br><span class="line">	Sem_wait(&amp;m-&gt;stic)			 \</span><br><span class="line">	<span class="comment">/* 某些操作 */</span>				  \</span><br><span class="line">	Sem_post(&amp;m-&gt;stic)			\</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终运行结果如下，我们可以清楚看到，每个线程都调度了，达到了相对的公平性。</p>
<p><img src="/2022/05/19/OS-thread-homework/image-20220519222752600.png" alt="image-20220519222752600"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Puitar</p>
  <div class="site-description" itemprop="description">博客萌新时不时送来没什么软用的文章</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">18</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>
  <div class="sidebar-button motion-element"><i class="fa fa-comment"></i>
    Chat
  </a>
  </div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/PUITAR" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;PUITAR" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/1831979740@qq.com" title="E-Mail → 1831979740@qq.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Puitar</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>















  

  

  

</body>
</html>
