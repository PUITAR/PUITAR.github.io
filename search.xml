<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>inDoor</title>
    <url>/2022/07/17/inDoor/</url>
    <content><![CDATA[<h1 id="物联网设计大赛室内图层添加"><a href="#物联网设计大赛室内图层添加" class="headerlink" title="物联网设计大赛室内图层添加"></a>物联网设计大赛室内图层添加</h1><p>用来提取室内图片，图片如下</p>
<p><img src="/2022/07/17/inDoor/zonghelou.svg"></p>
]]></content>
      <categories>
        <category>物联网设计大赛</category>
        <category>素材</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>物联网设计大赛</tag>
      </tags>
  </entry>
  <entry>
    <title>人流统计模块说明</title>
    <url>/2022/06/22/%E4%BA%BA%E6%B5%81%E7%BB%9F%E8%AE%A1%E6%A8%A1%E5%9D%97%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<h1 id="人流统计模块讲解"><a href="#人流统计模块讲解" class="headerlink" title="人流统计模块讲解"></a>人流统计模块讲解</h1><p>我们使用<code>onenet</code>提供的AI平台的接口</p>
<h2 id="人体检测"><a href="#人体检测" class="headerlink" title="人体检测"></a>人体检测</h2><h3 id="能力介绍"><a href="#能力介绍" class="headerlink" title="能力介绍"></a>能力介绍</h3><p>接口能力：检测并定位图片中无遮挡的人体，返回人体位置和置信度（0~1），可实现多人体检测；</p>
<p>图片格式：现支持PNG、JPG、JPEG、BMP，不支持GIF图片；</p>
<p>图片大小：上传图片大小不超过2M；图片中识别的人体不被遮挡，人体区域高度120像素以上，宽度80像素以上；</p>
<p>业务应用：智慧零售人流量统计、人体跟踪、安防监控。</p>
<h3 id="API调用方式"><a href="#API调用方式" class="headerlink" title="API调用方式"></a>API调用方式</h3><div class="table-container">
<table>
<thead>
<tr>
<th><code>请求方式</code></th>
<th><code>POST</code></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>url</code></td>
<td><code>http://ai.heclouds.com:9090/v1/aiApi/picture/BODY_RECO</code></td>
</tr>
<tr>
<td><code>http-header</code></td>
<td><code>token</code>: xxxxxxxxxxxxxxxxx  //通过AI Key和Secret Key鉴权（推荐）</td>
</tr>
<tr>
<td><code>request-body</code></td>
<td><code>&#123;    &quot;picture&quot;: [&quot;String&quot;]  //一张图片的base64图片编码</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="下面是python的示例代码"><a href="#下面是python的示例代码" class="headerlink" title="下面是python的示例代码"></a>下面是python的示例代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;http://ai.heclouds.com:9090/v1/aiApi/picture/BODY_RECO&#x27;</span></span><br><span class="line">headers =&#123;</span><br><span class="line">    <span class="string">&#x27;Content-Type&#x27;</span>:<span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;token&#x27;</span>:<span class="string">&#x27;xxxxxxxxxxxxxxxxx(用户鉴权接口返回结果中的accessToken)&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开图片文件</span></span><br><span class="line">file = <span class="built_in">open</span>(<span class="string">&#x27;D:/Desktop/体验图片/03人体检测/body5.png&#x27;</span>,<span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将其转为base64信息</span></span><br><span class="line">base64Str = base64.b64encode(file.read()).decode()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭打开的文件</span></span><br><span class="line">file.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造接口调用参数</span></span><br><span class="line">data = &#123;</span><br><span class="line">  <span class="string">&#x27;picture&#x27;</span>:[base64Str]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># POST 方式调用</span></span><br><span class="line">response = requests.request(<span class="string">&quot;POST&quot;</span>, url, headers=headers, data=json.dumps(data))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印结果</span></span><br><span class="line"><span class="built_in">print</span>(response.text)</span><br></pre></td></tr></table></figure>
<h3 id="返回示例"><a href="#返回示例" class="headerlink" title="返回示例"></a>返回示例</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;stateCode&quot;</span>: <span class="string">&quot;0x0000&quot;</span>, //结果状态码，16进制。<span class="string">&quot;0x0000&quot;</span>：成功</span><br><span class="line">    <span class="string">&quot;message&quot;</span>: <span class="string">&quot;success&quot;</span>,  //返回信息</span><br><span class="line">    <span class="string">&quot;data&quot;</span>: Array  //JSON对象数组，每一个JSON对象表示一个人体，包含了人体在图片中的位置、大小，标签，置信度</span><br><span class="line">&#125;</span><br><span class="line">例如:</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        //人体在图片中的位置、大小</span><br><span class="line">        <span class="string">&quot;box&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;x&quot;</span>: 50,</span><br><span class="line">            <span class="string">&quot;y&quot;</span>: 270,</span><br><span class="line">            <span class="string">&quot;width&quot;</span>: 795,</span><br><span class="line">            <span class="string">&quot;height&quot;</span>: 978</span><br><span class="line">        &#125;,</span><br><span class="line">        //置信度（0~1）</span><br><span class="line">        <span class="string">&quot;confidence&quot;</span>: 0.9998502731323242,</span><br><span class="line">        //标签</span><br><span class="line">        <span class="string">&quot;label&quot;</span>: <span class="string">&quot;person&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line">注意：</span><br><span class="line">http错误码返回<span class="string">&quot;401&quot;</span>时表示<span class="string">&quot;未经授权&quot;</span>，造成的原因有：未使用或使用的token不正确；使用的token已经超时失效。</span><br></pre></td></tr></table></figure>
<h2 id="代码说明"><a href="#代码说明" class="headerlink" title="代码说明"></a>代码说明</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获得tocken对应的keys</span></span><br><span class="line">aiKey = <span class="string">&#x27;d071c2afa0f14fb28d40be114e524984&#x27;</span></span><br><span class="line">secretKey = <span class="string">&#x27;209e5e8fb0b64299b671cc8a0c3a3592&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取access Token</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_access_token</span>(<span class="params">aikey, seckey</span>):</span><br><span class="line">    tkUrl = <span class="string">&#x27;http://ai.heclouds.com:9090/v1/user/app/accessToken?aiKey=%s&amp;secretKey=%s&#x27;</span> % (aiKey, secretKey)</span><br><span class="line">    tkheader = &#123;</span><br><span class="line">        <span class="string">&quot;Content-Type&quot;</span> : <span class="string">&quot;application/json&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># 获得tocken返回的json</span></span><br><span class="line">    r = requests.get(url=tkUrl, headers=tkheader).json()</span><br><span class="line">    <span class="keyword">return</span> r[<span class="string">&quot;data&quot;</span>][<span class="string">&quot;accessToken&quot;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getRes</span>():</span><br><span class="line">    url = <span class="string">&#x27;http://ai.heclouds.com:9090/v1/aiApi/picture/BODY_RECO&#x27;</span></span><br><span class="line">    headers =&#123;</span><br><span class="line">        <span class="string">&#x27;Content-Type&#x27;</span>:<span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;token&#x27;</span>: get_access_token(aiKey, secretKey)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># 打开图片文件</span></span><br><span class="line">    file = <span class="built_in">open</span>(<span class="string">&#x27;1.png&#x27;</span>,<span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">    <span class="comment"># 将其转为base64信息</span></span><br><span class="line">    base64Str = base64.b64encode(file.read()).decode()</span><br><span class="line">    <span class="comment"># 关闭打开的文件</span></span><br><span class="line">    file.close()</span><br><span class="line">    <span class="comment"># 构造接口调用参数</span></span><br><span class="line">    data = &#123;</span><br><span class="line">        <span class="string">&#x27;picture&#x27;</span>:[base64Str]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># POST 方式调用</span></span><br><span class="line">    response = requests.request(<span class="string">&quot;POST&quot;</span>, url, headers=headers, data=json.dumps(data)).json()</span><br><span class="line">    <span class="comment"># 打印结果</span></span><br><span class="line">    <span class="comment"># print(len(response[&quot;data&quot;]))</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(response[<span class="string">&quot;data&quot;</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    getRes()</span><br></pre></td></tr></table></figure>
<p>注释已经讲解的很清楚了。上一个函数是获得<code>accessToken</code>的函数，下一个就是获取答案，由于答案是返回一个json数组，每一个元素就是一个人体，一个框框的信息。我们直接次<code>len</code>函数获得数组的元素个数。我们就可以获得实时人数。</p>
]]></content>
      <categories>
        <category>物联网设计大赛</category>
        <category>模块</category>
      </categories>
      <tags>
        <tag>物联网设计大赛</tag>
        <tag>python</tag>
        <tag>oneOS</tag>
        <tag>oneNet</tag>
        <tag>人流统计</tag>
      </tags>
  </entry>
  <entry>
    <title>三按键测试工程</title>
    <url>/2022/06/30/%E4%B8%89%E6%8C%89%E9%94%AE%E6%B5%8B%E8%AF%95%E5%B7%A5%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="三按键测试"><a href="#三按键测试" class="headerlink" title="三按键测试"></a>三按键测试</h1><h2 id="文件结构说明"><a href="#文件结构说明" class="headerlink" title="文件结构说明"></a>文件结构说明</h2><p><img src="/2022/06/30/%E4%B8%89%E6%8C%89%E9%94%AE%E6%B5%8B%E8%AF%95%E5%B7%A5%E7%A8%8B/image-20220630084706907.png" alt="image-20220630084706907"></p>
<p>在前几个实验的基础上，增加了<code>key.h</code>和<code>beep.h</code></p>
<h3 id="KEY-H头文件"><a href="#KEY-H头文件" class="headerlink" title="KEY.H头文件"></a>KEY.H头文件</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**********************************key V2.0 说明 ************************************************************************</span></span><br><span class="line"><span class="comment">Key模块用于获取“STC-B学习板”上三个按键的状态。提供按键模块加载和一个应用函数,一个“按键事件：enumEventKey：</span></span><br><span class="line"><span class="comment">  (1) KeyInit()：按键模块加载函数；</span></span><br><span class="line"><span class="comment">  (2) char GetKeyAct(char Key)：获取按键状态。</span></span><br><span class="line"><span class="comment">        函数参数：Key，指定要获取状态的按键。Key取值：</span></span><br><span class="line"><span class="comment">						enumKey1</span></span><br><span class="line"><span class="comment">						enumKey2</span></span><br><span class="line"><span class="comment">						enumKey3    </span></span><br><span class="line"><span class="comment">    			（当参数取值超出有效范围，函数将返回fail）</span></span><br><span class="line"><span class="comment">        函数返回值：</span></span><br><span class="line"><span class="comment">						enumKeyNull（无按键动作）</span></span><br><span class="line"><span class="comment">						enumKeyPress（按下）</span></span><br><span class="line"><span class="comment">						enumKeyRelease（抬起）</span></span><br><span class="line"><span class="comment">						enumKeyFail（失败） </span></span><br><span class="line"><span class="comment">	  	返回值是经过多次检测按键实时状态和统计检测结果后（软件消抖）的有效事件。</span></span><br><span class="line"><span class="comment">    	每个按键查询一次后,事件值变成enumKeyNull。事件值仅查询一次有效。</span></span><br><span class="line"><span class="comment">  (3) 按键事件：enumEventKey</span></span><br><span class="line"><span class="comment">      当三个按键（enumKey1,enumKey2,enumKey3）中任意一个按键有”按下“或”抬起“动作时，将产生一个”按键事件“，</span></span><br><span class="line"><span class="comment">      响应按键事件的用户处理函数由用户编写,并有sys中提供的SetEventCallBack函数设置.	 </span></span><br><span class="line"><span class="comment">      补充说明：如果启用了ADC模块，按键3（Key3）任何操作在本模块不可检测到和有任何信息反应，</span></span><br><span class="line"><span class="comment">      这时按键3（Key3）任何操作将在  ADC模块中检测和反应。使用方法相同，具体见ADC模块说明。	</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _key_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _key_H_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">KeyInit</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">GetKeyAct</span><span class="params">(<span class="type">char</span> Key)</span> ; <span class="comment">//获取按键enumKey1,enumKey2,enumKey3事件</span></span><br><span class="line"><span class="comment">//返回值：enumKeyNull——无，enumKeyPress——下降沿，enumKeyRelease——上升沿，enumKeyFail——错误</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">KeyName</span>     &#123;</span>enumKey1,enumKey2,enumKey3&#125;;                          <span class="comment">//按键名</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">KeyActName</span>  &#123;</span>enumKeyNull,enumKeyPress,enumKeyRelease,enumKeyFail&#125;; <span class="comment">//按键动作名</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="BEEP-H"><a href="#BEEP-H" class="headerlink" title="BEEP.H"></a>BEEP.H</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Beep V2.0 说明 </span></span><br><span class="line"><span class="comment">Beep用于控制“STC-B学习板”上无源蜂鸣器的发声。Beep模块共提供1个驱动函数、2个应用函数：</span></span><br><span class="line"><span class="comment">  (1)  BeepInit(): 蜂鸣器模块驱动函数</span></span><br><span class="line"><span class="comment">  (2)  Set_Beep(unsigned int Beep_freq, unsigned char Beep_time): 控制蜂鸣器发声，非阻塞型</span></span><br><span class="line"><span class="comment">	   函数参数：</span></span><br><span class="line"><span class="comment">       Beep_freq：指定发声频率，单位Hz。小于10将无输出  </span></span><br><span class="line"><span class="comment">	   Beep_time：指定发声时长。发声时长＝10*Beep_time(mS)，最长 655350mS</span></span><br><span class="line"><span class="comment">	   函数返回值：enumSetBeepOK：调用成功，enumSetBeepFail：调用失败（或因蜂鸣器正在发音）	 </span></span><br><span class="line"><span class="comment">  (3)  GetBeepStatus(void): 获取Beep当前状态,enmuBeepFree:空闲, enumBeepBusy ,正在发音</span></span><br><span class="line"><span class="comment">  (4)  Beep模块使用了STC内部CCP模块1通道</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _beep_H_			</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _beep_H_		</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">BeepInit</span><span class="params">()</span>;	<span class="comment">// 蜂鸣器初始化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> <span class="title function_">SetBeep</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> Beep_freq, <span class="type">unsigned</span> <span class="type">int</span> Beep_time)</span>;   </span><br><span class="line"><span class="comment">// 发指定频率声音， 发声时长＝10×Beep_time	  (mS)  ，最长 655350mS</span></span><br><span class="line"><span class="comment">// Beep_freq &lt; 10 Hz, 不发音</span></span><br><span class="line"><span class="comment">// 函数返回 enumSetBeepOK：调用成功，   enumSetBeepFail：调用失败（调用时正在发音）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">GetBeepStatus</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">// 获取状态,enumBeepFree:自由, enumBeepBusy,正在发声</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">BeepActName</span> &#123;</span>enumBeepFree=<span class="number">0</span>,enumBeepBusy,enumSetBeepOK,enumSetBeepFail&#125;; </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h2 id="BSP版本主函数逻辑"><a href="#BSP版本主函数逻辑" class="headerlink" title="BSP版本主函数逻辑"></a>BSP版本主函数逻辑</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;STC15F2K60S2.H&quot;</span>        <span class="comment">//必须。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.H&quot;</span>                 <span class="comment">//必须。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;displayer.H&quot;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;key.H&quot;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;beep.H&quot;</span> </span></span><br><span class="line"></span><br><span class="line">code <span class="type">unsigned</span> <span class="type">long</span> SysClock=<span class="number">11059200</span>; <span class="comment">//必须。定义系统工作时钟频率(Hz)，用户必须修改成与实际工作频率（下载时选择的）一致</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _displayer_H_                  <span class="comment">//显示模块选用时必须。（数码管显示译码表，用戶可修改、增加等） </span></span></span><br><span class="line">code <span class="type">char</span> decode_table[]=&#123;</span><br><span class="line">    <span class="number">0x3f</span>,</span><br><span class="line">    <span class="number">0x06</span>,</span><br><span class="line">    <span class="number">0x5b</span>,</span><br><span class="line">    <span class="number">0x4f</span>,</span><br><span class="line">    <span class="number">0x66</span>,</span><br><span class="line">    <span class="number">0x6d</span>,</span><br><span class="line">    <span class="number">0x7d</span>,</span><br><span class="line">    <span class="number">0x07</span>,</span><br><span class="line">    <span class="number">0x7f</span>,</span><br><span class="line">    <span class="number">0x6f</span>,</span><br><span class="line">    <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x08</span>,</span><br><span class="line">    <span class="number">0x40</span>,</span><br><span class="line">    <span class="number">0x01</span>, </span><br><span class="line">    <span class="number">0x41</span>, </span><br><span class="line">    <span class="number">0x48</span>, </span><br><span class="line">    <span class="number">0x3f</span>|<span class="number">0x80</span>,</span><br><span class="line">    <span class="number">0x06</span>|<span class="number">0x80</span>,</span><br><span class="line">    <span class="number">0x5b</span>|<span class="number">0x80</span>,</span><br><span class="line">    <span class="number">0x4f</span>|<span class="number">0x80</span>,</span><br><span class="line">    <span class="number">0x66</span>|<span class="number">0x80</span>,</span><br><span class="line">    <span class="number">0x6d</span>|<span class="number">0x80</span>,</span><br><span class="line">    <span class="number">0x7d</span>|<span class="number">0x80</span>,</span><br><span class="line">    <span class="number">0x07</span>|<span class="number">0x80</span>,</span><br><span class="line">    <span class="number">0x7f</span>|<span class="number">0x80</span>,</span><br><span class="line">    <span class="number">0x6f</span>|<span class="number">0x80</span> </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> a;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">myKey_callback</span><span class="params">()</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">char</span> k;</span><br><span class="line">    SetBeep(<span class="number">1000</span>,<span class="number">10</span>); <span class="comment">// BEEPing</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 根据按键设置LED */</span></span><br><span class="line">    k=GetKeyAct(enumKey1);</span><br><span class="line">    <span class="keyword">if</span>( k == enumKeyPress ) a |=<span class="number">0x01</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( k == enumKeyRelease ) a &amp;=~<span class="number">0x01</span>;</span><br><span class="line">    k=GetKeyAct(enumKey2);</span><br><span class="line">    <span class="keyword">if</span>( k == enumKeyPress ) a |=<span class="number">0x02</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( k == enumKeyRelease ) a &amp;=~<span class="number">0x02</span>;</span><br><span class="line">    k=GetKeyAct(enumKey3);</span><br><span class="line">    <span class="keyword">if</span>( k == enumKeyPress ) a |=<span class="number">0x04</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( k == enumKeyRelease ) a &amp;=~<span class="number">0x04</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">my10mS_callback</span><span class="params">()</span></span><br><span class="line">&#123; </span><br><span class="line">    LedPrint(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123; </span><br><span class="line">    DisplayerInit();  </span><br><span class="line">    KeyInit();</span><br><span class="line">    BeepInit();</span><br><span class="line">    SetDisplayerArea(<span class="number">0</span>,<span class="number">7</span>);	</span><br><span class="line">    Seg7Print(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>);	</span><br><span class="line">    SetEventCallBack(enumEventSys10mS, my10mS_callback);</span><br><span class="line">    SetEventCallBack(enumEventKey, myKey_callback);</span><br><span class="line">    <span class="comment">// 循环等待事件</span></span><br><span class="line">    MySTC_Init();</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)             	</span><br><span class="line">    &#123; </span><br><span class="line">        MySTC_OS();    </span><br><span class="line">    &#125;	             </span><br><span class="line">&#125;                 </span><br></pre></td></tr></table></figure>
<h2 id="C版本"><a href="#C版本" class="headerlink" title="C版本"></a>C版本</h2><p>没有蜂鸣器。没有数码管。过于简单，按下按键，对应的LED亮起。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**********************</span></span><br><span class="line"><span class="comment">        三按键测试</span></span><br><span class="line"><span class="comment">型号:STC15F2K60S2 主频:11.0592MHz</span></span><br><span class="line"><span class="comment">************************/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;STC15F2K60S2.H&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*---------引脚别名定义---------*/</span></span><br><span class="line">sbit sbtKey1 = P3 ^ <span class="number">2</span>;</span><br><span class="line">sbit sbtKey2 = P3 ^ <span class="number">3</span>;</span><br><span class="line">sbit sbtKey3 = P1 ^ <span class="number">7</span>;</span><br><span class="line">sbit sbtLedSel = P2 ^ <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*---------初始化函数---------*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//推挽输出</span></span><br><span class="line">    P0M0 = <span class="number">0XFF</span>;</span><br><span class="line">    P0M1 = <span class="number">0X00</span>;</span><br><span class="line">    P2M0 = <span class="number">0X08</span>;</span><br><span class="line">    P2M1 = <span class="number">0X00</span>;</span><br><span class="line">    sbtLedSel = <span class="number">1</span>;          <span class="comment">//选择让LED灯发光,可以不设置，默认为1</span></span><br><span class="line">    P0 = <span class="number">0</span>;                 <span class="comment">//初始化P0，让LED灯全部熄灭</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*---------主函数---------*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Init();</span><br><span class="line">    <span class="keyword">while</span>( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( sbtKey1 == <span class="number">0</span> )  <span class="comment">//检测按键1是否被按下</span></span><br><span class="line">            P0 |= <span class="number">0x01</span>;     <span class="comment">//按下则L0发光</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            P0 &amp;= ~<span class="number">0x01</span>;    <span class="comment">//否则L0熄灭</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( sbtKey2 == <span class="number">0</span> )  <span class="comment">//检测按键2是否被按下</span></span><br><span class="line">            P0 |= <span class="number">0x02</span>;     <span class="comment">//按下则L1发光</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            P0 &amp;= ~<span class="number">0x02</span>;    <span class="comment">//否则L1熄灭</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( sbtKey3 == <span class="number">0</span> )  <span class="comment">//检测按键3是否被按下</span></span><br><span class="line">            P0 |= <span class="number">0x04</span>;     <span class="comment">//按下则L2发光</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            P0 &amp;= ~<span class="number">0x04</span>;    <span class="comment">//否则L2熄灭</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>STC-B</category>
        <category>基础编程</category>
      </categories>
      <tags>
        <tag>单片机</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>八位数码管+流水灯（BSP版本）</title>
    <url>/2022/06/29/%E5%85%AB%E4%BD%8D%E6%95%B0%E7%A0%81%E7%AE%A1-%E6%B5%81%E6%B0%B4%E7%81%AF%EF%BC%88BSP%E7%89%88%E6%9C%AC%EF%BC%89/</url>
    <content><![CDATA[<h1 id="八位数码管-流水灯（BSP版本）"><a href="#八位数码管-流水灯（BSP版本）" class="headerlink" title="八位数码管+流水灯（BSP版本）"></a>八位数码管+流水灯（BSP版本）</h1><p>因为不是专业的单片机专家，所以既然提供了带有BSP库的版本，自然就用BSP版本。这里介绍一下BSP版本的代码。</p>
<h2 id="文件说明"><a href="#文件说明" class="headerlink" title="文件说明"></a>文件说明</h2><p><img src="/2022/06/29/%E5%85%AB%E4%BD%8D%E6%95%B0%E7%A0%81%E7%AE%A1-%E6%B5%81%E6%B0%B4%E7%81%AF%EF%BC%88BSP%E7%89%88%E6%9C%AC%EF%BC%89/image-20220629151028369.png" alt="image-20220629151028369"></p>
<p>文件的主题部分如上图，除了main函数以外，我们看到<code>STC15F2K60S2.H</code>和前面一样是端口的地址定义的头文件</p>
<p>然后是<code>displayer.h</code>头文件，</p>
<blockquote>
<p><img src="/2022/06/29/%E5%85%AB%E4%BD%8D%E6%95%B0%E7%A0%81%E7%AE%A1-%E6%B5%81%E6%B0%B4%E7%81%AF%EF%BC%88BSP%E7%89%88%E6%9C%AC%EF%BC%89/image-20220629151443888.png" alt="image-20220629151443888"></p>
<p>这一部分就是显示功能的相关接口，STC单片机上的显示主要是数码管和LED灯。</p>
<ul>
<li><code>DisplayerInit</code>是显示模块初始化函数，会对对应的函数的硬件，以及相关针脚进行初始化，具体可以看看前面的博文，就是作P0、P2端口等以及其他相关寄存器的初始化</li>
<li><code>SetDisplayerArea</code>是设置有效显示区域，根据[begin, end]设置数码管显示范围。如果begin = 0，end = 7，显示的就是所有的数码管。但是范围不仅仅是这样，如果你的end大于7，比如是255，这也是能够正常工作的，只是硬件地址只有0-7，但是其他的无效地址会消耗一定的时间，这样总体显示时间变长了，由于是动态扫描的，所以8个有效数码管显示会出现闪烁，亮度下降的现象。</li>
<li><code>Seg7Print</code>参数是输入8个要显示的数据，这个可以根据输入的参数作为在<code>decode_table[]</code>中的索引，可以显示对应灯管的组合</li>
<li><code>LedPrint</code>控制8个数码管开关，一个位对应一个数码管，1是亮，0是暗。</li>
</ul>
</blockquote>
<p>还有一个文件是<code>sys.h</code>，这个是用来执行系统级别的操作，旨在对于用户以及系统的事件做出响应</p>
<blockquote>
<p><img src="/2022/06/29/%E5%85%AB%E4%BD%8D%E6%95%B0%E7%A0%81%E7%AE%A1-%E6%B5%81%E6%B0%B4%E7%81%AF%EF%BC%88BSP%E7%89%88%E6%9C%AC%EF%BC%89/image-20220629155718409.png" alt="image-20220629155718409"></p>
<p><img src="/2022/06/29/%E5%85%AB%E4%BD%8D%E6%95%B0%E7%A0%81%E7%AE%A1-%E6%B5%81%E6%B0%B4%E7%81%AF%EF%BC%88BSP%E7%89%88%E6%9C%AC%EF%BC%89/image-20220629155747086.png" alt="image-20220629155747086"></p>
<p>上面是系统相关的函数，注释写的很清楚，主要是初始化系统，并且定义了事件，以及响应事件的函数。这里不详细展开，用到的时候再进行说明。</p>
</blockquote>
<p>上面头文件涉及的函数，在<code>STCBSP_V3.6.LIB</code>静态库中进行定义，因此可以直接使用。</p>
<p><img src="/2022/06/29/%E5%85%AB%E4%BD%8D%E6%95%B0%E7%A0%81%E7%AE%A1-%E6%B5%81%E6%B0%B4%E7%81%AF%EF%BC%88BSP%E7%89%88%E6%9C%AC%EF%BC%89/image-20220629154235232.png" alt="image-20220629154235232"></p>
<h2 id="主函数逻辑说明"><a href="#主函数逻辑说明" class="headerlink" title="主函数逻辑说明"></a>主函数逻辑说明</h2><p><img src="/2022/06/29/%E5%85%AB%E4%BD%8D%E6%95%B0%E7%A0%81%E7%AE%A1-%E6%B5%81%E6%B0%B4%E7%81%AF%EF%BC%88BSP%E7%89%88%E6%9C%AC%EF%BC%89/image-20220629160509448.png" alt="image-20220629160509448" style="zoom:50%;"></p>
<p><code>main.c</code>中需要将<code>SysClock</code>设置成和下载的<code>IRC</code>一样的频率</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 显示数码管和LED等需要的头文件，其中前面两个是必须的 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;STC15F2K60S2.H&quot;</span>        <span class="comment">// 端口地址定义</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.H&quot;</span>                 <span class="comment">// 使用系统的函数定义</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;displayer.H&quot;</span> 			 <span class="comment">// 数码管显示</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 必须。定义系统工作时钟频率(Hz)，用户要修改成和实际工作频率(下载时)一致，如上图 */</span></span><br><span class="line">code <span class="type">unsigned</span> <span class="type">long</span> SysClock=<span class="number">11059200</span>;  <span class="comment">// code是告诉单片机这个变量的值刷写入ROM，不再改变</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 用户可以进行自定义数码管显示，主要是通过decode_table */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _displayer_H_                         </span></span><br><span class="line">code <span class="type">char</span> decode_table[]=&#123;			<span class="comment">/* 值 */</span></span><br><span class="line">    <span class="number">0x3f</span>,							<span class="comment">// 0		</span></span><br><span class="line">    <span class="number">0x06</span>,							<span class="comment">// 1			 </span></span><br><span class="line">    <span class="number">0x5b</span>,							<span class="comment">// 2			 </span></span><br><span class="line">    <span class="number">0x4f</span>,							<span class="comment">// 3			 											</span></span><br><span class="line">    <span class="number">0x66</span>,							<span class="comment">// 4			 									</span></span><br><span class="line">    <span class="number">0x6d</span>,							<span class="comment">// 5			 											</span></span><br><span class="line">    <span class="number">0x7d</span>,							<span class="comment">// 6			 		</span></span><br><span class="line">    <span class="number">0x07</span>,							<span class="comment">// 7			 </span></span><br><span class="line">    <span class="number">0x7f</span>,							<span class="comment">// 8		     </span></span><br><span class="line">    <span class="number">0x6f</span>,							<span class="comment">// 9			 </span></span><br><span class="line">    <span class="number">0x00</span>,							<span class="comment">// 无</span></span><br><span class="line">    <span class="number">0x08</span>,							<span class="comment">// 下-</span></span><br><span class="line">    <span class="number">0x40</span>,							<span class="comment">// 中-</span></span><br><span class="line">    <span class="number">0x01</span>, 							<span class="comment">// 上-</span></span><br><span class="line">    <span class="number">0x41</span>, 							<span class="comment">// 上中-	</span></span><br><span class="line">    <span class="number">0x48</span>,                 			<span class="comment">// 中下-</span></span><br><span class="line">    <span class="number">0x3f</span>|<span class="number">0x80</span>,						<span class="comment">// 带小数点0		</span></span><br><span class="line">    <span class="number">0x06</span>|<span class="number">0x80</span>,						<span class="comment">// 带小数点1			</span></span><br><span class="line">&#125;;  <span class="comment">// 也可以采用上面的拼接方式进行段选信息的构造</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* LED显示函数，可回调 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">my100mS_callback</span><span class="params">()</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="comment">// 定义一个LED寄存器类型</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> a;</span><br><span class="line">    <span class="comment">// LED显示左移</span></span><br><span class="line">    <span class="keyword">if</span>(a != <span class="number">0</span>) a=a&lt;&lt;<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 超出了，重置</span></span><br><span class="line">    <span class="keyword">else</span> a=<span class="number">0x01</span>;</span><br><span class="line">    <span class="comment">// 显示寄存器值</span></span><br><span class="line">    LedPrint(a);</span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 这里仅仅进行一次打印操作 </span></span><br><span class="line"><span class="comment">  	 * 但是每一次a的值从上一次继承下来，实现了移位操作</span></span><br><span class="line"><span class="comment">  	 * a是局部变量</span></span><br><span class="line"><span class="comment">  	 * 从局部变量声明的时候，它就在堆栈空间了，而不是调用函数的时候，才让它入栈的。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="comment">// 使用显示设备，需要进行初始化</span></span><br><span class="line">    DisplayerInit();  </span><br><span class="line">    <span class="comment">// 设置显示范围为0-64，实际有效只有0-7，因此有无效地址消耗时间，数码管会出现闪烁变暗</span></span><br><span class="line">    SetDisplayerArea(<span class="number">0</span>,<span class="number">64</span>);	</span><br><span class="line">    <span class="comment">// 八个数码管分别显示1-8</span></span><br><span class="line">    Seg7Print(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>);	</span><br><span class="line">    <span class="comment">// 利用回调函数，每100ms，就调用一次函数，这么做是为了节省栈空间，因为单片机的栈很小</span></span><br><span class="line">    SetEventCallBack(enumEventSys100mS, my100mS_callback);</span><br><span class="line">    <span class="comment">/* 这里是初始化系统并循环等待事件，如果没有下面这部分，程序运行结束，板子就死了 */</span></span><br><span class="line">    MySTC_Init();	    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123; </span><br><span class="line">        MySTC_OS();    </span><br><span class="line">    &#125;	             </span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<h2 id="C语言版本"><a href="#C语言版本" class="headerlink" title="C语言版本"></a>C语言版本</h2><p>整体和上一个版本差不多，这里不做赘述。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**********************</span></span><br><span class="line"><span class="comment">    :八位数码管+流水灯</span></span><br><span class="line"><span class="comment">型号:STC15F2K60S2 主频:11.0592MHz</span></span><br><span class="line"><span class="comment">************************/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;STC15F2K60S2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> uint unsigned int</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> uchar unsigned char</span></span><br><span class="line"></span><br><span class="line">uchar arrSeg7Select[] = &#123;<span class="number">0x3f</span>, <span class="number">0x06</span>, <span class="number">0x5b</span>, <span class="number">0x4f</span>, <span class="number">0x66</span>, <span class="number">0x6d</span>, <span class="number">0x7d</span>, <span class="number">0x07</span>, <span class="number">0x7f</span>&#125;; <span class="comment">//显示0-8</span></span><br><span class="line">uchar arrDigitSelect[] = &#123;<span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x02</span>, <span class="number">0x03</span>, <span class="number">0x04</span>, <span class="number">0x05</span>, <span class="number">0x06</span>, <span class="number">0x07</span>&#125;;   	<span class="comment">//数码管0-7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*---------引脚别名定义---------*/</span></span><br><span class="line">sbit sbtLedSel = P2 ^ <span class="number">3</span>;   <span class="comment">//数码管与LED灯切换引脚</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*---------变量定义---------*/</span></span><br><span class="line">uchar uiLed = <span class="number">0x01</span>;        <span class="comment">//LED灯值寄存</span></span><br><span class="line">uint  uiLedCnt = <span class="number">0</span>;        <span class="comment">//LED灯累计计数器</span></span><br><span class="line">uchar i = <span class="number">0</span>;               <span class="comment">//数码管扫描显示循环</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*---------初始化函数---------*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    P0M1 = <span class="number">0x00</span>;</span><br><span class="line">    P0M0 = <span class="number">0xff</span>;</span><br><span class="line">    P2M1 = <span class="number">0x00</span>;</span><br><span class="line">    P2M0 = <span class="number">0x08</span>;</span><br><span class="line">    sbtLedSel = <span class="number">0</span>;  <span class="comment">//先选择数码管亮</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*---------延时函数---------*/</span></span><br><span class="line"><span class="comment">//下为生成1ms的延时函数，通过传入参数n，函数可以延时n毫秒</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_ms</span><span class="params">( uint n )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>( n )</span><br><span class="line">    &#123;</span><br><span class="line">        uchar i, j;</span><br><span class="line">        i = <span class="number">11</span>;</span><br><span class="line">        j = <span class="number">190</span>;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> ( --j );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> ( --i );</span><br><span class="line">        n--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*---------主函数---------*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Init();</span><br><span class="line">    <span class="keyword">while</span>( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        sbtLedSel = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++ )</span><br><span class="line">        &#123;</span><br><span class="line">            P0 = <span class="number">0</span>;</span><br><span class="line">            P2 = arrDigitSelect[i];     <span class="comment">//选择数码管的位数</span></span><br><span class="line">            P0 = arrSeg7Select[i + <span class="number">1</span>];  <span class="comment">//显示对应的数值</span></span><br><span class="line">            delay_ms( <span class="number">1</span> );</span><br><span class="line">        &#125;</span><br><span class="line">        uiLedCnt++;</span><br><span class="line">        sbtLedSel = <span class="number">1</span>;</span><br><span class="line">        P0 = uiLed;                     <span class="comment">//LED显示</span></span><br><span class="line">        delay_ms( <span class="number">1</span> );                  <span class="comment">//延时200ms</span></span><br><span class="line">        <span class="keyword">if</span>( uiLedCnt == <span class="number">50</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( uiLed == <span class="number">0x80</span> )        <span class="comment">//value等于0x80时，重新赋初值0x01</span></span><br><span class="line">                uiLed = <span class="number">0x01</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                uiLed = uiLed &lt;&lt; <span class="number">1</span>;    <span class="comment">//value值逐一左移</span></span><br><span class="line">            uiLedCnt = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>STC-B</category>
        <category>基础编程</category>
      </categories>
      <tags>
        <tag>单片机</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>八位数码管动态扫描</title>
    <url>/2022/06/27/%E5%85%AB%E4%BD%8D%E6%95%B0%E7%A0%81%E7%AE%A1%E5%8A%A8%E6%80%81%E6%89%AB%E6%8F%8F/</url>
    <content><![CDATA[<h1 id="八位数码管动态扫描"><a href="#八位数码管动态扫描" class="headerlink" title="八位数码管动态扫描"></a>八位数码管动态扫描</h1><p>实验工程可以在学习通上面下载</p>
<h2 id="程序设计流程图"><a href="#程序设计流程图" class="headerlink" title="程序设计流程图"></a>程序设计流程图</h2><p><img src="/2022/06/27/%E5%85%AB%E4%BD%8D%E6%95%B0%E7%A0%81%E7%AE%A1%E5%8A%A8%E6%80%81%E6%89%AB%E6%8F%8F/a30fcab29846191787fc9aaabeae05fa.png" alt="img"></p>
<p>在程序启动的初期，需要对硬件有抽象的定义，这由我们的.h头文件表示，初始化硬件，实际是对一些寄存器的初始化，和上一个流水灯的<code>init</code>函数差不多。然后就是主要逻辑，扫描位选，并完成端口的赋值。</p>
<h2 id="原理说明"><a href="#原理说明" class="headerlink" title="原理说明"></a>原理说明</h2><h3 id="什么是段选和位选"><a href="#什么是段选和位选" class="headerlink" title="什么是段选和位选"></a>什么是段选和位选</h3><p>简单说：段选信号是选择数码管的那一段灯管亮起，位选信号是选择八个数码管的哪一个。</p>
<p><img src="/2022/06/27/%E5%85%AB%E4%BD%8D%E6%95%B0%E7%A0%81%E7%AE%A1%E5%8A%A8%E6%80%81%E6%89%AB%E6%8F%8F/image-20220627143830272.png" alt="image-20220627143830272"></p>
<p>如下图，由于这八个数码管是通用的同一个GND，也就是共地的。（一次只能一个开漏地级接给一个数码管，否则不同的二极管会冲突）因此，一次只能有一个数码管亮起，比如下图中八个数码管一次显示0-7，则只能够从左到右，D1先显示0，D1熄灭，D2再显示1，D2熄灭，…，然后轮流下去，如果速度够快，人眼看起来就像灯是一起亮着的。</p>
<p><img src="/2022/06/27/%E5%85%AB%E4%BD%8D%E6%95%B0%E7%A0%81%E7%AE%A1%E5%8A%A8%E6%80%81%E6%89%AB%E6%8F%8F/image-20220627135806124.png" alt="image-20220627135806124" style="zoom:50%;"></p>
<h3 id="段选进一步说明"><a href="#段选进一步说明" class="headerlink" title="段选进一步说明"></a>段选进一步说明</h3><p><img src="/2022/06/27/%E5%85%AB%E4%BD%8D%E6%95%B0%E7%A0%81%E7%AE%A1%E5%8A%A8%E6%80%81%E6%89%AB%E6%8F%8F/image-20220627142752484.png" alt="image-20220627142752484"></p>
<p><img src="/2022/06/27/%E5%85%AB%E4%BD%8D%E6%95%B0%E7%A0%81%E7%AE%A1%E5%8A%A8%E6%80%81%E6%89%AB%E6%8F%8F/image-20220627142912078.png" alt="image-20220627142912078" style="zoom:50%;"></p>
<p>位选就是第几个数码管，段选是怎么来的？</p>
<blockquote>
<p>比如我们要左起第3个（01234567）数码管显示6，因此位选就是2，也就是P2  = 2，当然也可以用程序中的方法（多此一举）<code>P2 = weixuan[2]</code></p>
<p>然后段选要显示6根据上面的图，我们知道，显示6，需要“a, c, d, f, g, e”这些灯管亮起。所以位选信息如下</p>
<p><img src="/2022/06/27/%E5%85%AB%E4%BD%8D%E6%95%B0%E7%A0%81%E7%AE%A1%E5%8A%A8%E6%80%81%E6%89%AB%E6%8F%8F/image-20220627144325373.png" alt="image-20220627144325373" style="zoom:80%;"></p>
<p>所以因此段选信息就是：<code>duanxuan[6] = 0b0111101 = 0x7d</code></p>
<p>所以对应P0.7-P0.0就是0x7d</p>
<p>类似上面的方法就可以枚举出所有的段选情况：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">uchar duanxuan[]=&#123;<span class="number">0x3f</span>,<span class="number">0x06</span>,<span class="number">0x5b</span>,<span class="number">0x4f</span>,<span class="number">0x66</span>,<span class="number">0x6d</span>,<span class="number">0x7d</span>,<span class="number">0x07</span>,<span class="number">0x7f</span>&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="代码说明"><a href="#代码说明" class="headerlink" title="代码说明"></a>代码说明</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 对硬件各个端口的定义的头文件，直接使用即可 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;STC15F2K60S2.h&gt;</span></span></span><br><span class="line"><span class="comment">/* 重定义类型名，简写 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> uint unsigned int</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> uchar unsigned char</span></span><br><span class="line"></span><br><span class="line">uint i=<span class="number">0</span>;</span><br><span class="line"><span class="comment">// 段选：选择亮灯</span></span><br><span class="line">uchar duanxuan[]=&#123;<span class="number">0x3f</span>,<span class="number">0x06</span>,<span class="number">0x5b</span>,<span class="number">0x4f</span>,<span class="number">0x66</span>,<span class="number">0x6d</span>,<span class="number">0x7d</span>,<span class="number">0x07</span>,<span class="number">0x7f</span>&#125;;</span><br><span class="line"><span class="comment">// 位选：选择哪一个数码管</span></span><br><span class="line">uchar weixuan[]=&#123;<span class="number">0x00</span>,<span class="number">0x01</span>,<span class="number">0x02</span>,<span class="number">0x03</span>,<span class="number">0x04</span>,<span class="number">0x05</span>,<span class="number">0x06</span>,<span class="number">0x07</span>&#125;;			 </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay</span><span class="params">(<span class="type">int</span> n)</span>				<span class="comment">// 延时函数，单位毫秒</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(n--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 设置推挽输出</span></span><br><span class="line"><span class="comment">     * 和流水灯实验类似，对P0端口和P2端口进行设置</span></span><br><span class="line"><span class="comment">     * 端口设置推挽输出，通道0设置“1”，通道0全0，具体见数据手册，流水灯也讲过了</span></span><br><span class="line"><span class="comment">     * 端口0的0通道，是表示位选，八个位对应八个灯管，所以全部设成1</span></span><br><span class="line"><span class="comment">     * 端口2的0通道，是表示段选，一次只能选一个数码管，由三位输入进行选择</span></span><br><span class="line"><span class="comment">     * 分别是：P2.2 P2.1 P2.0</span></span><br><span class="line"><span class="comment">     * 刚好是P2的第三位，所以赋值时候，只要P2 = weixuan[i]</span></span><br><span class="line"><span class="comment">     * 就可以</span></span><br><span class="line"><span class="comment">     * 这里简单将2的0通道全部设成1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	P2M0=<span class="number">0xff</span>;					</span><br><span class="line">   	P2M1=<span class="number">0x00</span>;</span><br><span class="line">    P0M0=<span class="number">0xff</span>;</span><br><span class="line">    P0M1=<span class="number">0x00</span>;</span><br><span class="line">	<span class="comment">/* 循环扫描数码管</span></span><br><span class="line"><span class="comment">     * 不断扫描数码管，使每一小段数码管都点亮一段时间</span></span><br><span class="line"><span class="comment">     * 视觉上一直是亮的状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			P0=<span class="number">0</span>;</span><br><span class="line">			P2=weixuan[i];		<span class="comment">// 选择数码管的位数</span></span><br><span class="line">			P0=duanxuan[i+<span class="number">1</span>];	<span class="comment">// 选择对应的数值</span></span><br><span class="line">			Delay(<span class="number">600</span>);			<span class="comment">// 延时</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>STC-B</category>
        <category>基础编程</category>
      </categories>
      <tags>
        <tag>单片机</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>八位数码管滚动显示</title>
    <url>/2022/06/30/%E5%85%AB%E4%BD%8D%E6%95%B0%E7%A0%81%E7%AE%A1%E6%BB%9A%E5%8A%A8%E6%98%BE%E7%A4%BA/</url>
    <content><![CDATA[<h1 id="八位数码管滚动显示"><a href="#八位数码管滚动显示" class="headerlink" title="八位数码管滚动显示"></a>八位数码管滚动显示</h1><p>如果又看明白的请会看之前的博文。</p>
<h3 id="BSP库版本"><a href="#BSP库版本" class="headerlink" title="BSP库版本"></a>BSP库版本</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;STC15F2K60S2.H&quot;</span>       </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.H&quot;</span>                 </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;displayer.H&quot;</span> </span></span><br><span class="line"></span><br><span class="line">code <span class="type">unsigned</span> <span class="type">long</span> SysClock=<span class="number">11059200</span>;         </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _displayer_H_                         </span></span><br><span class="line">code <span class="type">char</span> decode_table[]=&#123;</span><br><span class="line">    <span class="number">0x3f</span>,</span><br><span class="line">    <span class="number">0x06</span>,</span><br><span class="line">    <span class="number">0x5b</span>,</span><br><span class="line">    <span class="number">0x4f</span>,</span><br><span class="line">    <span class="number">0x66</span>,</span><br><span class="line">    <span class="number">0x6d</span>,</span><br><span class="line">    <span class="number">0x7d</span>,</span><br><span class="line">    <span class="number">0x07</span>,</span><br><span class="line">    <span class="number">0x7f</span>,</span><br><span class="line">    <span class="number">0x6f</span>,</span><br><span class="line">    <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x08</span>,</span><br><span class="line">    <span class="number">0x40</span>,</span><br><span class="line">    <span class="number">0x01</span>, </span><br><span class="line">    <span class="number">0x41</span>, </span><br><span class="line">    <span class="number">0x48</span>,                			</span><br><span class="line">    <span class="number">0x3f</span>|<span class="number">0x80</span>,</span><br><span class="line">    <span class="number">0x06</span>|<span class="number">0x80</span>,</span><br><span class="line">    <span class="number">0x5b</span>|<span class="number">0x80</span>,</span><br><span class="line">    <span class="number">0x4f</span>|<span class="number">0x80</span>,</span><br><span class="line">    <span class="number">0x66</span>|<span class="number">0x80</span>,</span><br><span class="line">    <span class="number">0x6d</span>|<span class="number">0x80</span>,</span><br><span class="line">    <span class="number">0x7d</span>|<span class="number">0x80</span>,</span><br><span class="line">    <span class="number">0x07</span>|<span class="number">0x80</span>,</span><br><span class="line">    <span class="number">0x7f</span>|<span class="number">0x80</span>,</span><br><span class="line">    <span class="number">0x6f</span>|<span class="number">0x80</span> </span><br><span class="line">&#125;; </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">/* 上面的和之前的完全一致 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 回调函数 </span></span><br><span class="line"><span class="comment"> * 滚动显示0123456789，八位数码管显示如下:</span></span><br><span class="line"><span class="comment"> * i = 0: 0 1 2 3 4 5 6 7 </span></span><br><span class="line"><span class="comment"> * i = 1: 1 2 3 4 5 6 7 8</span></span><br><span class="line"><span class="comment"> * i = 2: 2 3 4 5 6 7 8 9</span></span><br><span class="line"><span class="comment"> * ...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">my1S_callback</span><span class="params">()</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> i=<span class="number">0</span>;</span><br><span class="line">    code <span class="type">char</span> a[<span class="number">10</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    Seg7Print(           	</span><br><span class="line">        a[i%<span class="number">10</span>],</span><br><span class="line">        a[(i+<span class="number">1</span>)%<span class="number">10</span>],</span><br><span class="line">        a[(i+<span class="number">2</span>)%<span class="number">10</span>],</span><br><span class="line">        a[(i+<span class="number">3</span>)%<span class="number">10</span>],</span><br><span class="line">        a[(i+<span class="number">4</span>)%<span class="number">10</span>],</span><br><span class="line">        a[(i+<span class="number">5</span>)%<span class="number">10</span>],</span><br><span class="line">        a[(i+<span class="number">6</span>)%<span class="number">10</span>],</span><br><span class="line">        a[(i+<span class="number">7</span>)%<span class="number">10</span>]</span><br><span class="line">    );	</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123; </span><br><span class="line">    DisplayerInit(); <span class="comment">// 初始化显示设备</span></span><br><span class="line">    SetDisplayerArea(<span class="number">0</span>,<span class="number">7</span>); <span class="comment">// 设置显示数码管是0-7</span></span><br><span class="line">    LedPrint(<span class="number">0</span>); <span class="comment">// LED灯不显示</span></span><br><span class="line">    SetEventCallBack(enumEventSys1S, my1S_callback); <span class="comment">// 没一秒钟回调一次函数，让数码管从右向左滚动</span></span><br><span class="line">    <span class="comment">/* 初始化系统，并循环捕捉事件 */</span></span><br><span class="line">    MySTC_Init();	    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)             	</span><br><span class="line">    &#123; </span><br><span class="line">        MySTC_OS();    </span><br><span class="line">    &#125;	             </span><br><span class="line">&#125;                 </span><br></pre></td></tr></table></figure>
<h3 id="C语言版本"><a href="#C语言版本" class="headerlink" title="C语言版本"></a>C语言版本</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**********************</span></span><br><span class="line"><span class="comment">mySeg7Shift 八位数码管滚动显示</span></span><br><span class="line"><span class="comment">型号:STC15F2K60S2 主频:11.0592MHz</span></span><br><span class="line"><span class="comment">************************/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;STC15F2K60S2.H&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> uint unsigned int</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> uchar unsigned char</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*---------引脚别名定义---------*/</span></span><br><span class="line"><span class="comment">//位选的三个引脚控制位</span></span><br><span class="line"><span class="comment">//起始就是位选信息，用来选择显示哪一个数码管显示</span></span><br><span class="line">sbit sbtSel0 = P2 ^ <span class="number">0</span>; </span><br><span class="line">sbit sbtSel1 = P2 ^ <span class="number">1</span>; </span><br><span class="line">sbit sbtSel2 = P2 ^ <span class="number">2</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">/*---------变量定义---------*/</span></span><br><span class="line"><span class="comment">//show_wi(i=1,2,3,4,……,8)分别是对应左到右的各个数码管上的显示的数字</span></span><br><span class="line">uchar ucDig1Tmp;</span><br><span class="line">uchar ucDig2Tmp;</span><br><span class="line">uchar ucDig3Tmp;</span><br><span class="line">uchar ucDig4Tmp;</span><br><span class="line">uchar ucDig5Tmp;</span><br><span class="line">uchar ucDig6Tmp;</span><br><span class="line">uchar ucDig7Tmp;</span><br><span class="line">uchar ucDig8Tmp;</span><br><span class="line">uchar ucSeg7State;</span><br><span class="line">uchar ucCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">//段选，显示0-f</span></span><br><span class="line">uchar arrSegSelect[] = &#123;</span><br><span class="line">    <span class="number">0x3f</span>, </span><br><span class="line">    <span class="number">0x06</span>, </span><br><span class="line">    <span class="number">0x5b</span>, </span><br><span class="line">    <span class="number">0x4f</span>, </span><br><span class="line">    <span class="number">0x66</span>, </span><br><span class="line">    <span class="number">0x6d</span>, </span><br><span class="line">    <span class="number">0x7d</span>, </span><br><span class="line">    <span class="number">0x07</span>, </span><br><span class="line">    <span class="number">0x7f</span>, </span><br><span class="line">    <span class="number">0x6f</span>, </span><br><span class="line">    <span class="number">0x77</span>, </span><br><span class="line">    <span class="number">0x7c</span>, </span><br><span class="line">    <span class="number">0x39</span>, </span><br><span class="line">    <span class="number">0x5e</span>, </span><br><span class="line">    <span class="number">0x79</span>, </span><br><span class="line">    <span class="number">0x71</span>, </span><br><span class="line">    <span class="number">0x40</span>, </span><br><span class="line">    <span class="number">0x00</span></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">//位选,选择是0-7中的一个数码管</span></span><br><span class="line">uchar arrDigSelect[] = &#123;</span><br><span class="line">    <span class="number">0x00</span>, </span><br><span class="line">    <span class="number">0x01</span>, </span><br><span class="line">    <span class="number">0x02</span>, </span><br><span class="line">    <span class="number">0x03</span>, </span><br><span class="line">    <span class="number">0x04</span>, </span><br><span class="line">    <span class="number">0x05</span>, </span><br><span class="line">    <span class="number">0x06</span>, </span><br><span class="line">    <span class="number">0x07</span></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">/*---------初始化函数---------*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//P0，P2都设置为推挽输出</span></span><br><span class="line">    P2M0 = <span class="number">0xff</span>;</span><br><span class="line">    P2M1 = <span class="number">0x00</span>;</span><br><span class="line">    P0M0 = <span class="number">0xff</span>;</span><br><span class="line">    P0M1 = <span class="number">0x00</span>; </span><br><span class="line"></span><br><span class="line">    ucSeg7State = <span class="number">0</span>;</span><br><span class="line">    ucCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最开始数码管从左到右显示0-7</span></span><br><span class="line">    ucDig1Tmp = <span class="number">0</span>; </span><br><span class="line">    ucDig2Tmp = <span class="number">1</span>;</span><br><span class="line">    ucDig3Tmp = <span class="number">2</span>;</span><br><span class="line">    ucDig4Tmp = <span class="number">3</span>;</span><br><span class="line">    ucDig5Tmp = <span class="number">4</span>;</span><br><span class="line">    ucDig6Tmp = <span class="number">5</span>;</span><br><span class="line">    ucDig7Tmp = <span class="number">6</span>;</span><br><span class="line">    ucDig8Tmp = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这一部分是相应的设置，在BSP版本中，放在了MySTC_Init()中</span></span><br><span class="line">    TMOD = <span class="number">0x01</span>;             		<span class="comment">//定时器0，方式1</span></span><br><span class="line">    ET0 = <span class="number">1</span>;                  		<span class="comment">//开启定时器中断</span></span><br><span class="line">    TH0 = ( <span class="number">65535</span> - <span class="number">1000</span> ) / <span class="number">256</span>; 	<span class="comment">//定时器0的高八位设置</span></span><br><span class="line">    TL0 = ( <span class="number">65535</span> - <span class="number">1000</span> ) % <span class="number">256</span>; 	<span class="comment">//定时器0的低八位设置，这里总体就是设置定时器0的初始值是1ms</span></span><br><span class="line">    TR0 = <span class="number">1</span>;                 		<span class="comment">//启动定时器</span></span><br><span class="line">    EA = <span class="number">1</span>;                  		<span class="comment">//打开总的中断</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*---------定时器T0中断服务函数---------*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">T0_Process</span><span class="params">()</span> interrupt 1     	<span class="comment">//把数码管的显示提到中断里面来了，所以每次中断就运行这个函数</span></span><br><span class="line">&#123;</span><br><span class="line">    TH0 = ( <span class="number">65535</span> - <span class="number">1000</span> ) / <span class="number">256</span>; 	<span class="comment">//重新装载定时器0的初始值，为了下一次定时器溢出准备</span></span><br><span class="line">    TL0 = ( <span class="number">65535</span> - <span class="number">1000</span> ) % <span class="number">256</span>;</span><br><span class="line">    ucSeg7State++;         			<span class="comment">//这变量两个作用：具有下面分频作用，和扫描过程中显示第ucSeg7State个数码管的作用</span></span><br><span class="line">    <span class="keyword">if</span>( ucSeg7State == <span class="number">8</span> )    		<span class="comment">//进行分频，每中断八次才让ucCount的值加一次</span></span><br><span class="line">    &#123;</span><br><span class="line">        ucSeg7State = <span class="number">0</span>;</span><br><span class="line">        ucCount++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>( ucCount == <span class="number">100</span> )     <span class="comment">//考虑到扫描频率很高这里再次分频，ucCount加到100才执行</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//让从左到右各个数码管上的数字都加一</span></span><br><span class="line">        ucCount = <span class="number">0</span>;</span><br><span class="line">        ucDig1Tmp++;     </span><br><span class="line">        ucDig2Tmp++;</span><br><span class="line">        ucDig3Tmp++;</span><br><span class="line">        ucDig4Tmp++;</span><br><span class="line">        ucDig5Tmp++;</span><br><span class="line">        ucDig6Tmp++;</span><br><span class="line">        ucDig7Tmp++;</span><br><span class="line">        ucDig8Tmp++;</span><br><span class="line">    &#125;</span><br><span class="line">    P0 = <span class="number">0</span>;                       		<span class="comment">//让数码管显示更加好，不受上一次P0赋的值的影响</span></span><br><span class="line">    P2 = arrDigSelect[ucSeg7State];   	<span class="comment">//位选，选第ucSeg7State个数码管</span></span><br><span class="line">    <span class="keyword">switch</span>( ucSeg7State )           	<span class="comment">//每次中断显示一个数码管来显示</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            P0 = arrSegSelect[ucDig1Tmp % <span class="number">10</span>];</span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">//从左到右，第一个数码管显示</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            P0 = arrSegSelect[ucDig2Tmp % <span class="number">10</span>];</span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">//从左到右，第二个数码管显示</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            P0 = arrSegSelect[ucDig3Tmp % <span class="number">10</span>];</span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">//从左到右，第三个数码管显示</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            P0 = arrSegSelect[ucDig4Tmp % <span class="number">10</span>];</span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">//从左到右，第四个数码管显示</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            P0 = arrSegSelect[ucDig5Tmp % <span class="number">10</span>];</span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">//从左到右，第五个数码管显示</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            P0 = arrSegSelect[ucDig6Tmp % <span class="number">10</span>];</span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">//从左到右，第六个数码管显示</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">            P0 = arrSegSelect[ucDig7Tmp % <span class="number">10</span>];</span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">//从左到右，第七个数码管显示</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            P0 = arrSegSelect[ucDig8Tmp % <span class="number">10</span>];</span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">//从左到右，第八个数码管显示</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*---------主函数---------*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Init(); <span class="comment">//初始化</span></span><br><span class="line">    <span class="comment">// 死循环，防止程序运行完，单片机挂掉</span></span><br><span class="line">    <span class="keyword">while</span>( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>STC-B</category>
        <category>基础编程</category>
      </categories>
      <tags>
        <tag>单片机</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>可变调蜂鸣器工程</title>
    <url>/2022/06/30/%E5%8F%AF%E5%8F%98%E8%B0%83%E8%9C%82%E9%B8%A3%E5%99%A8%E5%B7%A5%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="可变调蜂鸣器工程"><a href="#可变调蜂鸣器工程" class="headerlink" title="可变调蜂鸣器工程"></a>可变调蜂鸣器工程</h1><p>这一次出现蜂鸣器的使用如果是C语言版本要如何使用，如果是BSP版本，参考上一篇博文。</p>
<p><strong>这里涉及到了定时器，定时器实际上是对单片机的机器周期进行计数，就是一个计数器，定时器设置一个初值，然后在初值上累加，直到溢出，一但溢出就产生中断。这里通过调整初值，改变时钟周期的长短。每一个时钟周期会产生蜂鸣器翻转，反转时间长短变化音调变化。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**********************</span></span><br><span class="line"><span class="comment">myBeep2 可变调蜂的鸣器</span></span><br><span class="line"><span class="comment">型号:STC15F2K60S2 主频:11.0592MHz</span></span><br><span class="line"><span class="comment">************************/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;STC15F2K60S2.H&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> uint  unsigned int</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> uchar unsigned char</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*---------引脚别名定义---------*/</span></span><br><span class="line">sbit sbtBeep = P3 ^ <span class="number">4</span>;                  <span class="comment">//蜂鸣器引脚</span></span><br><span class="line">sbit sbtKey1 = P3 ^ <span class="number">2</span>;                  <span class="comment">//按键1引脚</span></span><br><span class="line">sbit sbtKey2 = P3 ^ <span class="number">3</span>;                  <span class="comment">//按键2引脚</span></span><br><span class="line">sbit sbtSel0 = P2 ^ <span class="number">0</span>;                  <span class="comment">//位选信号位</span></span><br><span class="line">sbit sbtSel1 = P2 ^ <span class="number">1</span>;                  <span class="comment">//位选信号位</span></span><br><span class="line">sbit sbtSel2 = P2 ^ <span class="number">2</span>;                  <span class="comment">//位选信号位</span></span><br><span class="line">sbit sbtSel3 = P2 ^ <span class="number">3</span>;                  <span class="comment">//LED与数码管显示的控制位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*---------变量定义---------*/</span></span><br><span class="line">uint sbtKey1_state = <span class="number">0</span>;         <span class="comment">//0：Key1未按下         1：Key1已按下</span></span><br><span class="line">uint sbtKey2_state = <span class="number">0</span>;         <span class="comment">//0：Key2未按下         1：Key1已按下</span></span><br><span class="line">bit  btBeepFlag;                <span class="comment">//控制蜂鸣器开关的标志位</span></span><br><span class="line">uint uiToneNum = <span class="number">0</span>;             <span class="comment">//音调</span></span><br><span class="line">uchar arrSegSelect[] = &#123;</span><br><span class="line">    <span class="number">0x3f</span>, <span class="number">0x06</span>, <span class="number">0x5b</span>, <span class="number">0x4f</span>, <span class="number">0x66</span>, <span class="number">0x6d</span>, <span class="number">0x7d</span>, <span class="number">0x07</span>,</span><br><span class="line">    <span class="number">0x7f</span>, <span class="number">0x6f</span>, <span class="number">0x77</span>, <span class="number">0x7c</span>, <span class="number">0x39</span>, <span class="number">0x5e</span>, <span class="number">0x79</span>, <span class="number">0x71</span></span><br><span class="line">&#125;; <span class="comment">//段选0-f</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*---------初始化函数--------*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    P0M0 = <span class="number">0xff</span>;</span><br><span class="line">    P0M1 = <span class="number">0x00</span>;</span><br><span class="line">    P2M0 = <span class="number">0x08</span>;</span><br><span class="line">    P2M1 = <span class="number">0x00</span>;</span><br><span class="line">    <span class="comment">//设置P3^4为推挽模式</span></span><br><span class="line">    P3M1 = <span class="number">0x00</span>;</span><br><span class="line">    P3M0 = <span class="number">0x10</span>;						<span class="comment">//P3第四位设置为推挽输出模式</span></span><br><span class="line"></span><br><span class="line">    AUXR |= <span class="number">0x80</span>;                       <span class="comment">//定时器时钟1T模式</span></span><br><span class="line">    TMOD &amp;= <span class="number">0xF0</span>;                       <span class="comment">//设置定时器模式为16位自动重装</span></span><br><span class="line">    TL0 = <span class="number">0xCD</span>;                         <span class="comment">//设置定时初值</span></span><br><span class="line">    TH0 = <span class="number">0xF4</span>;                         <span class="comment">//设置定时初值</span></span><br><span class="line">    TF0 = <span class="number">0</span>;                            <span class="comment">//清除TF0标志</span></span><br><span class="line">    TR0 = <span class="number">1</span>;                            <span class="comment">//定时器0开始计时</span></span><br><span class="line"></span><br><span class="line">    btBeepFlag = <span class="number">0</span>;</span><br><span class="line">    P0 = <span class="number">0x00</span>;                          <span class="comment">//数码管和LED显示清零</span></span><br><span class="line"></span><br><span class="line">    sbtSel0 = <span class="number">1</span>;                        <span class="comment">//位选设置为第七位</span></span><br><span class="line">    sbtSel1 = <span class="number">1</span>;</span><br><span class="line">    sbtSel2 = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    sbtBeep = <span class="number">0</span>;                        <span class="comment">//蜂鸣器引脚置0，以保护蜂鸣器</span></span><br><span class="line">    ET0 = <span class="number">1</span>;</span><br><span class="line">    EA = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*---------延时子函数--------*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DelayMs</span><span class="params">( uint xms )</span></span><br><span class="line">&#123;</span><br><span class="line">    uchar i;</span><br><span class="line">    <span class="keyword">for</span>( ; xms &gt; <span class="number">0</span>; xms-- )</span><br><span class="line">        <span class="keyword">for</span>( i = <span class="number">114</span>; i &gt; <span class="number">0</span>; i-- )</span><br><span class="line">        &#123;</span><br><span class="line">            ;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*---------显示子函数--------*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DisplaySeg7Led</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    P0 = <span class="number">0</span>;</span><br><span class="line">    sbtSel3 = <span class="number">0</span>;</span><br><span class="line">    P0 = arrSegSelect[uiToneNum];</span><br><span class="line">    DelayMs( <span class="number">1</span> );</span><br><span class="line"></span><br><span class="line">    P0 = <span class="number">0</span>;</span><br><span class="line">    sbtSel3 = <span class="number">1</span>;</span><br><span class="line">    P0 = <span class="number">0x08</span>;</span><br><span class="line">    DelayMs( <span class="number">1</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*---------主函数--------*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Init();</span><br><span class="line">    <span class="keyword">while</span>( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( sbtKey1 == <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( sbtKey1_state == <span class="number">0</span> )        <span class="comment">//判断按键1是否按下</span></span><br><span class="line">            &#123;</span><br><span class="line">                DelayMs( <span class="number">10</span> );              <span class="comment">//延时消除抖动</span></span><br><span class="line">                <span class="keyword">if</span>( sbtKey1 == <span class="number">0</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    uiToneNum++;            <span class="comment">//声调改变</span></span><br><span class="line">                    <span class="keyword">if</span>( uiToneNum == <span class="number">10</span> )</span><br><span class="line">                        uiToneNum = <span class="number">0</span>;</span><br><span class="line">                    TH0 = <span class="number">0xF4</span> - uiToneNum; <span class="comment">//减小重装值，从而减小</span></span><br><span class="line">                    						<span class="comment">//定时器中断（蜂鸣器振动）频率</span></span><br><span class="line">                    sbtKey1_state = <span class="number">1</span>;      <span class="comment">//设置按键1为已按下</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            sbtKey1_state = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( sbtKey2 == <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( sbtKey2_state == <span class="number">0</span> )          <span class="comment">//判断按键2是否按下 </span></span><br><span class="line">            &#123;</span><br><span class="line">                DelayMs( <span class="number">10</span> );                <span class="comment">//延时消除抖动</span></span><br><span class="line">                <span class="keyword">if</span>( sbtKey2 == <span class="number">0</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    btBeepFlag = !btBeepFlag; <span class="comment">//蜂鸣器开关切换</span></span><br><span class="line">                    sbtKey2_state = <span class="number">1</span>;        <span class="comment">//设置按键1为已按下</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            sbtKey2_state = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        DisplaySeg7Led();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*---------T0定时器中断服务处理函数--------*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">T0_Process</span><span class="params">()</span> interrupt 1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>( btBeepFlag )</span><br><span class="line">    &#123;</span><br><span class="line">        sbtBeep = ~sbtBeep;            <span class="comment">//产生方波使得蜂鸣器发声</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        sbtBeep = <span class="number">0</span>;                  <span class="comment">//如果开关关闭,则蜂鸣器断电以保护蜂鸣器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>STC-B</category>
        <category>基础编程</category>
      </categories>
      <tags>
        <tag>单片机</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>扫描频率可改变的电子钟</title>
    <url>/2022/06/28/%E6%89%AB%E6%8F%8F%E9%A2%91%E7%8E%87%E5%8F%AF%E6%94%B9%E5%8F%98%E7%9A%84%E7%94%B5%E5%AD%90%E9%92%9F/</url>
    <content><![CDATA[<h1 id="扫描频率可以改变的电子钟"><a href="#扫描频率可以改变的电子钟" class="headerlink" title="扫描频率可以改变的电子钟"></a>扫描频率可以改变的电子钟</h1><h2 id="程序设计思路"><a href="#程序设计思路" class="headerlink" title="程序设计思路"></a>程序设计思路</h2><p>数字钟通过计数模拟时钟，将计数值，转换成时间格式，以格式：“时-分-秒”在LED数码管上显示，并通过案件调整扫描频率。</p>
<p><img src="/2022/06/28/%E6%89%AB%E6%8F%8F%E9%A2%91%E7%8E%87%E5%8F%AF%E6%94%B9%E5%8F%98%E7%9A%84%E7%94%B5%E5%AD%90%E9%92%9F/7c3906954a01b39404fea430d2308932.png" alt="img"></p>
<h2 id="相关寄存器设置"><a href="#相关寄存器设置" class="headerlink" title="相关寄存器设置"></a>相关寄存器设置</h2><ul>
<li><p>P0的八个位和P2.3设置成推挽输出。按键是输入，不需要推挽。设置寄存器配置值如下。    </p>
<blockquote>
<p>P2以及P0的端口设置，和上一个数码管扫描实验是一样的。</p>
<p>额外增加的考虑是P3端口的设置。0通道和1通道都是0，是传统的8051I/O口模式。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">P2M1=<span class="number">0x00</span>;</span><br><span class="line">P2M0=<span class="number">0xff</span>;</span><br><span class="line">P0M1=<span class="number">0x00</span>;</span><br><span class="line">P0M0=<span class="number">0xff</span>;</span><br><span class="line">P3M0=<span class="number">0x00</span>;</span><br><span class="line">P3M1=<span class="number">0x00</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过定时器0，采集方式1，在定时器中断中进行计数累加</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TMOD = <span class="number">0x01</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>打开总的中断</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">EA = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>开启定时器中断</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ET0 = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>计数寄存器初始化</p>
<blockquote>
<p>定时器0设置于模式1时，计数寄存器为16位模式，由高8位TH0和低8位TL0两个8位寄存器组成，当设定计算值为65536-50000=15536（D）时，转换为十六进制就是3CB0（H），此时，TH0=3C，TL0=B0分别装入即可，为了免除这些计算步骤，很多编程者采用“TH0=（65536-50000）/256;TL0=（65536-50000）%256“的编程方式，去让单片机自己去计算结果，那么为什么要介入256呢？其实并不难理解，做一下10——16进制的换算就知道了，256（D）=0100（H），这里01就是高8位的数据，00就是低8位的数据，通俗点说，15536（D）里有多少个256，就相当于高8位有多少数值，就是除的关系了，商存入高8位寄存器后余下的数存入低8位即可，取商计算就是TH0=（65536-50000）/256；而取余计算就是TL0=（65536-50000）%256 。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TH0=(<span class="number">65535</span><span class="number">-1000</span>)/<span class="number">256</span>;</span><br><span class="line">TL0=(<span class="number">65535</span><span class="number">-1000</span>)%<span class="number">256</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动定时器</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TR0=<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>中断1优先级置1，表示中断1设置为最高优先级</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PT0=<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置P2和P0为推挽输出模式</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">P2M1=<span class="number">0x00</span>;</span><br><span class="line">P2M0=<span class="number">0xff</span>;</span><br><span class="line">P0M1=<span class="number">0x00</span>;</span><br><span class="line">P0M0=<span class="number">0xff</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="代码说明"><a href="#代码说明" class="headerlink" title="代码说明"></a>代码说明</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 引入端口定义头文件和中断定义头文件 */</span> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;STC15F2K60S2.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;intrins.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 重命名，简写 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> uint unsigned int</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> uchar unsigned char</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 中断1 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> i1 interrupt 1</span></span><br><span class="line"></span><br><span class="line">sbit ledSel = P2 ^<span class="number">3</span>;    			<span class="comment">// LED或数码管选择信号(共用选择端信号)</span></span><br><span class="line">sbit key1 = P3 ^<span class="number">2</span>; 					<span class="comment">// 按键控制数码管扫描的频率</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 显示0-9对应的数字，段选选择 */</span></span><br><span class="line">uchar baseSevenSegment[] = &#123;</span><br><span class="line">    <span class="number">0x3f</span>, <span class="number">0x06</span>, <span class="number">0x5b</span>, <span class="number">0x4f</span>, <span class="number">0x66</span>,</span><br><span class="line">    <span class="number">0x6d</span>, <span class="number">0x7d</span>, <span class="number">0x07</span>, <span class="number">0x7f</span>, <span class="number">0x6f</span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="type">const</span> line = <span class="number">0x40</span>; 	<span class="comment">// &quot;-&quot;：8中中间横杠的段选信息</span></span><br><span class="line"><span class="type">char</span> timeAddOneFlag = <span class="number">0</span>;    		<span class="comment">// 时间增加标志，为1，时间增加一秒</span></span><br><span class="line"><span class="type">char</span> key1ActionFlag = <span class="number">0</span>;     		<span class="comment">// 按键操作标志，为1，按键操作需要响应</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> ledOnFlag = <span class="number">0</span>; 		<span class="comment">// LED亮起标志，为1，LED亮起</span></span><br><span class="line"><span class="type">char</span> tubeOnFlag = <span class="number">0</span>;        		<span class="comment">// 数码管亮标志，为1，数码管亮起</span></span><br><span class="line"><span class="type">int</span> ledValue = <span class="number">1</span>;          	 		<span class="comment">// LED显示值为多少</span></span><br><span class="line"><span class="type">int</span> myDisplay[<span class="number">8</span>] = &#123;<span class="number">0</span>&#125;;     		<span class="comment">// 数码管显示值为多少，一共8个数码管</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> timeCount = <span class="number">1</span>; 		<span class="comment">// 计数器</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> currHour = <span class="number">0</span>;			<span class="comment">// 当前小时</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> currMinute = <span class="number">0</span>;		<span class="comment">// 当前分钟</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> currSecond = <span class="number">0</span>;		<span class="comment">// 当前秒钟</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> interruptCount = <span class="number">0</span>;	<span class="comment">// 中断计数器</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> keyDownTime = <span class="number">0</span>;		<span class="comment">// 按键按下的时间</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> scanTime = <span class="number">1</span>;  		<span class="comment">// 扫描时间</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> currBit = <span class="number">0</span>;   		<span class="comment">// 当前显示的位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 延时函数 可以用ISP生成 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay5us</span><span class="params">()</span>       <span class="comment">//@11.0592MHz</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">    _nop_();</span><br><span class="line">    i = <span class="number">11</span>;</span><br><span class="line">    <span class="keyword">while</span> (--i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置ledSel,转为数码管显示 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">switchToTube</span><span class="params">()</span> &#123;</span><br><span class="line">    ledSel = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置ledSel,转为led设置 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">switchToLed</span><span class="params">()</span> &#123;</span><br><span class="line">    P0 = <span class="number">0</span>;</span><br><span class="line">    ledSel = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 改变其中一位的内容</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param bitNum 位数（第几位）（例如最左那位，则调用1）</span></span><br><span class="line"><span class="comment"> * @param value 改变后的数字，需确保大于0小于10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">change1Bit</span><span class="params">(<span class="type">int</span> bitNum, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    myDisplay[bitNum - <span class="number">1</span>] = baseSevenSegment[value];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 改变其中一位的内容（设置七段码）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param bitNum 位数（第几位）（例如最左那位，则调用1）</span></span><br><span class="line"><span class="comment"> * @param sevenSegCode 目标七段码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">change1Bit_seven</span><span class="params">(<span class="type">int</span> bitNum, <span class="type">int</span> sevenSegCode)</span> &#123;</span><br><span class="line">    myDisplay[bitNum - <span class="number">1</span>] = sevenSegCode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数码管设置为显示指定的数值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param num 数字</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">changeAll</span><span class="params">(<span class="type">long</span> num)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">7</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="type">int</span> foo = num % <span class="number">10</span>;</span><br><span class="line">        myDisplay[i] = baseSevenSegment[foo];</span><br><span class="line">        num /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * led亮</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">displayLed</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (ledOnFlag) &#123;</span><br><span class="line">        switchToLed();</span><br><span class="line">        P0 = ledValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 显示数码管</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">showTube</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tubeOnFlag) &#123;</span><br><span class="line">        switchToTube();</span><br><span class="line">        P0 = <span class="number">0</span>;</span><br><span class="line">        P2 = currBit;</span><br><span class="line">        P0 = myDisplay[currBit];</span><br><span class="line">        Delay5us();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化定时器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">timer0Initialize</span><span class="params">()</span>        <span class="comment">//0.1毫秒@12MHz</span></span><br><span class="line">&#123;</span><br><span class="line">    AUXR |= <span class="number">0x80</span>;        <span class="comment">// 定时器时钟1T模式</span></span><br><span class="line">    TMOD &amp;= <span class="number">0xF0</span>;        <span class="comment">// 设置定时器模式</span></span><br><span class="line">    TL0 = <span class="number">0xAE</span>;        	 <span class="comment">// 设置定时器初值</span></span><br><span class="line">    TH0 = <span class="number">0xFB</span>;          <span class="comment">// 设置定时器初值</span></span><br><span class="line">    TF0 = <span class="number">0</span>;             <span class="comment">// 清除TF0标志</span></span><br><span class="line">    TR0 = <span class="number">1</span>;             <span class="comment">// 定时器0开始计时</span></span><br><span class="line">    EA = <span class="number">1</span>; 			 <span class="comment">// 打开总的中断</span></span><br><span class="line">    ET0 = <span class="number">1</span>; 			 <span class="comment">// 打开定时器0中断</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 整体程序初始化函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">initialize</span><span class="params">()</span> &#123;</span><br><span class="line">    P0M0 = <span class="number">0xFF</span>;</span><br><span class="line">    P0M1 = <span class="number">0x00</span>;</span><br><span class="line">    P2M0 = <span class="number">0x0f</span>; <span class="comment">//设置P2.0-3为推挽工作状态</span></span><br><span class="line">    P2M1 = <span class="number">0x00</span>;</span><br><span class="line">    P3M0 = <span class="number">0x00</span>;</span><br><span class="line">    P3M1 = <span class="number">0x00</span>;</span><br><span class="line">    P3M0 = <span class="number">0x00</span>;</span><br><span class="line">    P3M1 = <span class="number">0x00</span>;</span><br><span class="line">    ledSel = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    timer0Initialize();</span><br><span class="line">    changeAll(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 第三位和第六位设置为 &#x27;-&#x27;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    change1Bit_seven(<span class="number">3</span>, line);</span><br><span class="line">    change1Bit_seven(<span class="number">6</span>, line);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 时间自增1秒</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">addTime</span><span class="params">()</span> &#123;</span><br><span class="line">    ++currSecond;</span><br><span class="line">    <span class="keyword">if</span> (currSecond == <span class="number">60</span>) &#123;</span><br><span class="line">        ++currMinute;</span><br><span class="line">        currSecond = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (currMinute == <span class="number">60</span>) &#123;</span><br><span class="line">            ++currHour;</span><br><span class="line">            currMinute = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (currHour == <span class="number">24</span>)</span><br><span class="line">                currHour = <span class="number">0</span>;</span><br><span class="line">            change1Bit(<span class="number">2</span>, currHour % <span class="number">10</span>);</span><br><span class="line">            change1Bit(<span class="number">1</span>, currHour / <span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        change1Bit(<span class="number">5</span>, currMinute % <span class="number">10</span>);</span><br><span class="line">        change1Bit(<span class="number">4</span>, currMinute / <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    change1Bit(<span class="number">8</span>, currSecond % <span class="number">10</span>);</span><br><span class="line">    change1Bit(<span class="number">7</span>, currSecond / <span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 按下key1要做的事</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">key1Action</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (key1ActionFlag) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ledValue == <span class="number">0x80</span>)</span><br><span class="line">            ledValue = <span class="number">0x01</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ledValue &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (ledValue == <span class="number">1</span>)</span><br><span class="line">            scanTime = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ledValue == <span class="number">2</span>)</span><br><span class="line">            scanTime = <span class="number">50</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ledValue == <span class="number">4</span>)</span><br><span class="line">            scanTime = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ledValue == <span class="number">8</span>)</span><br><span class="line">            scanTime = <span class="number">200</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ledValue == <span class="number">16</span>)</span><br><span class="line">            scanTime = <span class="number">500</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ledValue == <span class="number">32</span>)</span><br><span class="line">            scanTime = <span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ledValue == <span class="number">64</span>)</span><br><span class="line">            scanTime = <span class="number">2000</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ledValue == <span class="number">128</span>)</span><br><span class="line">            scanTime = <span class="number">5000</span>;</span><br><span class="line">        key1ActionFlag = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 收到中断的信号（是时候自增时间了）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">timeSignalHandler</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (timeAddOneFlag) &#123;</span><br><span class="line">        addTime();</span><br><span class="line">        timeAddOneFlag = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单片机运行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        timeSignalHandler();</span><br><span class="line">        displayLed();</span><br><span class="line">        showTube();</span><br><span class="line">        key1Action();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 每0.1毫秒进入一次定时器中断</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">interruptFunction</span><span class="params">()</span> i1 &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> KEY_TIME_THRESHOLD = <span class="number">500</span>;</span><br><span class="line">    interruptCount = (interruptCount + <span class="number">1</span>) % <span class="number">20000</span>;</span><br><span class="line">    <span class="comment">// led显示的频率应该低些才有好的显示效果</span></span><br><span class="line">    <span class="keyword">if</span> (interruptCount % <span class="number">12</span> &gt; <span class="number">10</span>) &#123;</span><br><span class="line">        ledOnFlag = <span class="number">1</span>;</span><br><span class="line">        tubeOnFlag = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        tubeOnFlag = <span class="number">1</span>;</span><br><span class="line">        ledOnFlag = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 数码管的扫描</span></span><br><span class="line">    <span class="keyword">if</span> (interruptCount % scanTime == <span class="number">0</span>)</span><br><span class="line">        currBit = (currBit + <span class="number">1</span>) % <span class="number">8</span>;</span><br><span class="line">    <span class="comment">// 读秒</span></span><br><span class="line">    <span class="keyword">if</span> (interruptCount % <span class="number">10000</span> == <span class="number">0</span>)</span><br><span class="line">        timeAddOneFlag = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 按键功能设置</span></span><br><span class="line">    <span class="keyword">if</span> (key1 == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (keyDownTime &lt; KEY_TIME_THRESHOLD)</span><br><span class="line">            ++keyDownTime;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (keyDownTime &gt;= KEY_TIME_THRESHOLD)</span><br><span class="line">            key1ActionFlag = <span class="number">1</span>;</span><br><span class="line">        keyDownTime = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    initialize();</span><br><span class="line">    run();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​        </p>
]]></content>
      <categories>
        <category>STC-B</category>
        <category>基础编程</category>
      </categories>
      <tags>
        <tag>单片机</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>流水灯实验</title>
    <url>/2022/06/26/%E6%B5%81%E6%B0%B4%E7%81%AF%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<h1 id="流水灯实验"><a href="#流水灯实验" class="headerlink" title="流水灯实验"></a>流水灯实验</h1><h2 id="程序设计思路"><a href="#程序设计思路" class="headerlink" title="程序设计思路"></a>程序设计思路</h2><p>流水灯是经典实验。要点亮发光二极管，要把P0端口和P2.3端口设置成推挽输出，然后</p>
<ul>
<li>将P2.3设成“1”，这表示使能发光二极管</li>
<li>对P0端口赋值，就可以点亮对应的led灯了</li>
</ul>
<p>而对于流水灯，基本思路就是点亮一个led灯，等待一段时间，然后熄灭它，同时点亮下一个led灯，然后如此循环下去，就可以看到流水效果如下</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">00000001</span><br><span class="line">00000010</span><br><span class="line">00000100</span><br><span class="line">00001000</span><br><span class="line">00010000</span><br><span class="line">00100000</span><br><span class="line">01000000</span><br><span class="line">10000000</span><br><span class="line">00000001</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h2 id="关键代码说明"><a href="#关键代码说明" class="headerlink" title="关键代码说明"></a>关键代码说明</h2><h3 id="相关定义以及头文件"><a href="#相关定义以及头文件" class="headerlink" title="相关定义以及头文件"></a>相关定义以及头文件</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 这个是我们的单片机的端口的定义 */</span></span><br><span class="line"><span class="comment">/* 如果仔细阅读头文件，可以看到就是用唯一的整数标识每一个端口 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;STC15F2K60S2.H&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义类型，简写 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> uchar unsigned char</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> uint unsigned int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 选择位 */</span></span><br><span class="line">sbit led_sel=P2^<span class="number">3</span>; <span class="comment">// 端口P2.3</span></span><br><span class="line">uchar led;         <span class="comment">// 用一个uchar表示8个LED，每一个是1位</span></span><br></pre></td></tr></table></figure>
<p>本程序主要是三个函数组成</p>
<h3 id="对二级管初始化"><a href="#对二级管初始化" class="headerlink" title="对二级管初始化"></a>对二级管初始化</h3><blockquote>
<p><code>void Init();</code></p>
</blockquote>
<p>这个函数主要是发光二极管的初始化设置：</p>
<p><strong>只要将P0口和P2.3工作模式设置为推挽输出，同时将P2.3置“1”，使能发光二极管电路。</strong>（这里的置“1”是P2的bit3置为1）</p>
<p><img src="/2022/06/26/%E6%B5%81%E6%B0%B4%E7%81%AF%E5%AE%9E%E9%AA%8C/image-20220626175135866.png" alt="image-20220626175135866"></p>
<p><img src="/2022/06/26/%E6%B5%81%E6%B0%B4%E7%81%AF%E5%AE%9E%E9%AA%8C/image-20220626175208809.png" alt="image-20220626175208809"></p>
<p>其中P0、P2这两个端口的设置通过对对应的寄存器赋值来设置实现。</p>
<p>看看上面两个表，其中第一列，也就是通道1为0（八个位都是0），通道0为1（特定位为1），表示处于推挽模式。STC15F2K60S2数据手册4.1章节（322页）有详细的介绍，下面简单介绍进一步如何配置。</p>
<p><img src="/2022/06/26/%E6%B5%81%E6%B0%B4%E7%81%AF%E5%AE%9E%E9%AA%8C/image-20220626174347225.png" alt="image-20220626174347225"></p>
<p>上面是STC-B的部分电路原理图。由于处于推挽输出模式，要求通道0为1，通道1为0。通道1为0，就把通道一八个位全部设置成低电平。但是通道0为1就要对特定位进行赋1。对于P0端口，我们可以在电路图中看到是红色框框，它对应了八个发光二极管的正极端，所以要让8个发光二极管统统发光，就要全部设置使能。所以对于P0的通道0，进行赋1，就要把八个位全部设置成1。另一方面，对于P2端口。我们看到上面对于这个实验的led灯，只有一个LED负极开漏端有一个LED_SEL选择信号，表示选择哪一个LED发光。可以看到蓝色框框，只是P2.3，也就是端口P2的0通道的第三个位赋1就好。</p>
<p>因此我们得到如下初始化代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Init</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">// P0的通道1全0</span></span><br><span class="line">	P0M1=<span class="number">0x00</span>;</span><br><span class="line">    <span class="comment">// P0的通道0全1</span></span><br><span class="line">	P0M0=<span class="number">0xff</span>;</span><br><span class="line">	<span class="comment">// P2的通道1全0</span></span><br><span class="line">	P2M1=<span class="number">0x00</span>;</span><br><span class="line">    <span class="comment">// P2的通道0只要bit3为1</span></span><br><span class="line">	P2M0=<span class="number">0x08</span>;</span><br><span class="line">	<span class="comment">// 流水灯从L0开始(00000001)</span></span><br><span class="line">	led_sel=<span class="number">1</span>;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="延时函数"><a href="#延时函数" class="headerlink" title="延时函数"></a>延时函数</h3><blockquote>
<p><code>void delay_ms(uint n);</code></p>
</blockquote>
<p>函数<code>delay_ms</code>的功能是延时n毫秒，但时间不一定特别准确。单片机工作在同一的时钟脉冲控制下。这个脉冲式单片机控制器的时钟电路产生的。时钟电路由振荡器和分频器构成，振荡器产生基本振荡信号，然后分频，得到相应时钟。（这玩意了解一下就好了）</p>
<p><strong>关于单片机中周期的说明：</strong></p>
<ul>
<li><p>振荡周期： 晶体振荡器的周期。</p>
</li>
<li><p>状态周期： 振荡信号经二分频后形成的时钟脉冲信号，用S表示。一个状态周期的两个振荡周期作为两个节拍分别称为节拍P1和节拍P2。P1有效时，通常完成算术逻辑操作；P2有效时，一般进行内部寄存器之间的传输。</p>
</li>
<li><p>机器周期： 完成一个基本操作所需的时间称为机器周期。一个机器周期包含6个状态周期，用S1、S2、….、S6表示；共12个节拍，依次可表示为S1P1、S1P2、S2P1、S2P2、……、S6P1、S6P2。</p>
</li>
<li><p>指令周期：CPU执行一条指令所需要的时间。CPU执行指令是在时钟脉冲控制下一步一步进行的，由于指令的功能和长短各不相同，因此，指令执行所需的时间也不一样。一个指令周期通常含有1～4个机器周期。 </p>
</li>
</ul>
<p><img src="/2022/06/26/%E6%B5%81%E6%B0%B4%E7%81%AF%E5%AE%9E%E9%AA%8C/b8bf661c195bddcad5caf5d85ce46e12.png" alt="img"></p>
<p>上图是MCS-51单片机各种周期的相互关系。</p>
<p>因此，根据指令执行的时间，可计算出1ms可以相应执行多少条指令，函数中可通过循环执行空指令来达到延时1ms的效果。此外延时函数也可以在STC-ISP中通过“软件延时计算器”功能自动生成指定延时时间的延时函数代码，如下：</p>
<p><img src="/2022/06/26/%E6%B5%81%E6%B0%B4%E7%81%AF%E5%AE%9E%E9%AA%8C/image-20220626184218824.png" alt="image-20220626184218824"></p>
<p>直接用ISP串口助手生成延时200ms对应的代码即可</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Delay200ms</span><span class="params">()</span>		<span class="comment">//@11.0592MHz</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i, j, k;</span><br><span class="line">	<span class="comment">//_nop_();</span></span><br><span class="line">	<span class="comment">//_nop_();</span></span><br><span class="line">	i = <span class="number">9</span>;</span><br><span class="line">	j = <span class="number">104</span>;</span><br><span class="line">	k = <span class="number">139</span>;</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">do</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">while</span> (--k);</span><br><span class="line">		&#125; <span class="keyword">while</span> (--j);</span><br><span class="line">	&#125; <span class="keyword">while</span> (--i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h3><blockquote>
<p>void main();</p>
</blockquote>
<p>首先要调用函数Init()对电路进行初始化，再循环地对P0口进行赋值，点亮流水灯。</p>
<p>每一次流水灯对应点亮的位向左移动一位，具体就如“程序设计思路”的演示图所示。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 初始化LED灯</span></span><br><span class="line">	Init();</span><br><span class="line">    <span class="comment">// 从L0开始亮</span></span><br><span class="line">	led=<span class="number">0x01</span>;</span><br><span class="line">    <span class="comment">// 无休止闪烁</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">// P0端口连接LED灯，所以把寄存器LED给P0</span></span><br><span class="line">		P0=led;</span><br><span class="line">		<span class="comment">// 延时200ms	</span></span><br><span class="line">		Delay200ms();</span><br><span class="line">        <span class="comment">// LED寄存器状态赋值</span></span><br><span class="line">		<span class="keyword">if</span>(led==<span class="number">0x80</span>) <span class="comment">// 如果到了L7灯，下一个状态又从L0开始</span></span><br><span class="line">			led=<span class="number">0x01</span>;</span><br><span class="line">		<span class="keyword">else</span>		  <span class="comment">// 否则左移一位</span></span><br><span class="line">			led=led&lt;&lt;<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="下载程序"><a href="#下载程序" class="headerlink" title="下载程序"></a>下载程序</h2><p>在学习资料里面下载相关工具。主要是<em>keil uvision 4</em>。</p>
<p><img src="/2022/06/26/%E6%B5%81%E6%B0%B4%E7%81%AF%E5%AE%9E%E9%AA%8C/image-20220627112449125.png" alt="image-20220627112449125"></p>
<p>新建工程uprojx，然后编译生成hex文件，烧入程序，运行。</p>
<blockquote>
<p>如果编译没有生成<code>.hex</code>文件可以进行如下设置</p>
</blockquote>
<p><img src="/2022/06/26/%E6%B5%81%E6%B0%B4%E7%81%AF%E5%AE%9E%E9%AA%8C/image-20220627112712761.png" alt="image-20220627112712761"></p>
<p><strong>成功效果</strong>如下</p>
<p><img src="/2022/06/26/%E6%B5%81%E6%B0%B4%E7%81%AF%E5%AE%9E%E9%AA%8C/image-20220627112808166.png" alt="image-20220627112808166"></p>
]]></content>
      <categories>
        <category>STC-B</category>
        <category>基础编程</category>
      </categories>
      <tags>
        <tag>单片机</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>红外模块通信协议</title>
    <url>/2022/07/01/%E7%BA%A2%E5%A4%96%E6%A8%A1%E5%9D%97%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h1 id="红外协议"><a href="#红外协议" class="headerlink" title="红外协议"></a>红外协议</h1><p><img src="/2022/07/01/%E7%BA%A2%E5%A4%96%E6%A8%A1%E5%9D%97%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/image-20220701164207348.png" alt="image-20220701164207348"></p>
<p>由于目前能够使用的STC单片机库的红外传输一次只能传输10 bits，因此一种比较合理的并且安全稳定的设计方法是按位进行编码。编码设计如上</p>
<h2 id="各个位功能说明"><a href="#各个位功能说明" class="headerlink" title="各个位功能说明"></a>各个位功能说明</h2><ul>
<li>选择位<ul>
<li>选择位可以进行类别的选择选择某一类指令或者是一个数据<ul>
<li>选择位最高位是0，标识为数据，此时使用偶校验</li>
<li>选择位最高位是1，标识为指令，此时使用奇校验</li>
</ul>
</li>
</ul>
</li>
<li>指令位<ul>
<li>指令位共有6位，可以进行自主设计</li>
<li>如果选择位最高位是0，标识是数据，则选择位的低两位作为数据为和指令位6位连接成一个字节</li>
<li>如果最高位是1，则是指令，在这个基础上选择位还有四位所以一共可以分成四大类的指令，如果还要细分，可以在指令位中进行进一步划分</li>
</ul>
</li>
<li>奇偶校验位<ul>
<li>奇偶校验位是根据选择位的最高位来决定的</li>
<li>同时奇偶校验位对自己以外的前9位进行计算</li>
<li>因此选择位最高位会对奇偶校验位的方式进行选择，奇偶校验位又会对包括选择位最高位在内的所有位进行校验，这种方式能够稳定传输</li>
</ul>
</li>
</ul>
<p>具体位功能设计这里不强制说明，由使用者编写。</p>
]]></content>
      <categories>
        <category>物联网设计大赛</category>
        <category>模块</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>红外协议</tag>
      </tags>
  </entry>
  <entry>
    <title>编译原理学习笔记1</title>
    <url>/2022/07/03/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/</url>
    <content><![CDATA[<h1 id="什么是编译"><a href="#什么是编译" class="headerlink" title="什么是编译"></a>什么是编译</h1><h2 id="计算机程序设计语言以及编译"><a href="#计算机程序设计语言以及编译" class="headerlink" title="计算机程序设计语言以及编译"></a>计算机程序设计语言以及编译</h2><ul>
<li>机器语言<ul>
<li>可以被计算机直接理解</li>
<li>二进制和十六进制</li>
<li>编写阅读困难</li>
</ul>
</li>
<li>汇编语言<ul>
<li>引入注记符</li>
<li>依赖于特定机器</li>
<li>书写效率低</li>
</ul>
</li>
<li>高级语言<ul>
<li>类似数学定义和自然语言</li>
<li>更接近人类习惯</li>
<li>不依赖特定机器</li>
<li>简洁</li>
</ul>
</li>
</ul>
<p>将高级语言翻译成汇编语言或者直接翻译成机器语言的过程称为编译。</p>
<p>将汇编语言翻译成机器语言的称为汇编。</p>
<p><strong>编译的定义：</strong>将<u>高级语言</u>（源语言）翻译成<u>汇编语言或机器语言</u>（目标语言）的过程。</p>
<h2 id="编译器在语言处理系统的位置"><a href="#编译器在语言处理系统的位置" class="headerlink" title="编译器在语言处理系统的位置"></a>编译器在语言处理系统的位置</h2><p><img src="/2022/07/03/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/image-20220630224930676.png" alt="image-20220630224930676"></p>
<ul>
<li><p>预处理器把存在不同文件中的源程序聚合在一块，把称为宏的编写语句转换为原始语句</p>
</li>
<li><p>加载器修改可重定位地址：将修改后的指令和数据放到内存中适当的位置</p>
</li>
<li><p>链接器将多个可重定位的机器代码文件（包括库文件）链接在一块，解决外部内存地址（引用其他文件对象或过程）问题</p>
</li>
<li><p>可重定位：在内存中存放的起始位置L不是固定的</p>
</li>
</ul>
<h1 id="编译系统的结构"><a href="#编译系统的结构" class="headerlink" title="编译系统的结构"></a>编译系统的结构</h1><blockquote>
<p>高级语言程序 =》编译器 =》机器语言</p>
<p>下面是编译的流程图，编译过程，编译器主要进行如下步骤</p>
</blockquote>
<p><img src="/2022/07/03/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/image-20220704135027449.png" alt="image-20220704135027449"></p>
<h1 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h1><h2 id="原理概述"><a href="#原理概述" class="headerlink" title="原理概述"></a>原理概述</h2><p>词法分析是编译器的第一个阶段。</p>
<blockquote>
<p>词法分析的主要任务：从左向右进行扫描源程序的字符，识别出各个单词，确定单词类型。将识别出的单词转换成统一的<strong>机内表示</strong>——词法单元（token）形式</p>
<p><strong>token：</strong>&lt;种别码，属性值&gt;</p>
<ul>
<li>种别码是单词的种类（词性词类）</li>
<li>属性值是区分同一种别的标识，具体来说就是存储字面值</li>
</ul>
</blockquote>
<p><img src="/2022/07/03/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/image-20220704135633686.png" alt="image-20220704135633686"></p>
<h2 id="词法分析例子"><a href="#词法分析例子" class="headerlink" title="词法分析例子"></a>词法分析例子</h2><p><img src="/2022/07/03/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/image-20220704140102740.png" alt="image-20220704140102740"></p>
<ul>
<li>while是一个关键字，一词一码，种别码就可以唯一确定这个单词，所以属性值空。同样的道理，左括号、不等号、右括号、左花括号、++、封号、右花括号 他们都是一词一码，所以属性值空。</li>
<li>value和num是两个标识符，还有100是常量，仅仅凭借种别码不能唯一确定，所以在属性值中放入他们的字面值，来唯一确定他们。</li>
</ul>
<h1 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h1><p>语法分析是编译的第二个阶段。</p>
<blockquote>
<p>语法分析的主要任务：语法分析器(parser)从词法分析输出的token序列中识别出各类短语，并构造语法分析树(parse tree)</p>
<p>语法分析树描述了程序语句的语法结构</p>
</blockquote>
<h3 id="例1：赋值语句的语法分析树"><a href="#例1：赋值语句的语法分析树" class="headerlink" title="例1：赋值语句的语法分析树"></a>例1：赋值语句的语法分析树</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">position = initial + rate * <span class="number">60</span>;</span><br></pre></td></tr></table></figure>
<p>经过词法分析我们可以得到对应的token序列</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  position    =   initial    +   rate    *   <span class="number">60</span>;</span><br><span class="line">&lt;id,position&gt;&lt;=&gt;&lt;id,initial&gt;&lt;+&gt;&lt;id,rate&gt;&lt;*&gt;&lt;num,<span class="number">60</span>&gt;</span><br></pre></td></tr></table></figure>
<p>我们可以的到语法分析树：</p>
<p><img src="/2022/07/03/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/image-20220704141928523.png" alt="image-20220704141928523"></p>
<ul>
<li>一个标识符和一个常数，它们本身可以构成表达式。一个表达书通过运算符，例如“+、*”又可以构成另外一个表达式。</li>
<li><u>标识符</u>连接上一个<u>赋值符号</u>再连接上一个<u>表达式</u>最后连接一个<u>封号</u>可以构成赋值语句。</li>
</ul>
<h3 id="例2：变量声明语句的分析树"><a href="#例2：变量声明语句的分析树" class="headerlink" title="例2：变量声明语句的分析树"></a>例2：变量声明语句的分析树</h3><ul>
<li><p>文法，文法是一系列规则构成的：</p>
<ul>
<li>这里的D表示declaration，表示声明语句</li>
<li>T是type，表示类型</li>
<li>IDS是identifier sequence，表示标识符序列</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&lt;D&gt;-&gt;&lt;T&gt;&lt;IDS&gt;;</span><br><span class="line">一个声明语句是由一个类型连接上一个标识符序列和一个封号构成</span><br><span class="line">&lt;T&gt;-&gt;int|real|char|bool</span><br><span class="line">类型可以是int，real，char，bool中的一个</span><br><span class="line">&lt;IDS&gt;-&gt;<span class="built_in">id</span>|&lt;IDS&gt;,<span class="built_in">id</span></span><br><span class="line">一个标识符<span class="built_in">id</span>本身可以构成一个标识符序列；一个标识符序列和一个<span class="built_in">id</span>通过<span class="string">&quot;,&quot;</span>连接起来，可以构成一个更大的标识符序列</span><br></pre></td></tr></table></figure>
</li>
<li><p>根据上面的文法，我们输入：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a,b,c;</span><br></pre></td></tr></table></figure>
<p>可以得到它的分析树</p>
<p><img src="/2022/07/03/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/image-20220704143428661.png" alt="image-20220704143428661"></p>
</li>
</ul>
<h1 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h1><p>语义分析是编译的第三个阶段</p>
<blockquote>
<p>语义分析的主要任务：</p>
<ul>
<li>收集标识符的属性信息</li>
<li>语义检查</li>
</ul>
</blockquote>
<h2 id="收集标识符属性信息"><a href="#收集标识符属性信息" class="headerlink" title="收集标识符属性信息"></a>收集标识符属性信息</h2><h3 id="标识符的属性"><a href="#标识符的属性" class="headerlink" title="标识符的属性"></a>标识符的属性</h3><p>标识符都有哪些属性呢？</p>
<ul>
<li><p>种属（Kind）</p>
<ul>
<li>简单变量、复合变量（数组、记录、…）、过程、…</li>
</ul>
</li>
<li><p>类型（Type）</p>
<ul>
<li>整型、实型、字符型、布尔型、指针型、…</li>
</ul>
</li>
<li><p>存储位置、长度</p>
<p><img src="/2022/07/03/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/image-20220704144057609.png" alt="image-20220704144057609"></p>
</li>
<li><p>值</p>
</li>
<li>过程的作用域</li>
<li>参数和返回值信息<ul>
<li>参数个数、参数类型、参数传递方式、返回值类型、…</li>
</ul>
</li>
</ul>
<h3 id="符号表"><a href="#符号表" class="headerlink" title="符号表"></a>符号表</h3><p><img src="/2022/07/03/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/image-20220704144846519.png" alt="image-20220704144846519"></p>
<p>语义分析的到的标识符的信息都会存放在符号表中。</p>
<p>上面的表中，每一行，称为符号表的一条记录。每一个标识符都会对应一条记录。每一个字段就对应了标识符的一个属性，比如类型type、种属kind等。</p>
<p>符号表通常带有一个字符串表，存放程序中用到的<u>标识符</u>和<u>常字符串</u>。</p>
<p>NAME分成两部分，一部分存放标志符在字符串表中的起始位置，另一部分用来存放标识符的长度。</p>
<h2 id="语义检查"><a href="#语义检查" class="headerlink" title="语义检查"></a>语义检查</h2><p>语义分析主要包括如下工作</p>
<ul>
<li>变量或过程<u>未经声明就使用</u></li>
<li>变量或过程名<u>重复声明</u></li>
<li><u>运算分量</u>类型不匹配（可能进行强制类型转换）</li>
<li><u>操作符</u>和<u>操作数</u>的类型不匹配<ul>
<li><u>数组下标</u>不是整数</li>
<li>对<u>非数组变量</u>使用数组访问操作符</li>
<li>对<u>非过程名</u>使用调用操作符</li>
<li>过程调用的<u>参数类型或数目</u>不匹配</li>
<li>函数<u>返回类型</u>有错误</li>
</ul>
</li>
</ul>
<h1 id="中间代码生成和编译器后端"><a href="#中间代码生成和编译器后端" class="headerlink" title="中间代码生成和编译器后端"></a>中间代码生成和编译器后端</h1><h2 id="中间代码生成"><a href="#中间代码生成" class="headerlink" title="中间代码生成"></a>中间代码生成</h2><h3 id="常用的中间表示形式"><a href="#常用的中间表示形式" class="headerlink" title="常用的中间表示形式"></a>常用的中间表示形式</h3><ul>
<li><p>三地址码（Three-address Code）</p>
<ul>
<li><p>三地址码由<u>类似于汇编</u>的指令序列组成，每个指令<u>最多有三个操作数</u>（operand）</p>
</li>
<li><p>常用的三地址指令</p>
<p><img src="/2022/07/03/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/image-20220704150228720.png" alt="image-20220704150228720" style="zoom:80%;"></p>
<ul>
<li>地址可以具有如下形式之一<ul>
<li>源程序中的名字（NAME）</li>
<li>常量（constant）</li>
<li>编译器生成的临时变量</li>
</ul>
</li>
</ul>
</li>
<li><p>三地址指令表示</p>
<ul>
<li><p>四元式（Quadruples）</p>
<ul>
<li>（op，y，z，x）</li>
</ul>
<p><img src="/2022/07/03/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/image-20220704151132100.png" alt="image-20220704151132100"></p>
<p>从上面的示例，我们可以看出：三地址指令序列唯一确定了一个运算完整的顺序</p>
</li>
<li><p>三元式（Triples）</p>
</li>
<li><p>间接三元式（Indirect triples）</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>语法结构树/语法树（Syntax Trees）</p>
<ul>
<li>请注意这里的的语法结构树和起那面的语法分析树不是一回事</li>
</ul>
</li>
</ul>
<h3 id="中间代码生成的例子"><a href="#中间代码生成的例子" class="headerlink" title="中间代码生成的例子"></a>中间代码生成的例子</h3><p><img src="/2022/07/03/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/image-20220704151743975.png" alt="image-20220704151743975"></p>
<p>右边的式中间代码，左边的式语法结构树。</p>
<p>其中左边的树中：S是中间代码集合，B是判断语句，E是表达式</p>
<h2 id="目标代码生成"><a href="#目标代码生成" class="headerlink" title="目标代码生成"></a>目标代码生成</h2><p><img src="/2022/07/03/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/image-20220704153054925.png" alt="image-20220704153054925"></p>
<ul>
<li>目标代码生成以源程序的<u>中间表示形式</u>作为输入，并把它映射到<u>目标语言</u></li>
<li>目标代码生成的一个重要任务是为程序中使用的变量<u>合理分配寄存器</u></li>
</ul>
<h2 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h2><p>为改进代码所进行的<u>等价程序变换</u>，使其<u>运行得更快</u>一些、<u>占用空间更少</u>一些、或者两者兼顾</p>
<p>包括例如：自动识别代码中得重复运算</p>
]]></content>
      <categories>
        <category>courses-learning</category>
        <category>编译原理笔记</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>编译原理学习笔记2</title>
    <url>/2022/07/05/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/</url>
    <content><![CDATA[<h1 id="词法语法分析基本概念"><a href="#词法语法分析基本概念" class="headerlink" title="词法语法分析基本概念"></a>词法语法分析基本概念</h1><h2 id="字母表"><a href="#字母表" class="headerlink" title="字母表"></a>字母表</h2><p>字母表（Alphabet）：字母表∑是一个<u>有穷符号集合</u></p>
<ul>
<li>符号：字母、数字、标点符号、…</li>
</ul>
<p>例如：</p>
<ul>
<li>二进制字母表：{0，1}</li>
<li>ASCII字符集</li>
<li>Unicode字符集</li>
</ul>
<h2 id="字母表的运算"><a href="#字母表的运算" class="headerlink" title="字母表的运算"></a>字母表的运算</h2><ul>
<li><p>字母表$∑_1$和$∑_2$的<u>乘积</u></p>
<p><img src="/2022/07/05/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/image-20220706001340805.png" alt="image-20220706001340805"></p>
</li>
<li><p>字母表的<u>n次幂</u></p>
</li>
</ul>
<p><img src="/2022/07/05/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/image-20220706001746142.png" alt="image-20220706001746142" style="zoom:80%;"></p>
<ul>
<li>字母表的<u>正闭包运算</u></li>
</ul>
<p><img src="/2022/07/05/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/image-20220706001834961.png" alt="image-20220706001834961" style="zoom: 67%;"></p>
<ul>
<li>字母表的<u>克林闭包</u></li>
</ul>
<p><img src="/2022/07/05/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/image-20220706001936935.png" alt="image-20220706001936935" style="zoom:67%;"></p>
<h2 id="串"><a href="#串" class="headerlink" title="串"></a>串</h2><p>设∑是一个字母表，任意x∈∑*（克林闭包），x称为是∑上的一个<u>串</u></p>
<p>由此可见，串是字母中符号的一个又穷序列</p>
<p>串s的长度，通常记为|s|，是指s中符号的个数</p>
<ul>
<li>例如|aab| = 3</li>
</ul>
<p>空串是长度为0的串，用ε（epsilon）表示</p>
<ul>
<li>|ε| = 0</li>
</ul>
<h2 id="串上的运算——连接"><a href="#串上的运算——连接" class="headerlink" title="串上的运算——连接"></a>串上的运算——连接</h2><p>x和y是两个串，x和y的连接时把y附加到x的后面形成的串，记为xy</p>
<ul>
<li>例如x = dog且y = house，则xy = doghouse</li>
</ul>
<p>空串时连接运算的单位元，即，对于任何串s有，εs = sε = s</p>
<p><img src="/2022/07/05/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/image-20220706002929267.png" alt="image-20220706002929267"></p>
<h2 id="串上的运算——幂运算"><a href="#串上的运算——幂运算" class="headerlink" title="串上的运算——幂运算"></a>串上的运算——幂运算</h2><p><img src="/2022/07/05/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/image-20220706003037100.png" alt="image-20220706003037100" style="zoom:80%;"></p>
<h1 id="文法的定义"><a href="#文法的定义" class="headerlink" title="文法的定义"></a>文法的定义</h1><h2 id="文法概述"><a href="#文法概述" class="headerlink" title="文法概述"></a>文法概述</h2><p><img src="/2022/07/05/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/image-20220706093506887.png" alt="image-20220706093506887" style="zoom:80%;"></p>
<p><img src="/2022/07/05/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/image-20220706093617730.png" alt="image-20220706093617730"></p>
<p><img src="/2022/07/05/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/image-20220706093821496.png" alt="image-20220706093821496" style="zoom:80%;"></p>
<p>PS：E表示的是表达式</p>
<h2 id="产生式的简写"><a href="#产生式的简写" class="headerlink" title="产生式的简写"></a>产生式的简写</h2><p><img src="/2022/07/05/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/image-20220706094045868.png" alt="image-20220706094045868"></p>
<h2 id="符号约定"><a href="#符号约定" class="headerlink" title="符号约定"></a>符号约定</h2><p><img src="/2022/07/05/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/image-20220706094125505.png" alt="image-20220706094125505" style="zoom: 67%;"></p>
<p><img src="/2022/07/05/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/image-20220706094210869.png" alt="image-20220706094210869" style="zoom:67%;"></p>
<p><img src="/2022/07/05/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/image-20220706094418507.png" alt="image-20220706094418507"></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>示例</th>
<th>补充说明</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>终结符</td>
<td>a,b,c</td>
<td>终结符号串</td>
<td>u,v,…,z</td>
</tr>
<tr>
<td>非终结符</td>
<td>A,B,C</td>
<td></td>
<td></td>
</tr>
<tr>
<td>文法符号</td>
<td>X,Y,Z</td>
<td>文法符号串</td>
<td>α,β,γ</td>
</tr>
</tbody>
</table>
</div>
<h1 id="语言的定义"><a href="#语言的定义" class="headerlink" title="语言的定义"></a>语言的定义</h1><h2 id="推导和归约"><a href="#推导和归约" class="headerlink" title="推导和归约"></a>推导和归约</h2><p><img src="/2022/07/05/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/image-20220707070400509.png" alt="image-20220707070400509"></p>
<p><img src="/2022/07/05/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/image-20220707070547641.png" alt="image-20220707070547641" style="zoom:80%;"></p>
<h3 id="推导和规约的例子"><a href="#推导和规约的例子" class="headerlink" title="推导和规约的例子"></a>推导和规约的例子</h3><blockquote>
<p>例句：little boy eats apple.</p>
</blockquote>
<p><img src="/2022/07/05/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/image-20220707070757275.png" alt="image-20220707070757275"></p>
<h2 id="句型和句子"><a href="#句型和句子" class="headerlink" title="句型和句子"></a>句型和句子</h2><p><img src="/2022/07/05/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/image-20220707070943358.png" alt="image-20220707070943358"></p>
<p><img src="/2022/07/05/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/image-20220707071112194.png" alt="image-20220707071112194"></p>
<p>可以产生无穷个句子，也就是说，文法解决了“<u>无穷语言的有穷表达形式</u>”。</p>
<h2 id="文法定义标识符的例子"><a href="#文法定义标识符的例子" class="headerlink" title="文法定义标识符的例子"></a>文法定义标识符的例子</h2><p><img src="/2022/07/05/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/image-20220707071406429.png" alt="image-20220707071406429"></p>
<blockquote>
<p>课上提出的问题：请写出无符号整数和浮点数的文法定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 无符号整数的文法定义 */</span></span><br><span class="line">S-&gt;<span class="number">0</span>|D(D∪<span class="number">0</span>)*</span><br><span class="line">D-&gt;<span class="number">1</span>|<span class="number">2</span>|<span class="number">3</span>|...|<span class="number">9</span></span><br><span class="line">PS: 无符号整数实际上就是<span class="number">0</span>和非零数构成的，所以S由<span class="number">0</span>和(D∪<span class="number">0</span>)*[非零数]构成</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 浮点数的文法定义 */</span></span><br><span class="line">S-&gt;MFNE</span><br><span class="line">N-&gt;.|ε	<span class="comment">// 整数还是小数</span></span><br><span class="line">M-&gt;+|-	<span class="comment">// 符号</span></span><br><span class="line">E-&gt;ED|ε <span class="comment">// 任意长度的数字串或空串</span></span><br><span class="line">F-&gt;FD|D <span class="comment">// 非零长度数字串(浮点数非空)</span></span><br><span class="line">D-&gt;<span class="number">0</span>|<span class="number">1</span>|...|<span class="number">9</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="文法的运算"><a href="#文法的运算" class="headerlink" title="文法的运算"></a>文法的运算</h2><p><img src="/2022/07/05/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/image-20220707074537980.png" alt="image-20220707074537980"></p>
<h1 id="文法的分类"><a href="#文法的分类" class="headerlink" title="文法的分类"></a>文法的分类</h1><h2 id="0型文法"><a href="#0型文法" class="headerlink" title="0型文法"></a>0型文法</h2><p><img src="/2022/07/05/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/image-20220707074702293.png" alt="image-20220707074702293"></p>
<h2 id="1型文法（上下文有关文法）"><a href="#1型文法（上下文有关文法）" class="headerlink" title="1型文法（上下文有关文法）"></a>1型文法（上下文有关文法）</h2><p><img src="/2022/07/05/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/image-20220707074803369.png" alt="image-20220707074803369"></p>
<h2 id="2型文法（上下文无关文法）"><a href="#2型文法（上下文无关文法）" class="headerlink" title="2型文法（上下文无关文法）"></a>2型文法（上下文无关文法）</h2><p><img src="/2022/07/05/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/image-20220707074916160.png" alt="image-20220707074916160"></p>
<h2 id="3型文法（正规文法）"><a href="#3型文法（正规文法）" class="headerlink" title="3型文法（正规文法）"></a>3型文法（正规文法）</h2><p><img src="/2022/07/05/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/image-20220707075219571.png" alt="image-20220707075219571" style="zoom: 67%;"></p>
<h2 id="四种文法的关系"><a href="#四种文法的关系" class="headerlink" title="四种文法的关系"></a>四种文法的关系</h2><p><img src="/2022/07/05/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/image-20220707075342222.png" alt="image-20220707075342222"></p>
<blockquote>
<p><strong>判断文法类型</strong><br>有文法G为：A-&gt;ε|aB，B-&gt;Ab|a，请判断文法G属于哪一类文法？<br>解题思路: 第一步：判断是否是0型文法，推导式左边是否至少包含一个非终结符，如果满足，则符合0型文法，；第二步：判断是否是1型文法：推导式右边的长度是否大于等于推导式左边的长度，如果满足，则符合1型文法；第三部：判断是否是2型文法，推导式左边是否是非终结符，如果满足，则符合2型文法；第四步：判断是左线性还是右线性，同时满足则不符合，只能是左线性和或者右线性中一个。<br>答案：2型文法</p>
</blockquote>
<h1 id="CFG的分析树"><a href="#CFG的分析树" class="headerlink" title="CFG的分析树"></a>CFG的分析树</h1><p>正则文法可以满足程序设计语言中的几乎所有单词构造，但是生成能力有限，不能满足句子构造。所以退而求其次，我们研究上下文无关文法的分析树。</p>
<h2 id="分析树"><a href="#分析树" class="headerlink" title="分析树"></a>分析树</h2><p><img src="/2022/07/05/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/image-20220707075704552.png" alt="image-20220707075704552"></p>
<p><strong>分析树是推导的图形化表示！</strong></p>
<p><img src="/2022/07/05/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/image-20220707075918441.png" alt="image-20220707075918441"></p>
<h2 id="（句型的）短语"><a href="#（句型的）短语" class="headerlink" title="（句型的）短语"></a>（句型的）短语</h2><p><img src="/2022/07/05/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/image-20220707080434612.png" alt="image-20220707080434612"></p>
<ul>
<li>直接短语一定是某一个产生式的右部<ul>
<li>例如下面的“提高|人民|生活|水平”都是直接短语，都是④或者⑤的右部</li>
</ul>
</li>
<li>产生式的右部不一定是给定句型的直接短语<ul>
<li>例如“高人|民生|活水”，虽然是右部但是不是直接短语</li>
</ul>
</li>
</ul>
<p><img src="/2022/07/05/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/image-20220707080733037.png" alt="image-20220707080733037"></p>
<p>这是由于，句型只是这个文法的一个特例模板，不一定式所有的右部的定义都用的上的。</p>
<h2 id="二义性文法"><a href="#二义性文法" class="headerlink" title="二义性文法"></a>二义性文法</h2><blockquote>
<p>如果一个文法可以为某个句子生成<u>多棵分析树</u>，则称这个文法是<u>二义性</u>的</p>
</blockquote>
<p>让我们直接看一个例子，给定下面的文法和一个给定的句型，可以构造这个句型的两个分析树。</p>
<p><img src="/2022/07/05/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/image-20220707081301716.png" alt="image-20220707081301716"></p>
<p><img src="/2022/07/05/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/image-20220707081322485.png" alt="image-20220707081322485"></p>
<p>由于这个文法可以为这个句型，构造两个分析树，所以称为二义性文法。<strong>大多数编译器都希望不要有二义性文法。</strong>因此要对文法进行改造，但是要付出代价，下面看看如何改造。</p>
<p>上面产生歧义的源头是：有两个if但是只有一个else！这使得else可以和两个if中的任意一个匹配。</p>
<p>大多数程序设计语言中都有这样的<strong>消歧规则：</strong>每一个else和最近的尚未匹配的if匹配。</p>
<p>因此引入这条规则上面两棵分析树只能保留左边的分析树。</p>
<p><img src="/2022/07/05/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/image-20220707082156672.png" alt="image-20220707082156672"></p>
]]></content>
      <categories>
        <category>courses-learning</category>
        <category>编译原理笔记</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>编译原理学习笔记3</title>
    <url>/2022/07/09/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03/</url>
    <content><![CDATA[<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p><u>正则表达式</u>（Regular Expression，RE）是一种用来描述正则语言的更紧凑的表示方法</p>
<blockquote>
<p>例如：r = a(a|b)*(ε|(.|_)(a|b)(a|b)*)</p>
</blockquote>
<p><strong>正则表达式</strong>可以由较小的正则表达式按照特定规则递归构造。每个正则表达式r定义（表示）一个语言，记为L(r)。这个语言也根据r的子表达式所表示的语言递归定义。</p>
<blockquote>
<p>例子：</p>
<ul>
<li>digit → 0|1|..|9</li>
<li>digits → digit digit*</li>
<li>可选小数部分：optionalFraction → .digits|ε </li>
<li>可选指数指数部分：optionalExponent → (E(+|-|ε)digits)|ε</li>
<li>number → digits optionalFraction optionalExponent</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 例子</span></span><br><span class="line">2	2.15	2.15E+3		2.15E-3		2.15E3		2E-3</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="有穷自动机"><a href="#有穷自动机" class="headerlink" title="有穷自动机"></a>有穷自动机</h1><h2 id="有穷自动机的定义"><a href="#有穷自动机的定义" class="headerlink" title="有穷自动机的定义"></a>有穷自动机的定义</h2><p>是对一类处理系统建立的数学模型。这一类系统具有一系列离散的输入输出信息和有穷数目的内部状态（状态：对过去输入信息处理的状态）。参考有限状态机。</p>
<p>FA的典型例子：电梯控制装置</p>
<ul>
<li>输入：顾客乘电梯的需求（要达到的楼层号）</li>
<li>状态：电梯所处的层数和运动方向</li>
<li>电梯控制装置不需要记住先前全部的服务要求，只要记住电梯当前所处的状态以及还没满足的所有服务请求。</li>
</ul>
<p><img src="/2022/07/09/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03/image-20220724153635370.png" alt="image-20220724153635370"></p>
<h2 id="FA定义（接收）的语言"><a href="#FA定义（接收）的语言" class="headerlink" title="FA定义（接收）的语言"></a>FA定义（接收）的语言</h2><p><img src="/2022/07/09/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03/image-20220724153914512.png" alt="image-20220724153914512"></p>
<blockquote>
<p>L(M) = 所有以abb结尾的字母表{a，b}上的串的集合</p>
</blockquote>
<h2 id="最长子串匹配原则"><a href="#最长子串匹配原则" class="headerlink" title="最长子串匹配原则"></a>最长子串匹配原则</h2><p><img src="/2022/07/09/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03/image-20220724154114487.png" alt="image-20220724154114487"></p>
<p>所以上面的例子中，输入串中匹配的应该是“&lt;=”和“++”，而不是“&lt;”和“=”或者两个“+”</p>
<h1 id="有穷自动机的分类"><a href="#有穷自动机的分类" class="headerlink" title="有穷自动机的分类"></a>有穷自动机的分类</h1><h2 id="确定的有穷自动机-DFA"><a href="#确定的有穷自动机-DFA" class="headerlink" title="确定的有穷自动机(DFA)"></a>确定的有穷自动机(DFA)</h2><p><img src="/2022/07/09/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03/image-20220724160205619.png" alt="image-20220724160205619"></p>
<p><img src="/2022/07/09/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03/image-20220724160540181.png" alt="image-20220724160540181"></p>
<p>转换图和转换表是等价的，所以可以不用转换表来表示状态转移。</p>
<h2 id="非确定的有穷状态机-NFA"><a href="#非确定的有穷状态机-NFA" class="headerlink" title="非确定的有穷状态机(NFA)"></a>非确定的有穷状态机(NFA)</h2><p><img src="/2022/07/09/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03/image-20220724160802826.png" alt="image-20220724160802826"></p>
<p><img src="/2022/07/09/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03/image-20220724160849386.png" alt></p>
<p>不确定的FA就是，一个状态，沿着标记为a的边出发，不止到达一个状态。例如上面的状态0，沿着a的标记边出发，可以到达状态0和状态1。如果某个状态从一个标记的边出发不能到达任何状态，就把空集放到表项中，例如上面的状态1通过a边，就不能到任何状态。</p>
<h2 id="DFA和NFA的等价性"><a href="#DFA和NFA的等价性" class="headerlink" title="DFA和NFA的等价性"></a>DFA和NFA的等价性</h2><ul>
<li>对于任意的NFA <em>N</em>，存在识别同一语言的DFA <em>D</em></li>
<li>对于任意的DFA <em>D</em>，存在识别同一语言的NFA <em>N</em></li>
</ul>
<p><img src="/2022/07/09/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03/image-20220724164312824.png" alt="image-20220724164312824"></p>
<p>NFA看起来分析起来要更加直观简单，但是计算机实现DFA要更容易一点</p>
<h2 id="带有“ε-边”的NFA"><a href="#带有“ε-边”的NFA" class="headerlink" title="带有“ε-边”的NFA"></a>带有“ε-边”的NFA</h2><p><img src="/2022/07/09/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03/image-20220724164550054.png" alt="image-20220724164550054"></p>
<blockquote>
<p>r = 0*1*2*</p>
</blockquote>
<p><img src="/2022/07/09/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03/image-20220724164719463.png" alt="image-20220724164719463"></p>
<h2 id="DFA的算法实现"><a href="#DFA的算法实现" class="headerlink" title="DFA的算法实现"></a>DFA的算法实现</h2><blockquote>
<p>前面说到DFA在计算机实现上要比NFA更加容易，下面是它的算法实现</p>
</blockquote>
<p><img src="/2022/07/09/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03/image-20220724164844160.png" alt="image-20220724164844160"></p>
<p>s表示当前状态，如果最后s在接收状态集F中，则表示成功接收。否则到不确定状态了，就回答no。</p>
<h1 id="从正则表达式到有穷自动机"><a href="#从正则表达式到有穷自动机" class="headerlink" title="从正则表达式到有穷自动机"></a>从正则表达式到有穷自动机</h1><blockquote>
<p>前面说到DFA在计算机上要更容易实现，但是NFA要更加容易分析，所以我们通常先得到NFA，再得到DFA</p>
</blockquote>
<h2 id="根据RE-正则表达式-构造NFA"><a href="#根据RE-正则表达式-构造NFA" class="headerlink" title="根据RE(正则表达式)构造NFA"></a>根据RE(正则表达式)构造NFA</h2><p><img src="/2022/07/09/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03/image-20220724165517326.png" alt="image-20220724165517326"></p>
<p><img src="/2022/07/09/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03/image-20220724165601319.png" alt="image-20220724165601319"></p>
<p><img src="/2022/07/09/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03/image-20220724165711728.png" alt="image-20220724165711728"></p>
<h2 id="从NFA到DFA的转换方法"><a href="#从NFA到DFA的转换方法" class="headerlink" title="从NFA到DFA的转换方法"></a>从NFA到DFA的转换方法</h2><p><img src="/2022/07/09/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03/image-20220724170114615.png" alt="image-20220724170114615"></p>
<blockquote>
<p>方法就是从初始状态开始，到第一个状态A，然后看所有的边，只有a可以进入非空下一状态，所以A通过a进入状态{A,B}，也就是DFA中的A,B状态；然后看状态A和状态B的所有边，首先是a，可以进入{A,B}和∅，它们的并集就是{A,B}，所以状态A,B可以通过a边进入自身，同理通过b可以进入{B,C}和∅的并集，所以状态A,B通过b边进入状态B,C；然后看状态B,C，方法和前面一样，最后得到通过b进入自身，通过c进入状态C,D；状态C,D是终止状态，只能通过c进入自身。</p>
<p>最多只能进入到自身的状态就是终止状态太。不能进入到自身的状态同时不需要任何条件进入下一状态的一般是起始状态，这列的start就是自动进入状态A的</p>
<p>如果类似于C,D状态这种状态，它包含在NFA中的终止状态D，那么在DFA中C,D状态就是终止状态</p>
</blockquote>
<p>在看一个例子</p>
<p><img src="/2022/07/09/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03/image-20220724171239688.png" alt="image-20220724171239688"></p>
<p>注意到，这里有三个终止状态，也就说DFA可以不止一个终止状态。只要包含NFA中的终止状态的状态就是DFA中的终止状态。</p>
<h2 id="子集构造法"><a href="#子集构造法" class="headerlink" title="子集构造法"></a>子集构造法</h2><blockquote>
<p>由于从NFA构造的DFA中的每一个状态都是NFA中状态集合的一个子集，因此NFA转换成DFA的算法又称作子集构造法</p>
</blockquote>
<p>这里伪代码就不写了，感兴趣可以搜索一下，原理上面都讲过了。</p>
<h1 id="识别单词的DFA"><a href="#识别单词的DFA" class="headerlink" title="识别单词的DFA"></a>识别单词的DFA</h1><p><img src="/2022/07/09/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03/image-20220724172022748.png" alt="image-20220724172022748"></p>
<p><img src="/2022/07/09/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03/image-20220724172239405.png" alt="image-20220724172239405"></p>
<p>通过上面NFA转DFA的方法，可以画出DFA</p>
<p><img src="/2022/07/09/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03/image-20220724173247829.png" alt="image-20220724173247829"></p>
<h2 id="识别各进制无符号整数的DFA"><a href="#识别各进制无符号整数的DFA" class="headerlink" title="识别各进制无符号整数的DFA"></a>识别各进制无符号整数的DFA</h2><p><img src="/2022/07/09/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03/image-20220724173527397.png" alt="image-20220724173527397"></p>
<h2 id="识别注释的DFA"><a href="#识别注释的DFA" class="headerlink" title="识别注释的DFA"></a>识别注释的DFA</h2><p><img src="/2022/07/09/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03/image-20220724173810908.png" alt="image-20220724173810908"></p>
<h2 id="识别Token的DFA"><a href="#识别Token的DFA" class="headerlink" title="识别Token的DFA"></a>识别Token的DFA</h2><p><img src="/2022/07/09/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03/image-20220724173906227.png" alt="image-20220724173906227"></p>
<p>把上面讲的各类识别的DFA合到一个DFA下，就可以构造一个识别Token的DFA，可以识别不同类型单词的DFA，就达到了我们这一节的识别单词的DFA的目的</p>
<p>这里没有提到<strong>关键字</strong>，但是可以用上图标志符（IDN）的识别方法。如果识别出来一个标识符它是在关键字表里面的就把他识别成一个关键字，否则就照常识别成一个标识符。</p>
<h2 id="词法分析阶段的错误处理"><a href="#词法分析阶段的错误处理" class="headerlink" title="词法分析阶段的错误处理"></a>词法分析阶段的错误处理</h2><p><img src="/2022/07/09/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03/image-20220724174231290.png" alt="image-20220724174231290"></p>
<p><img src="/2022/07/09/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03/image-20220724174318518.png" alt="image-20220724174318518"></p>
<blockquote>
<p>最简单的错误恢复策略是“恐慌模式（panic mode）”恢复：</p>
<p>从剩余的输入中不断删除字符，直到词法分析器能够在剩余输入的开头发现一个正确的字符位置</p>
</blockquote>
]]></content>
      <categories>
        <category>courses-learning</category>
        <category>编译原理笔记</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>OS期末铧锺碘</title>
    <url>/2022/06/14/OS%E6%9C%9F%E6%9C%AB%E9%93%A7%E9%94%BA%E7%A2%98/</url>
    <content><![CDATA[<h1 id="操作系统铧锺碘"><a href="#操作系统铧锺碘" class="headerlink" title="操作系统铧锺碘"></a>操作系统铧锺碘</h1><p>期末考占总评的40%</p>
<p>老师提到的考试复习指南：</p>
<ul>
<li>注重应用，需要直到API怎么用，各个参数是什么</li>
<li>能够举一些例子</li>
<li>从网络上找一些经典的资料</li>
</ul>
<h2 id="四个简答题"><a href="#四个简答题" class="headerlink" title="四个简答题"></a>四个简答题</h2><p>分值：5分一个</p>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><blockquote>
<ul>
<li>各种调度算法是什么样的。各种调度算法有什么特点，还存在什么问题？</li>
<li>多级反馈队列为什么常用，彩票调度算法和步长调度算法等公平份额算法为什么不行？</li>
</ul>
</blockquote>
<h4 id="各种调度算法的特点和优缺点"><a href="#各种调度算法的特点和优缺点" class="headerlink" title="各种调度算法的特点和优缺点"></a>各种调度算法的特点和优缺点</h4><h5 id="先进先出-FIFO"><a href="#先进先出-FIFO" class="headerlink" title="先进先出(FIFO)"></a>先进先出(FIFO)</h5><ul>
<li>先进先出（First In First Out，FIFO），或者又叫做先到先服务（First Come First Served，FCFS）</li>
</ul>
<p><img src="/2022/06/14/OS%E6%9C%9F%E6%9C%AB%E9%93%A7%E9%94%BA%E7%A2%98/image-20220614133547462.png" alt="image-20220614133547462" style="zoom:80%;"></p>
<ul>
<li>优点：简单，易于实现（最符合直觉的策略）</li>
<li>存在问题：<ul>
<li>存在护航效应（一些耗时较少的潜在资源消费 者被排在重量级的资源消费者之后）。简而言之就是：先到达的长进程让后到达的短进程饿死。</li>
<li>周转时间和响应时间都是糟糕的。</li>
</ul>
</li>
</ul>
<h5 id="最短任务-作业-优先-SJF"><a href="#最短任务-作业-优先-SJF" class="headerlink" title="最短任务(作业)优先(SJF)"></a>最短任务(作业)优先(SJF)</h5><ul>
<li>最短任务优先（First Job First，SJF）：先运行最短的任务，然后是次短的任务，如此下去。</li>
</ul>
<p><img src="/2022/06/14/OS%E6%9C%9F%E6%9C%AB%E9%93%A7%E9%94%BA%E7%A2%98/image-20220614133837340.png" alt="image-20220614133837340" style="zoom:80%;"></p>
<ul>
<li>特点：<ul>
<li>SJF在所有作业同时到达的情况下是最优（optmial，opt）调度算法。</li>
<li>它是非抢占式的，如果长任务比短任务先到达，还是会有护航效应。</li>
</ul>
</li>
<li>优点：<ul>
<li>周转时间很好</li>
</ul>
</li>
<li>缺点：<ul>
<li>响应时间不好</li>
</ul>
</li>
</ul>
<h5 id="最短完成时间优先-STCF"><a href="#最短完成时间优先-STCF" class="headerlink" title="最短完成时间优先(STCF)"></a>最短完成时间优先(STCF)</h5><ul>
<li>向SJF添加抢占，就是最短完成时间优先（Shortest Time-to-Completion First，STCF）或者称作抢占式最短作业优先（Preemptive Shortest Job）调度程序</li>
</ul>
<p><img src="/2022/06/14/OS%E6%9C%9F%E6%9C%AB%E9%93%A7%E9%94%BA%E7%A2%98/image-20220614135705282.png" alt="image-20220614135705282" style="zoom:80%;"></p>
<ul>
<li>特点：<ul>
<li>STCF在作业不同时到达的情况下延续了SJF的最优性</li>
<li>它是抢占式的，如果长任务先到达，短任务后到达，短任务会抢占CPU先执行。</li>
</ul>
</li>
<li>优点：<ul>
<li>周转时间很好</li>
</ul>
</li>
<li>缺点：<ul>
<li>响应时间不好</li>
</ul>
</li>
</ul>
<h5 id="轮转"><a href="#轮转" class="headerlink" title="轮转"></a>轮转</h5><ul>
<li>轮转（Round-Robin，RR），又称作时间切片（time-slicing）：RR在一个时间片（time slice，有时称为调度量子，scheduling quantum）内工作，然后切换到运行队列的下一个任务，而不是运行一个任务直到结束。它反复运行，直到所有任务完成。</li>
</ul>
<p><img src="/2022/06/14/OS%E6%9C%9F%E6%9C%AB%E9%93%A7%E9%94%BA%E7%A2%98/image-20220614140940324.png" alt="image-20220614140940324" style="zoom:80%;"></p>
<ul>
<li>时间片长度影响性能：越短，响应时间越好；太短，频繁切换上下文影响整体性能。</li>
<li>特点：是一种公平调度算法</li>
<li>优点：<ul>
<li>响应时间好</li>
</ul>
</li>
<li>缺点：<ul>
<li>周转时间差</li>
</ul>
</li>
<li>进一步优化：重叠RR，考虑了IO，需要IO的任务让出CPU在完成前不参与调度。</li>
</ul>
<h5 id="多级反馈队列-MLFQ"><a href="#多级反馈队列-MLFQ" class="headerlink" title="多级反馈队列(MLFQ)"></a>多级反馈队列(MLFQ)</h5><ul>
<li><strong>规则</strong>：期中考过了，我觉得不会再考，但是仍然很重要。<ul>
<li>规则1：如果A的优先级&gt;B的优先级，运行A（不运行B）。</li>
<li>规则2：如果A的优先级=B的优先级，轮转运行A和B。</li>
<li>规则3：工作进入系统时，放在最高优先级（最上层队列）。</li>
<li>规则4：一旦工作用完了在某一层中的时间配额（无论中间主动放弃多少次CPU），就降低优先级（移入低一级队列）。</li>
<li>规则5：经过一段时间S，就将系统中所有工作重新加入最高优先级队列。</li>
</ul>
</li>
<li>特点：<ul>
<li>在没有任务长短的先验知识情况下，同时优化了周转时间和响应时间。</li>
<li>采用多级队列，每个队列代表一个优先级。</li>
</ul>
</li>
<li>优点：<ul>
<li>对于短时间运行的交互型工作，获得类似SJF/STCF的很好的全局性能（周转时间）。</li>
<li>同时对长时间运行的CPU密集型负载也可以公平地运行（响应时间）。</li>
</ul>
</li>
</ul>
<h5 id="彩票调度-Lottery"><a href="#彩票调度-Lottery" class="headerlink" title="彩票调度(Lottery)"></a>彩票调度(Lottery)</h5><ul>
<li>给每个进程分发⼀定量的彩票，每次调 度时随机抽出⼀个号码，被抽中的进程获得CPU。</li>
<li>彩票数（tickets）代表了进程占有某个资源地份额。一个进程拥有的彩票占总数地百分比，就是占有资源的份额。</li>
</ul>
<p><img src="/2022/06/14/OS%E6%9C%9F%E6%9C%AB%E9%93%A7%E9%94%BA%E7%A2%98/image-20220614142733606.png" alt="image-20220614142733606" style="zoom:80%;"></p>
<ul>
<li>特点：<ul>
<li>充分利用了随机性</li>
<li>从概率上满足期望的比例，但不能确保。运行时间越长，得到的CPU时间比例越接近期望。</li>
</ul>
</li>
<li>优点：<ul>
<li>可以避免奇怪的边角情况。</li>
<li>很轻量，几乎不需要记录任何状态</li>
<li>随机方法很快</li>
</ul>
</li>
<li>缺点：<ul>
<li>工作时间很短的时，平均不公平度很差。只有运行很多时间片时，才得到期望结果。</li>
</ul>
</li>
</ul>
<h5 id="步长调度算法-Stride"><a href="#步长调度算法-Stride" class="headerlink" title="步长调度算法(Stride)"></a>步长调度算法(Stride)</h5><ul>
<li>给每个进程分发⼀定量的彩票，用一个大数除以彩票得到步长，程序被调度⼀次则累计⼀次行程值（pass值 += 步长），每次调度行程值最小的进程。</li>
</ul>
<p><img src="/2022/06/14/OS%E6%9C%9F%E6%9C%AB%E9%93%A7%E9%94%BA%E7%A2%98/image-20220614144327579.png" alt="image-20220614144327579" style="zoom:80%;"></p>
<ul>
<li>优点：在给定优先级的情况下，达到绝对公平，比彩票调度优化了确定性。</li>
<li>缺点：需要一个全局状态(pass值)</li>
</ul>
<h4 id="为什么MLFQ可用，彩票步长不用"><a href="#为什么MLFQ可用，彩票步长不用" class="headerlink" title="为什么MLFQ可用，彩票步长不用"></a>为什么MLFQ可用，彩票步长不用</h4><ul>
<li><p>MLFQ可用的原因就是它的优点：</p>
<ul>
<li>对于短时间运行的交互型工作，获得类似SJF/STCF的很好的全局性能（周转时间）。</li>
<li>同时对长时间运行的CPU密集型负载也可以公平地运行。</li>
</ul>
</li>
<li><p>彩票步长不广泛使用的原因：</p>
<ul>
<li>一个原因是这两种方式都不能很好地适合I/O；</li>
<li>另一个原因是其中最难的票数分配问题并没有确定的解决方式。</li>
</ul>
</li>
</ul>
<h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><blockquote>
<ul>
<li>虚拟内存空间是什么？</li>
<li>为什么需要虚拟内存空间而不是直接使用物理内存空间？</li>
<li>使用虚拟内存空间的目标或者说是指标是什么？</li>
</ul>
</blockquote>
<h4 id="什么时虚拟内存空间？"><a href="#什么时虚拟内存空间？" class="headerlink" title="什么时虚拟内存空间？"></a>什么时虚拟内存空间？</h4><p>虚拟内存是计算机系统<strong>内存管理的一种技术</strong>。它负责为程序提供一 个巨大的、稀疏的、私有的地址空间的假象，其中保存了程序的所有指令和数据。而实际上，它通常是被分隔成多个物理内存片段，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。</p>
<h4 id="为什么需要虚拟内存空间？"><a href="#为什么需要虚拟内存空间？" class="headerlink" title="为什么需要虚拟内存空间？"></a>为什么需要虚拟内存空间？</h4><p>主要是虚拟内存提供了三个主要的好处：易于使用，高性能，可靠。</p>
<ul>
<li>虚拟内存可以为进程提供独立的内存空间并引入多层的页表结构将虚拟内存翻译成物理内存，进程之间可以共享物理内存减少开销，也能简化程序的链接、装载以及内存分配过程；</li>
<li>虚拟内存可以结合磁盘和物理内存的优势为进程提供看起来速度足够快并且容量足够大的存储；</li>
<li>虚拟内存可以控制进程对物理内存的访问，隔离不同进程的访问权限，提高系统的安全性；</li>
</ul>
<h4 id="虚拟内存的目标（指标）"><a href="#虚拟内存的目标（指标）" class="headerlink" title="虚拟内存的目标（指标）"></a>虚拟内存的目标（指标）</h4><p><img src="/2022/06/14/OS%E6%9C%9F%E6%9C%AB%E9%93%A7%E9%94%BA%E7%A2%98/image-20220615010114930.png" alt="image-20220615010114930" style="zoom:80%;"></p>
<p><img src="/2022/06/14/OS%E6%9C%9F%E6%9C%AB%E9%93%A7%E9%94%BA%E7%A2%98/image-20220615010135694.png" alt="image-20220615010135694" style="zoom:80%;"></p>
<h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><blockquote>
<ul>
<li>什么是并发？并发的概念是什么？</li>
<li>竞态条件、临界区等概念</li>
</ul>
</blockquote>
<h4 id="什么是并发"><a href="#什么是并发" class="headerlink" title="什么是并发"></a>什么是并发</h4><p><strong>并发</strong>当有多个线程在操作时,如果系统只有一个CPU,则它不可能真正同时进行一个以上的线程，它只能把CPU运行时间划分成若干个时间段,再将时间段分配给各个线程执行，在一个时间段的线程代码运行时，其它线程处于挂起状。这种方式我们称之为并发。</p>
<h4 id="什么是临界区、竞态条件等"><a href="#什么是临界区、竞态条件等" class="headerlink" title="什么是临界区、竞态条件等"></a>什么是临界区、竞态条件等</h4><p><img src="/2022/06/14/OS%E6%9C%9F%E6%9C%AB%E9%93%A7%E9%94%BA%E7%A2%98/image-20220614155546936.png" alt="image-20220614155546936" style="zoom:80%;"></p>
<h3 id="持久"><a href="#持久" class="headerlink" title="持久"></a>持久</h3><blockquote>
<p>明确为：崩溃一致性</p>
<ul>
<li>什么是崩溃一致性</li>
<li>崩溃一致性存在什么例子</li>
</ul>
</blockquote>
<h4 id="什么是崩溃一致性问题"><a href="#什么是崩溃一致性问题" class="headerlink" title="什么是崩溃一致性问题"></a>什么是崩溃一致性问题</h4><p>文件系统如何在出现断电（power loss）或系统崩溃（system  crash）的情况下，更新持久数据结构。这称为崩溃一致性问题。</p>
<h4 id="存在什么例子"><a href="#存在什么例子" class="headerlink" title="存在什么例子"></a>存在什么例子</h4><ul>
<li><strong>课本42.1</strong></li>
</ul>
<p>简单描述就是：</p>
<p><img src="/2022/06/14/OS%E6%9C%9F%E6%9C%AB%E9%93%A7%E9%94%BA%E7%A2%98/image-20220615161654399.png" alt="image-20220615161654399"></p>
<p>考虑一种情况是将单个数据块附加到原有文件末尾。则这个过程文件需要更新的有：数据位图增加一个表示数据块有效的位；更新<code>inode</code>中的数据块指针等；更新数据块Db。</p>
<p>现在我们考虑6种不一致现象：</p>
<ul>
<li><strong>只更新了数据块。</strong>此时，该文件的<code>inode</code>中没有指向Db的指针。Db的写入相当于无效。</li>
<li><strong>只更新了<code>inode</code>。</strong>此时，数据块没有更新，导致读取这个块返回给用户垃圾数据。同时出现文件系统不一致，数据位图告诉我们Db这个块未分配，但是<code>inode</code>认为它分配了。</li>
<li><strong>只更新了数据位图。</strong>此时，同样出现文件系统不一致，数据位图认为Db这个块分配了，但是<code>inode</code>没有指向它。如果不解决，会造成空间泄露。</li>
<li><strong>只更新了<code>inode</code>和数据位图。</strong>此时文件系统的元数据是一致的。但是数据没有更新，造成了垃圾数据。</li>
<li><strong>只更新了<code>inode</code>和数据块。</strong><code>inode</code>能够指向正确的数据块。但是又出现了文件系统给元数据不一致（<code>inode</code>和位图）。</li>
<li><strong>只更新了数据位图和数据块。</strong><code>inode</code>和位图的不一致性问题。没有<code>inode</code>指向这个块。</li>
</ul>
<h2 id="五个计算题加分析题"><a href="#五个计算题加分析题" class="headerlink" title="五个计算题加分析题"></a>五个计算题加分析题</h2><p>共计80分，其中由于计科期中考试进程考的比较多，进程部分的分值会少一点</p>
<p>五个答题主要是1+2+1+1：进程一个，虚拟内存两个，并发一个，文件部分一个</p>
<h3 id="进程x1"><a href="#进程x1" class="headerlink" title="进程x1"></a>进程x1</h3><p>没给提示。有可能是fork和exec相关的。</p>
<ul>
<li>（12 分）描述进程与线程以及它们之间的区别和联系。分析给出下图代码（图 5-1）在控 制台可能输出的信息；代码（图 5-2）可能会创建多少个进程，多少个线程。（答案5，2）</li>
</ul>
<p><img src="/2022/06/14/OS%E6%9C%9F%E6%9C%AB%E9%93%A7%E9%94%BA%E7%A2%98/image-20220615163218702.png" alt="image-20220615163218702" style="zoom:80%;"></p>
<p><img src="/2022/06/14/OS%E6%9C%9F%E6%9C%AB%E9%93%A7%E9%94%BA%E7%A2%98/image-20220615163231423.png" alt="image-20220615163231423"></p>
<p><img src="/2022/06/14/OS%E6%9C%9F%E6%9C%AB%E9%93%A7%E9%94%BA%E7%A2%98/ML4YT3TK5Z~_Y1D9DP`M4FP.png" alt="img"></p>
<h3 id="虚拟内存x2"><a href="#虚拟内存x2" class="headerlink" title="虚拟内存x2"></a>虚拟内存x2</h3><p>有两个题，由于现代操作系统普遍使用分页管理机制，而不是分段管理机制，所以着重在分页上（自己体会这句话）。而且他不怎么说分段，所以肯定考分页。</p>
<blockquote>
<ul>
<li>首先要搞懂最简单的线性页表，它有什么缺陷？</li>
<li>页表使得访存需要增加额外的访问页表的成本，所以很慢。为此有了TLB加速缓存。TLB是怎么工作的。</li>
<li>线性页表（一级）存储太大，所以有了多级页表。搞清楚怎么做的特别是二级三级页表。（我觉得是三级页表，老师提到了两三次）</li>
<li>在页表中除了物理页号，还有一些其他的属性位，都有些什么，它们代表什么含义？（例如有效位、存在位等）</li>
<li>通过上面的页表机制，给定一个虚拟地址，怎么计算它的物理地址？</li>
<li>超越物理内存（置换策略）</li>
</ul>
</blockquote>
<ul>
<li><p>线性页表（linear page table），就是一个数组。操作系统通过虚拟页号（VPN）检索该数组，并在该索引处查找页表项（PTE），以便找到期望的物理帧号（PFN）。</p>
</li>
<li><p>线性页表存在的问题就是太慢和太大</p>
<ul>
<li>对应的解决办法就是TLB和分级页表</li>
</ul>
</li>
<li><p>TLB和多级页表很重要，但是请见书本。</p>
</li>
<li><p>一些属性位：</p>
<p><img src="/2022/06/14/OS%E6%9C%9F%E6%9C%AB%E9%93%A7%E9%94%BA%E7%A2%98/image-20220614162257586.png" alt="image-20220614162257586" style="zoom:80%;"></p>
<p>上图包含一个存在位（P），确定是否允 许写入该页面的读/写位（R/W） 确定用户模式进程是否可以访问该页面的用户/超级用户位 （U/S），有几位（PWT、PCD、PAT 和 G）确定硬件缓存如何为这些页面工作，一个访问位 （A）和一个脏位（D），最后是页帧号（PFN）本身。</p>
<ul>
<li>有效位(V)：用于指定特定的地址转换是否有效</li>
<li>保护位(R/W)：表明页是否可以读取、写入或执行</li>
<li>存在位(P)：表示该页是在物理存储器上还是在磁盘交换区上</li>
<li>参考位(A)：又称访问位，用于追踪页是否被访问，也用于确定哪些页很受欢迎，应该保留在内存中。</li>
<li>脏位(D)：标示该页是否被写过</li>
</ul>
</li>
<li><p>怎么用页表进行地址转换请看书</p>
<ul>
<li>不难，就是查表</li>
<li>需要注意，物理页（帧）号拼上页偏移才是物理地址。</li>
</ul>
</li>
<li><p>超越物理内存（置换策略）</p>
<ul>
<li><p>平均内存访问时间（Average  Memory Access Time，AMAT）</p>
<script type="math/tex; mode=display">
AMAT = (P_{Hit}·T_M) + (P_{Miss}·T_D)</script></li>
<li><p>最优策略是MIN（无法实现，作为策略追求的性能上界）</p>
</li>
<li><p>简单策略FIFO</p>
<p><img src="/2022/06/14/OS%E6%9C%9F%E6%9C%AB%E9%93%A7%E9%94%BA%E7%A2%98/image-20220614163007021.png" alt="image-20220614163007021" style="zoom: 80%;"></p>
</li>
<li><p>随机策略</p>
<p><img src="/2022/06/14/OS%E6%9C%9F%E6%9C%AB%E9%93%A7%E9%94%BA%E7%A2%98/image-20220614163049148.png" alt="image-20220614163049148" style="zoom: 80%;"></p>
</li>
<li><p>最近最少使用（Least-Recently-Used，LRU）</p>
<p><img src="/2022/06/14/OS%E6%9C%9F%E6%9C%AB%E9%93%A7%E9%94%BA%E7%A2%98/image-20220614163141209.png" alt="image-20220614163141209" style="zoom: 80%;"></p>
</li>
<li><p>最不经常使用”（Least-Frequently-Used， LFU）（历史信息中使用频次最低的）</p>
</li>
</ul>
</li>
<li><p><img src="/2022/06/14/OS%E6%9C%9F%E6%9C%AB%E9%93%A7%E9%94%BA%E7%A2%98/image-20220615021516526.png" alt="image-20220615021516526"></p>
<ul>
<li>基本思想：<ul>
<li>分段是指将虚拟地址空间中代码、堆、栈等段分别映射到物理内存，而不是将整 个虚拟地址空间全部映射到物理内存。</li>
<li>分页是将虚拟地址空间等分为固定大小的页 （如 4KB），以页的方式将虚拟地址空间与物理内存进行映射。</li>
</ul>
</li>
<li>地址转换过程：<ul>
<li>分段主要是把不同的段，借助两个寄存器（基址寄存器和界限寄存器），其中物理地址等同于基址寄存器中存储的段机制加上段内偏移。界限寄存器主要实现了段的保护功能。</li>
<li>页的地址转换是将虚拟地址分成虚拟页号部分和页偏移部分。虚拟页号通过页表存储的物理帧号实现虚拟页号到物理页号的映射。由于偏移不变，所以把得到的物理页号拼上偏移就是物理地址。</li>
</ul>
</li>
<li>优缺点：<ul>
<li>分段的优点是硬件支 持比较简单；缺点是可能会导致外部碎片、空闲空间的管理比较复杂。</li>
<li>分页的优点是 空间管理简单、没有外部碎片，缺点是页表存储空间大、地址翻译慢（需要 TLB 加 速），因此需要硬件的支持较多。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="并发x1"><a href="#并发x1" class="headerlink" title="并发x1"></a>并发x1</h3><p>由于并发的计算分析大题只考一个，而且老师又提示说会考一提编程相关的代码题，要会用函数，会用接口。肯定就是这题。</p>
<blockquote>
<p>用信号量解决理发师问题。如果有余力也可以看看信号量解决吸烟者问题。我觉得就是理发师</p>
</blockquote>
<p>类似这个历年真题。把打印员换成理发师，就是经典的理发师问题。</p>
<p><img src="C:/Users/18319/AppData/Roaming/Typora/typora-user-images/image-20220615151151214.png" alt="image-20220615151151214"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NUM_CHAIR 5					<span class="comment">// 最大等待椅子数目</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUM_CUST  10				<span class="comment">// 顾客数量</span></span></span><br><span class="line"><span class="type">sem_t</span> customers;         			<span class="comment">// 表示有顾客的条件变量</span></span><br><span class="line"><span class="type">sem_t</span> barber;    	     			<span class="comment">// 表示理发师醒了的条件变量</span></span><br><span class="line"><span class="type">sem_t</span> mutex;              			<span class="comment">// 空闲椅子数是共享资源，需要互斥量</span></span><br><span class="line"><span class="type">int</span> freechairs;      				<span class="comment">// 空椅子的数量</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> * <span class="title function_">Barber</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (ture) &#123;	     			<span class="comment">// 理发师持续不断工作或者睡眠</span></span><br><span class="line">        sem_wait(&amp;customers);		<span class="comment">// 试图为一个顾客理发，如果没有顾客就睡着</span></span><br><span class="line">        sem_wait(&amp;mutex);			<span class="comment">// 需要修改空椅子的数量(全局变量)，需要上锁</span></span><br><span class="line">        freechair++;			    <span class="comment">// 为一个顾客理发，顾客起身，空一张椅子出来</span></span><br><span class="line">        sem_post(&amp;barber);			<span class="comment">// 此时理发师可以工作，通知顾客过来理发</span></span><br><span class="line">        sem_post(&amp;mutex);			<span class="comment">// 修改完空椅子数目，释放锁</span></span><br><span class="line">        <span class="comment">/* 理发师在理发... */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> * <span class="title function_">Customers</span><span class="params">()</span> &#123; 	 			<span class="comment">// 一个线程仅仅表示一名顾客</span></span><br><span class="line">    sem_wait(&amp;mutex);    		 	<span class="comment">// 想要坐到一张椅子上等待</span></span><br><span class="line">    <span class="keyword">if</span> (freechairs &gt; <span class="number">0</span>) &#123;			<span class="comment">// 如果还有空椅子的话</span></span><br><span class="line">        freechairs--;				<span class="comment">// 顾客坐到一张椅子上等待</span></span><br><span class="line">        sem_post(&amp;customers);		<span class="comment">// 唤醒理发师，有顾客来了</span></span><br><span class="line">        sem_post(&amp;mutex);			<span class="comment">// 顾客已经坐到椅子上等待，释放互斥量</span></span><br><span class="line">        sem_wait(&amp;barber);			<span class="comment">// 如果理发师还在忙，就等他</span></span><br><span class="line">        <span class="comment">/* 抢到理发师，此时顾客开始理发 */</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;							<span class="comment">// 没有空着的椅子 </span></span><br><span class="line">        sem_post(&amp;mutex);			<span class="comment">// 不要忘记试图坐下上的锁(第20行)</span></span><br><span class="line">        <span class="comment">/* 没有椅子坐，直接走了 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">/* 初始化 */</span></span><br><span class="line">    sem_init(&amp;customers, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    sem_init(&amp;barbers, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    sem_init(&amp;mutex, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    freechairs = NUM_CHAIR;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 启动理发师和顾客 */</span></span><br><span class="line">    <span class="type">pthread_t</span> bar, cust[NUM_CUST];</span><br><span class="line">    Pthread_create(&amp;bar, <span class="literal">NULL</span>, Barber, <span class="literal">NULL</span>);	  	</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_CUST; i++) &#123;</span><br><span class="line">        Pthread_create(&amp;cust[i], <span class="literal">NULL</span>, Customers, <span class="literal">NULL</span>);</span><br><span class="line">        sleep(randint(<span class="literal">NULL</span>));	  <span class="comment">// 每隔一个随机时间来一个顾客</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="补充之吸烟者问题"><a href="#补充之吸烟者问题" class="headerlink" title="补充之吸烟者问题"></a>补充之吸烟者问题</h4><p>这里只用到了信号量，因为座子上的资源只够一个人吸烟，不会有共享</p>
<p><img src="/2022/06/14/OS%E6%9C%9F%E6%9C%AB%E9%93%A7%E9%94%BA%E7%A2%98/cf90bb5e99024c04b9cdab2779822591.jpg" alt="在这里插入图片描述"></p>
<p><img src="/2022/06/14/OS%E6%9C%9F%E6%9C%AB%E9%93%A7%E9%94%BA%E7%A2%98/71681ce2b6b14269a5d98021c97ee207.jpg" alt="在这里插入图片描述"></p>
<p><img src="/2022/06/14/OS%E6%9C%9F%E6%9C%AB%E9%93%A7%E9%94%BA%E7%A2%98/b41906fd38354d9db406f11b5fdb6635.jpg" alt="在这里插入图片描述"></p>
<h3 id="文件x1"><a href="#文件x1" class="headerlink" title="文件x1"></a>文件x1</h3><blockquote>
<ul>
<li>存储管理<ul>
<li>磁盘结构是什么样的？旋转寻道传输以及这方面的知识以及有关的时间是怎么算的？</li>
<li>RAID（0/1/4/5）各自有什么特点和优缺点，稳态吞吐量怎么算的</li>
</ul>
</li>
<li>文件系统<ul>
<li>数据进行读写，要经历什么样的步骤</li>
<li>元数据的成员有哪些：修改时间、…、直接指针、间接指针<ul>
<li>放在一个应用场景中让你进行设计（大概率是设计分配直接指针和间接指针[二级、三级]）</li>
<li>对应消耗多少空间，对应的数据块又有多大？</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="磁盘结构"><a href="#磁盘结构" class="headerlink" title="磁盘结构"></a>磁盘结构</h4><p><img src="/2022/06/14/OS%E6%9C%9F%E6%9C%AB%E9%93%A7%E9%94%BA%E7%A2%98/image-20220614164632169.png" alt="image-20220614164632169" style="zoom: 80%;"></p>
<script type="math/tex; mode=display">
T_{I/O} = T_{寻道} + T_{旋转} + T_{传输}</script><script type="math/tex; mode=display">
R_{I/O} = \frac{传输大小}{T_{I/O}}</script><p><img src="/2022/06/14/OS%E6%9C%9F%E6%9C%AB%E9%93%A7%E9%94%BA%E7%A2%98/image-20220615015619442.png" alt="image-20220615015619442" style="zoom:80%;"></p>
<h4 id="各种时间怎么算"><a href="#各种时间怎么算" class="headerlink" title="各种时间怎么算"></a>各种时间怎么算</h4><p>有两个真题,可以理解一下</p>
<ul>
<li>真题1</li>
</ul>
<p><img src="/2022/06/14/OS%E6%9C%9F%E6%9C%AB%E9%93%A7%E9%94%BA%E7%A2%98/image-20220615171059400.png" alt="image-20220615171059400"></p>
<p><img src="/2022/06/14/OS%E6%9C%9F%E6%9C%AB%E9%93%A7%E9%94%BA%E7%A2%98/image-20220615171145581.png" alt="image-20220615171145581"></p>
<ul>
<li>真题2:</li>
</ul>
<p><img src="/2022/06/14/OS%E6%9C%9F%E6%9C%AB%E9%93%A7%E9%94%BA%E7%A2%98/image-20220615171003028.png" alt="image-20220615171003028"></p>
<p><img src="/2022/06/14/OS%E6%9C%9F%E6%9C%AB%E9%93%A7%E9%94%BA%E7%A2%98/image-20220615170926641.png" alt="image-20220615170926641"></p>
<h4 id="RAID各级的优缺点以及特点"><a href="#RAID各级的优缺点以及特点" class="headerlink" title="RAID各级的优缺点以及特点"></a>RAID各级的优缺点以及特点</h4><ul>
<li><p><strong>【RAID 0——RAID中速度最快】</strong></p>
<p><strong>原理：</strong>采用数据条带技术（Striping），将数据分成“块”保存在不同磁盘上，读写时以并行的方式对各磁盘同时进行操作。</p>
<p><strong>优点：</strong>组建低成本，且具有传输速度快、存储空间利用率高等优点；</p>
<p><strong>缺点：</strong>不提供数据冗余保护，任何一块硬盘发生损坏，则所有的数据将不可恢复；</p>
</li>
<li><p><strong>【RAID 1——RAID中安全性最高】</strong></p>
<p><strong>原理：</strong>俗称“磁盘镜像”，将数据完全一致地分别写到工作磁盘和镜像磁盘，一旦工作磁盘发生故障，系统自动从镜像磁盘读取数据，不会影响用户工作。</p>
<p><strong>优点：</strong>磁盘数据呈现完全镜像，具有安全性好、技术简单、管理方便等优点；</p>
<p><strong>缺点：</strong>实现成本高，磁盘空间利用率仅 50%；</p>
</li>
<li><p><strong>【RAID 4——条带分布+专用盘校验】</strong></p>
<p><strong>原理：</strong>其中一块硬盘上存储校验数据，当某块硬盘出现故障时，其它硬盘可以通过校验数据将有故障的硬盘的数据重新恢复出来。</p>
<p><strong>优点：</strong>1、磁盘利用率较高(N-1)；2、并行I/O传输，顺序读性能较高</p>
<p><strong>缺点：</strong>1、专用校验盘成为性能瓶颈；2、每次读写牵动整个组，每次只能完成一次I/O 传输</p>
</li>
<li><p><strong>【RAID 5——RAID中综合性能最佳】</strong></p>
<p><strong>原理：</strong>采用校验码冗余数据，校验块旋转地分布在多个磁盘上，当某个磁盘出现故障，可以使用其他磁盘上校验信息来恢复数据。</p>
<p><strong>优点：</strong>兼顾存储性能、数据安全和存储成本等；</p>
<p><strong>缺点：</strong>1、写入性能相对低；2、重建数据时，性能会受到较大的影响；</p>
</li>
</ul>
<h4 id="文件系统相关"><a href="#文件系统相关" class="headerlink" title="文件系统相关"></a>文件系统相关</h4><ul>
<li>真题:</li>
</ul>
<p>文件系统的实现需要考虑元数据（metadata）的处理，请回答跟元数据相关的下列问题：</p>
<p>（1）文件系统中的<code>inode</code>的作用是什么？<code>inode</code>中一般包含哪些信息？（4分）</p>
<p>（2）为了描述文件的大小，需要在元数据中给定指向数据的指针，指针一般分为直接指针（direct pointer）和间接指针（indirect pointer），假设数据块的大小为4KB，每个指针占用4字节的空间，那么10个直接指针和1个一级间接指针可以寻址的文件大小是多少？1个二级间接指针可以寻址的文件大小是多少？请给出分析和计算过程。（8分）</p>
<p><img src="/2022/06/14/OS%E6%9C%9F%E6%9C%AB%E9%93%A7%E9%94%BA%E7%A2%98/image-20220615145705046.png" alt="image-20220615145705046" style="zoom:80%;"></p>
<ul>
<li><p>直接指针间接指针的好坏(来不及了…略)</p>
<ul>
<li>主要就是直接指针数目多,索引快,但是指向的数据块小</li>
<li>间接指针需要额外的索引时间,但是数目少,指向的块的总大小很大</li>
</ul>
<p><img src="/2022/06/14/OS%E6%9C%9F%E6%9C%AB%E9%93%A7%E9%94%BA%E7%A2%98/image-20220615175410707.png" alt="image-20220615175410707" style="zoom:80%;"></p>
</li>
</ul>
<h4 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h4><p>日志记一下这五点吧,估计最多考这样</p>
<p><img src="/2022/06/14/OS%E6%9C%9F%E6%9C%AB%E9%93%A7%E9%94%BA%E7%A2%98/image-20220615175448501.png" alt="image-20220615175448501"></p>
]]></content>
      <categories>
        <category>courses-learning</category>
        <category>大二下期末</category>
      </categories>
      <tags>
        <tag>os</tag>
        <tag>期末总复习</tag>
      </tags>
  </entry>
  <entry>
    <title>OS-thread-homework</title>
    <url>/2022/05/19/OS-thread-homework/</url>
    <content><![CDATA[<h1 id="操作系统第三部分作业"><a href="#操作系统第三部分作业" class="headerlink" title="操作系统第三部分作业"></a>操作系统第三部分作业</h1><h2 id="作业范围"><a href="#作业范围" class="headerlink" title="作业范围"></a>作业范围</h2><ul>
<li>第26章1、2、3、4题</li>
<li>第28章1、2、3、4、5、6、7题</li>
<li>第30章1、2、4、8、9、10、11题</li>
<li>第31章1、2、4、5、6题</li>
</ul>
<h2 id="第26章"><a href="#第26章" class="headerlink" title="第26章"></a>第26章</h2><h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3><p>首先查看这个程序，得到结果如下</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sh&gt; <span class="built_in">cat</span> loop.s</span><br><span class="line"><span class="comment"># 段符号</span></span><br><span class="line">.main</span><br><span class="line">.top</span><br><span class="line"><span class="comment"># 重点看下面这4句</span></span><br><span class="line">sub  <span class="variable">$1</span>,%dx		<span class="comment"># %dx = %dx - 1</span></span><br><span class="line"><span class="built_in">test</span> <span class="variable">$0</span>,%dx		<span class="comment"># %dx &amp; $0 不改变%dx的值，仅仅改变标志位</span></span><br><span class="line">jgte .top		<span class="comment"># 表示如果大于等于就跳到.top</span></span><br><span class="line">halt			<span class="comment"># 停机</span></span><br></pre></td></tr></table></figure>
<p>现在我们理解了<code>loop.s</code>句子的含义。现在我们看看题目，假设dx的初始值是0，很快就可以计算出每个指令执行的时候dx的值。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ ./x86.py -p loop.s -t 1 -i 100 -R dx</span><br><span class="line">...</span><br><span class="line">   dx          Thread 0</span><br><span class="line">    0</span><br><span class="line">   -1   1000 sub  <span class="variable">$1</span>,%dx</span><br><span class="line">   -1   1001 <span class="built_in">test</span> <span class="variable">$0</span>,%dx</span><br><span class="line">   -1   1002 jgte .top</span><br><span class="line">   -1   1003 halt</span><br></pre></td></tr></table></figure>
<p>dx作为循环变量判断是否跳出循环，上述语句可以写成c语言的语句如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = n;</span><br><span class="line"><span class="keyword">while</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">	i--;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以它的价值就在于循环递减变量以及循环变量判断是否跳出循环。</p>
<h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h3><p>现在运行相同的代码，但是使用如下标志，但是设定了寄存器的初始值如<code>-a</code>后面所赋值。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ ./x86.py -p loop.s -t 2 -i 100 -a dx=3,dx=3 -R dx</span><br><span class="line">...</span><br><span class="line">   dx          Thread 0                Thread 1</span><br><span class="line">    3</span><br><span class="line">    2   1000 sub  <span class="variable">$1</span>,%dx</span><br><span class="line">    2   1001 <span class="built_in">test</span> <span class="variable">$0</span>,%dx</span><br><span class="line">    2   1002 jgte .top</span><br><span class="line">    1   1000 sub  <span class="variable">$1</span>,%dx</span><br><span class="line">    1   1001 <span class="built_in">test</span> <span class="variable">$0</span>,%dx</span><br><span class="line">    1   1002 jgte .top</span><br><span class="line">    0   1000 sub  <span class="variable">$1</span>,%dx</span><br><span class="line">    0   1001 <span class="built_in">test</span> <span class="variable">$0</span>,%dx</span><br><span class="line">    0   1002 jgte .top</span><br><span class="line">   -1   1000 sub  <span class="variable">$1</span>,%dx</span><br><span class="line">   -1   1001 <span class="built_in">test</span> <span class="variable">$0</span>,%dx</span><br><span class="line">   -1   1002 jgte .top</span><br><span class="line">   -1   1003 halt</span><br><span class="line">    3   ----- Halt;Switch -----  ----- Halt;Switch -----</span><br><span class="line">    2                            1000 sub  <span class="variable">$1</span>,%dx</span><br><span class="line">    2                            1001 <span class="built_in">test</span> <span class="variable">$0</span>,%dx</span><br><span class="line">    2                            1002 jgte .top</span><br><span class="line">    1                            1000 sub  <span class="variable">$1</span>,%dx</span><br><span class="line">    1                            1001 <span class="built_in">test</span> <span class="variable">$0</span>,%dx</span><br><span class="line">    1                            1002 jgte .top</span><br><span class="line">    0                            1000 sub  <span class="variable">$1</span>,%dx</span><br><span class="line">    0                            1001 <span class="built_in">test</span> <span class="variable">$0</span>,%dx</span><br><span class="line">    0                            1002 jgte .top</span><br><span class="line">   -1                            1000 sub  <span class="variable">$1</span>,%dx</span><br><span class="line">   -1                            1001 <span class="built_in">test</span> <span class="variable">$0</span>,%dx</span><br><span class="line">   -1                            1002 jgte .top</span><br><span class="line">   -1                            1003 halt</span><br></pre></td></tr></table></figure>
<p>在这种情况下，多线程不会影响结果的运行，因为两个线程执行的时候不是共享同一个<code>edx</code>的。这种情况下，两个线程只使用自己的dx的值，dx在每个线程从3到-1。并且在中断前halt跳出循环。</p>
<p>至于这段代码是否有竞态条件？首先要弄清楚什么叫竞态条件等两个基本概念。</p>
<blockquote>
<ul>
<li>临界区：访问共享资源的一段代码，资源通常是一个变量或数据结构。</li>
<li>竞态条件：出现在多个执行线程同时进入临界区时，他们都试图更新共享的数据结构导致了不确定结果</li>
</ul>
</blockquote>
<p>这一段<code>loop.s</code>中对共享资源更新的部分的代码就是<code>sub</code>指令这一条。因此因此我们可以看临界区就是这一段<code>loop.s</code>或者就是<code>sub</code>这一句。很明显从在这种情况下，线程每100条指令中断1次，而还没到100条指令就已经跳出循环了。这种情况下可以看出来，两段代码是没有竞态条件的。</p>
<h3 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h3><p>这一组测试使得中断间隔非常小而且随机，使用不同的种子<code>-s</code>查看不同的交替。中断频率是否会改变这个程序的行为。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ ./x86.py -p loop.s -t 2 -i 3 -r -a dx=3,dx=3 -R dx</span><br><span class="line">...</span><br><span class="line">   dx          Thread 0                Thread 1</span><br><span class="line">    3</span><br><span class="line">    2   1000 sub  <span class="variable">$1</span>,%dx</span><br><span class="line">    2   1001 <span class="built_in">test</span> <span class="variable">$0</span>,%dx</span><br><span class="line">    2   1002 jgte .top</span><br><span class="line">    3   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    2                            1000 sub  <span class="variable">$1</span>,%dx</span><br><span class="line">    2                            1001 <span class="built_in">test</span> <span class="variable">$0</span>,%dx</span><br><span class="line">    2                            1002 jgte .top</span><br><span class="line">    2   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    1   1000 sub  <span class="variable">$1</span>,%dx</span><br><span class="line">    1   1001 <span class="built_in">test</span> <span class="variable">$0</span>,%dx</span><br><span class="line">    2   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    1                            1000 sub  <span class="variable">$1</span>,%dx</span><br><span class="line">    1   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    1   1002 jgte .top</span><br><span class="line">    0   1000 sub  <span class="variable">$1</span>,%dx</span><br><span class="line">    1   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    1                            1001 <span class="built_in">test</span> <span class="variable">$0</span>,%dx</span><br><span class="line">    1                            1002 jgte .top</span><br><span class="line">    0   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    0   1001 <span class="built_in">test</span> <span class="variable">$0</span>,%dx</span><br><span class="line">    0   1002 jgte .top</span><br><span class="line">   -1   1000 sub  <span class="variable">$1</span>,%dx</span><br><span class="line">    1   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    0                            1000 sub  <span class="variable">$1</span>,%dx</span><br><span class="line">   -1   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">   -1   1001 <span class="built_in">test</span> <span class="variable">$0</span>,%dx</span><br><span class="line">   -1   1002 jgte .top</span><br><span class="line">    0   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    0                            1001 <span class="built_in">test</span> <span class="variable">$0</span>,%dx</span><br><span class="line">    0                            1002 jgte .top</span><br><span class="line">   -1   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">   -1   1003 halt</span><br><span class="line">    0   ----- Halt;Switch -----  ----- Halt;Switch -----</span><br><span class="line">   -1                            1000 sub  <span class="variable">$1</span>,%dx</span><br><span class="line">   -1                            1001 <span class="built_in">test</span> <span class="variable">$0</span>,%dx</span><br><span class="line">   -1   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">   -1                            1002 jgte .top</span><br><span class="line">   -1                            1003 halt</span><br></pre></td></tr></table></figure>
<p>再看看不同的随机种子下是什么样的结果。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ ./x86.py -p loop.s -t 2 -i 3 -r -a dx=3,dx=3 -R dx -c -s 1</span><br><span class="line">...</span><br><span class="line">   dx          Thread 0                Thread 1</span><br><span class="line">    3</span><br><span class="line">    2   1000 sub  <span class="variable">$1</span>,%dx</span><br><span class="line">    3   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    2                            1000 sub  <span class="variable">$1</span>,%dx</span><br><span class="line">    2                            1001 <span class="built_in">test</span> <span class="variable">$0</span>,%dx</span><br><span class="line">    2                            1002 jgte .top</span><br><span class="line">    2   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    2   1001 <span class="built_in">test</span> <span class="variable">$0</span>,%dx</span><br><span class="line">    2   1002 jgte .top</span><br><span class="line">    1   1000 sub  <span class="variable">$1</span>,%dx</span><br><span class="line">    2   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    1                            1000 sub  <span class="variable">$1</span>,%dx</span><br><span class="line">    1   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    1   1001 <span class="built_in">test</span> <span class="variable">$0</span>,%dx</span><br><span class="line">    1   1002 jgte .top</span><br><span class="line">    1   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    1                            1001 <span class="built_in">test</span> <span class="variable">$0</span>,%dx</span><br><span class="line">    1                            1002 jgte .top</span><br><span class="line">    1   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    0   1000 sub  <span class="variable">$1</span>,%dx</span><br><span class="line">    0   1001 <span class="built_in">test</span> <span class="variable">$0</span>,%dx</span><br><span class="line">    1   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    0                            1000 sub  <span class="variable">$1</span>,%dx</span><br><span class="line">    0                            1001 <span class="built_in">test</span> <span class="variable">$0</span>,%dx</span><br><span class="line">    0                            1002 jgte .top</span><br><span class="line">    0   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    0   1002 jgte .top</span><br><span class="line">    0   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">   -1                            1000 sub  <span class="variable">$1</span>,%dx</span><br><span class="line">    0   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">   -1   1000 sub  <span class="variable">$1</span>,%dx</span><br><span class="line">   -1   1001 <span class="built_in">test</span> <span class="variable">$0</span>,%dx</span><br><span class="line">   -1   1002 jgte .top</span><br><span class="line">   -1   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">   -1                            1001 <span class="built_in">test</span> <span class="variable">$0</span>,%dx</span><br><span class="line">   -1                            1002 jgte .top</span><br><span class="line">   -1   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">   -1   1003 halt</span><br><span class="line">   -1   ----- Halt;Switch -----  ----- Halt;Switch -----</span><br><span class="line">   -1                            1003 halt</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">./x86.py -p loop.s -t 2 -i 3 -r -a dx=3,dx=3 -R dx -c -s 2</span><br><span class="line">...</span><br><span class="line">   dx          Thread 0                Thread 1</span><br><span class="line">    3</span><br><span class="line">    2   1000 sub  <span class="variable">$1</span>,%dx</span><br><span class="line">    2   1001 <span class="built_in">test</span> <span class="variable">$0</span>,%dx</span><br><span class="line">    2   1002 jgte .top</span><br><span class="line">    3   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    2                            1000 sub  <span class="variable">$1</span>,%dx</span><br><span class="line">    2                            1001 <span class="built_in">test</span> <span class="variable">$0</span>,%dx</span><br><span class="line">    2                            1002 jgte .top</span><br><span class="line">    2   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    1   1000 sub  <span class="variable">$1</span>,%dx</span><br><span class="line">    2   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    1                            1000 sub  <span class="variable">$1</span>,%dx</span><br><span class="line">    1   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    1   1001 <span class="built_in">test</span> <span class="variable">$0</span>,%dx</span><br><span class="line">    1   1002 jgte .top</span><br><span class="line">    0   1000 sub  <span class="variable">$1</span>,%dx</span><br><span class="line">    1   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    1                            1001 <span class="built_in">test</span> <span class="variable">$0</span>,%dx</span><br><span class="line">    1                            1002 jgte .top</span><br><span class="line">    0                            1000 sub  <span class="variable">$1</span>,%dx</span><br><span class="line">    0   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    0   1001 <span class="built_in">test</span> <span class="variable">$0</span>,%dx</span><br><span class="line">    0   1002 jgte .top</span><br><span class="line">   -1   1000 sub  <span class="variable">$1</span>,%dx</span><br><span class="line">    0   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    0                            1001 <span class="built_in">test</span> <span class="variable">$0</span>,%dx</span><br><span class="line">   -1   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">   -1   1001 <span class="built_in">test</span> <span class="variable">$0</span>,%dx</span><br><span class="line">   -1   1002 jgte .top</span><br><span class="line">    0   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    0                            1002 jgte .top</span><br><span class="line">   -1                            1000 sub  <span class="variable">$1</span>,%dx</span><br><span class="line">   -1   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">   -1   1003 halt</span><br><span class="line">   -1   ----- Halt;Switch -----  ----- Halt;Switch -----</span><br><span class="line">   -1                            1001 <span class="built_in">test</span> <span class="variable">$0</span>,%dx</span><br><span class="line">   -1   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">   -1                            1002 jgte .top</span><br><span class="line">   -1   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">   -1                            1003 halt</span><br></pre></td></tr></table></figure>
<p>总体看来，两个线程仍然是执行了从3到-1的循环操作，但是由于中断具有随机性，因此也就不能够确定什么时候执行完毕。从工作执行总量上看没有发生改变，但就工作执行的先后以及连续性上，改变了行为。</p>
<h3 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h3><p>第四题是访问一个公共变量而不是寄存器，在前面3题中，每个线程都有自己的专属寄存器。在中断的时候，线程的寄存器会保存，在恢复中断恢复的时候寄存器的值会被恢复。因此在循环上不会被破坏。但是现在的公共资源是一个变量，这可能引起某些变化。具体见下面。</p>
<p>首先看看这个程序<code>looping-race-nolock.s</code>是什么意思</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cat looping-race-nolock.s</span><br><span class="line"># assumes %bx has loop count in it</span><br><span class="line"></span><br><span class="line">.main</span><br><span class="line">.top</span><br><span class="line"># critical section 临界区</span><br><span class="line">mov 2000, %ax  # get &#x27;value&#x27; at address 2000</span><br><span class="line">add $1, %ax    # increment it: ax += 1</span><br><span class="line">mov %ax, 2000  # store it back</span><br><span class="line"></span><br><span class="line"># see if we&#x27;re still looping</span><br><span class="line">sub  $1, %bx</span><br><span class="line">test $0, %bx</span><br><span class="line">jgt .top</span><br><span class="line"></span><br><span class="line">halt</span><br></pre></td></tr></table></figure>
<p>可以看出来bx是循环变量，要对ax进行加一操作，可以写出程序的c语言表达如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = n;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> *p;</span><br><span class="line"><span class="keyword">while</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    *p = x;</span><br><span class="line">    *p--;</span><br><span class="line">    i--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们再来看看下面这段执行情况。显然除了<code>mov %ax 2000</code>这个语句会更新2000地址的变量x的值，其余时刻都不会更新。因此结果如下。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ ./x86.py -p looping-race-nolock.s -t 1 -M 2000</span><br><span class="line">...</span><br><span class="line"> 2000          Thread 0</span><br><span class="line">    0</span><br><span class="line">    0   1000 mov 2000, %ax</span><br><span class="line">    0   1001 add <span class="variable">$1</span>, %ax</span><br><span class="line">    1   1002 mov %ax, 2000</span><br><span class="line">    1   1003 sub  <span class="variable">$1</span>, %bx</span><br><span class="line">    1   1004 <span class="built_in">test</span> <span class="variable">$0</span>, %bx</span><br><span class="line">    1   1005 jgt .top</span><br><span class="line">    1   1006 halt</span><br></pre></td></tr></table></figure>
<h2 id="第28章"><a href="#第28章" class="headerlink" title="第28章"></a>第28章</h2><p>这一章的习题同样是一个用python写的x86模拟器，它能够运行<code>.s</code>格式的文件。</p>
<p>在这里，我们有四个常用的寄存器ax、bx、cx、dx，还有一个程序计数器PC。还有足够小但是能够满足我们需求的汇编指令。我们也加了一些额外的寄存器，例如ex和fx，这不见得能够与x86是对应的。但是这并没有什么问题。</p>
<h3 id="1-1"><a href="#1-1" class="headerlink" title="1."></a>1.</h3><p>这题要我们用./x86运行<code>flag.s</code>文件。首先理解一下<code>flag.s</code>到底说了什么。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> flag.s</span><br><span class="line">.var flag</span><br><span class="line">.var count</span><br><span class="line"></span><br><span class="line">.main</span><br><span class="line">.top</span><br><span class="line"></span><br><span class="line">.acquire</span><br><span class="line">mov  flag, %ax      <span class="comment"># get flag</span></span><br><span class="line"><span class="built_in">test</span> <span class="variable">$0</span>, %ax        <span class="comment"># if we get 0 back: lock is free!</span></span><br><span class="line">jne  .acquire       <span class="comment"># if not, try again</span></span><br><span class="line">mov  <span class="variable">$1</span>, flag       <span class="comment"># store 1 into flag</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># critical section</span></span><br><span class="line">mov  count, %ax     <span class="comment"># get the value at the address</span></span><br><span class="line">add  <span class="variable">$1</span>, %ax        <span class="comment"># increment it</span></span><br><span class="line">mov  %ax, count     <span class="comment"># store it back</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># release lock</span></span><br><span class="line">mov  <span class="variable">$0</span>, flag       <span class="comment"># clear the flag now</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># see if we&#x27;re still looping</span></span><br><span class="line">sub  <span class="variable">$1</span>, %bx</span><br><span class="line"><span class="built_in">test</span> <span class="variable">$0</span>, %bx</span><br><span class="line">jgt .top</span><br><span class="line"></span><br><span class="line">halt</span><br></pre></td></tr></table></figure>
<p>上面这部分汇编代码其实很好理解，根据上面的注释，我们可以写出c语言版本</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> <span class="type">mutex_t</span>;</span><br><span class="line"><span class="type">mutex_t</span> flag = <span class="number">0x0</span>;</span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> i = n;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">mian</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">/* 上锁 */</span></span><br><span class="line">        <span class="keyword">while</span> (flag != <span class="number">0x0</span>)</span><br><span class="line">            ; <span class="comment">// 自选等待锁空闲</span></span><br><span class="line">        <span class="comment">/* lock */</span></span><br><span class="line">        flag = <span class="number">0x1</span>;</span><br><span class="line">        <span class="comment">/* 临界区代码 */</span></span><br><span class="line">        count++;</span><br><span class="line">        <span class="comment">/* unlock */</span></span><br><span class="line">        flag = <span class="number">0x0</span>;</span><br><span class="line">        <span class="comment">/* 判断是否继续循环 */</span></span><br><span class="line">        i--;	</span><br><span class="line">    &#125; <span class="keyword">while</span> (i &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="comment">/* halt */</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以<code>flag.s</code>的功能就是在循环变量被减到0之前不断申请上锁，然后对公共资源count++，然后释放锁的过程。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$./x86.py -p flag.s</span><br><span class="line">...</span><br><span class="line">       Thread 0                Thread 1</span><br><span class="line"></span><br><span class="line">1000 mov  flag, %ax</span><br><span class="line">1001 <span class="built_in">test</span> <span class="variable">$0</span>, %ax</span><br><span class="line">1002 jne  .acquire</span><br><span class="line">1003 mov  <span class="variable">$1</span>, flag</span><br><span class="line">1004 mov  count, %ax</span><br><span class="line">1005 add  <span class="variable">$1</span>, %ax</span><br><span class="line">1006 mov  %ax, count</span><br><span class="line">1007 mov  <span class="variable">$0</span>, flag</span><br><span class="line">1008 sub  <span class="variable">$1</span>, %bx</span><br><span class="line">1009 <span class="built_in">test</span> <span class="variable">$0</span>, %bx</span><br><span class="line">1010 jgt .top</span><br><span class="line">1011 halt</span><br><span class="line">----- Halt;Switch -----  ----- Halt;Switch -----</span><br><span class="line">                         1000 mov  flag, %ax</span><br><span class="line">                         1001 <span class="built_in">test</span> <span class="variable">$0</span>, %ax</span><br><span class="line">                         1002 jne  .acquire</span><br><span class="line">                         1003 mov  <span class="variable">$1</span>, flag</span><br><span class="line">                         1004 mov  count, %ax</span><br><span class="line">                         1005 add  <span class="variable">$1</span>, %ax</span><br><span class="line">                         1006 mov  %ax, count</span><br><span class="line">                         1007 mov  <span class="variable">$0</span>, flag</span><br><span class="line">                         1008 sub  <span class="variable">$1</span>, %bx</span><br><span class="line">                         1009 <span class="built_in">test</span> <span class="variable">$0</span>, %bx</span><br><span class="line">                         1010 jgt .top</span><br><span class="line">                         1011 halt</span><br></pre></td></tr></table></figure>
<p>和上面的26的作业类似，在中断时间片较短的时候，两个线程都能够完成各自的工作。这个时候，count能够获得两个线程的累加工作，并获得确定的答案。既能够获得某个线程两倍的累加量。</p>
<h3 id="2-1"><a href="#2-1" class="headerlink" title="2."></a>2.</h3><p>上面其实已经解释了。答案是会的，能够按照预期工作。我们可以详细跟踪各个变量和寄存器的值看看</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$./x86.py -p flag.s -R ax,bx -M flag,count -c</span><br><span class="line">...</span><br><span class="line"> flag count      ax    bx          Thread 0                Thread 1</span><br><span class="line"></span><br><span class="line">    0     0       0     0</span><br><span class="line">    0     0       0     0   1000 mov  flag, %ax</span><br><span class="line">    0     0       0     0   1001 <span class="built_in">test</span> <span class="variable">$0</span>, %ax</span><br><span class="line">    0     0       0     0   1002 jne  .acquire</span><br><span class="line">    1     0       0     0   1003 mov  <span class="variable">$1</span>, flag</span><br><span class="line">    1     0       0     0   1004 mov  count, %ax</span><br><span class="line">    1     0       1     0   1005 add  <span class="variable">$1</span>, %ax</span><br><span class="line">    1     1       1     0   1006 mov  %ax, count</span><br><span class="line">    0     1       1     0   1007 mov  <span class="variable">$0</span>, flag</span><br><span class="line">    0     1       1    -1   1008 sub  <span class="variable">$1</span>, %bx</span><br><span class="line">    0     1       1    -1   1009 <span class="built_in">test</span> <span class="variable">$0</span>, %bx</span><br><span class="line">    0     1       1    -1   1010 jgt .top</span><br><span class="line">    0     1       1    -1   1011 halt</span><br><span class="line">    0     1       0     0   ----- Halt;Switch -----  ----- Halt;Switch -----</span><br><span class="line">    0     1       0     0                            1000 mov  flag, %ax</span><br><span class="line">    0     1       0     0                            1001 <span class="built_in">test</span> <span class="variable">$0</span>, %ax</span><br><span class="line">    0     1       0     0                            1002 jne  .acquire</span><br><span class="line">    1     1       0     0                            1003 mov  <span class="variable">$1</span>, flag</span><br><span class="line">    1     1       1     0                            1004 mov  count, %ax</span><br><span class="line">    1     1       2     0                            1005 add  <span class="variable">$1</span>, %ax</span><br><span class="line">    1     2       2     0                            1006 mov  %ax, count</span><br><span class="line">    0     2       2     0                            1007 mov  <span class="variable">$0</span>, flag</span><br><span class="line">    0     2       2    -1                            1008 sub  <span class="variable">$1</span>, %bx</span><br><span class="line">    0     2       2    -1                            1009 <span class="built_in">test</span> <span class="variable">$0</span>, %bx</span><br><span class="line">    0     2       2    -1                            1010 jgt .top</span><br><span class="line">    0     2       2    -1                            1011 halt</span><br></pre></td></tr></table></figure>
<p>可以看到两个线程的循环变量寄存器都是bx，它们都是1，说明可以各自累加一次。count的初始值是0，所以最终各自累加一次，可以看到最后count的值恰好是2，证明了可以按照预期工作。</p>
<h3 id="3-1"><a href="#3-1" class="headerlink" title="3."></a>3.</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$./x86.py -p flag.s -R ax,bx -M flag,count -c -a bx=2,bx=2</span><br><span class="line">...</span><br><span class="line"> flag count      ax    bx          Thread 0                Thread 1</span><br><span class="line"></span><br><span class="line">    0     0       0     2</span><br><span class="line">    0     0       0     2   1000 mov  flag, %ax</span><br><span class="line">    0     0       0     2   1001 <span class="built_in">test</span> <span class="variable">$0</span>, %ax</span><br><span class="line">    0     0       0     2   1002 jne  .acquire</span><br><span class="line">    1     0       0     2   1003 mov  <span class="variable">$1</span>, flag</span><br><span class="line">    1     0       0     2   1004 mov  count, %ax</span><br><span class="line">    1     0       1     2   1005 add  <span class="variable">$1</span>, %ax</span><br><span class="line">    1     1       1     2   1006 mov  %ax, count</span><br><span class="line">    0     1       1     2   1007 mov  <span class="variable">$0</span>, flag</span><br><span class="line">    0     1       1     1   1008 sub  <span class="variable">$1</span>, %bx</span><br><span class="line">    0     1       1     1   1009 <span class="built_in">test</span> <span class="variable">$0</span>, %bx</span><br><span class="line">    0     1       1     1   1010 jgt .top</span><br><span class="line">    0     1       0     1   1000 mov  flag, %ax</span><br><span class="line">    0     1       0     1   1001 <span class="built_in">test</span> <span class="variable">$0</span>, %ax</span><br><span class="line">    0     1       0     1   1002 jne  .acquire</span><br><span class="line">    1     1       0     1   1003 mov  <span class="variable">$1</span>, flag</span><br><span class="line">    1     1       1     1   1004 mov  count, %ax</span><br><span class="line">    1     1       2     1   1005 add  <span class="variable">$1</span>, %ax</span><br><span class="line">    1     2       2     1   1006 mov  %ax, count</span><br><span class="line">    0     2       2     1   1007 mov  <span class="variable">$0</span>, flag</span><br><span class="line">    0     2       2     0   1008 sub  <span class="variable">$1</span>, %bx</span><br><span class="line">    0     2       2     0   1009 <span class="built_in">test</span> <span class="variable">$0</span>, %bx</span><br><span class="line">    0     2       2     0   1010 jgt .top</span><br><span class="line">    0     2       2     0   1011 halt</span><br><span class="line">    0     2       0     2   ----- Halt;Switch -----  ----- Halt;Switch -----</span><br><span class="line">    0     2       0     2                            1000 mov  flag, %ax</span><br><span class="line">    0     2       0     2                            1001 <span class="built_in">test</span> <span class="variable">$0</span>, %ax</span><br><span class="line">    0     2       0     2                            1002 jne  .acquire</span><br><span class="line">    1     2       0     2                            1003 mov  <span class="variable">$1</span>, flag</span><br><span class="line">    1     2       2     2                            1004 mov  count, %ax</span><br><span class="line">    1     2       3     2                            1005 add  <span class="variable">$1</span>, %ax</span><br><span class="line">    1     3       3     2                            1006 mov  %ax, count</span><br><span class="line">    0     3       3     2                            1007 mov  <span class="variable">$0</span>, flag</span><br><span class="line">    0     3       3     1                            1008 sub  <span class="variable">$1</span>, %bx</span><br><span class="line">    0     3       3     1                            1009 <span class="built_in">test</span> <span class="variable">$0</span>, %bx</span><br><span class="line">    0     3       3     1                            1010 jgt .top</span><br><span class="line">    0     3       0     1                            1000 mov  flag, %ax</span><br><span class="line">    0     3       0     1                            1001 <span class="built_in">test</span> <span class="variable">$0</span>, %ax</span><br><span class="line">    0     3       0     1                            1002 jne  .acquire</span><br><span class="line">    1     3       0     1                            1003 mov  <span class="variable">$1</span>, flag</span><br><span class="line">    1     3       3     1                            1004 mov  count, %ax</span><br><span class="line">    1     3       4     1                            1005 add  <span class="variable">$1</span>, %ax</span><br><span class="line">    1     4       4     1                            1006 mov  %ax, count</span><br><span class="line">    0     4       4     1                            1007 mov  <span class="variable">$0</span>, flag</span><br><span class="line">    0     4       4     0                            1008 sub  <span class="variable">$1</span>, %bx</span><br><span class="line">    0     4       4     0                            1009 <span class="built_in">test</span> <span class="variable">$0</span>, %bx</span><br><span class="line">    0     4       4     0                            1010 jgt .top</span><br><span class="line">    0     4       4     0                            1011 halt</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>和前面的题目一样，实际就是两个线程分别进行两次累加，可以看到到目前为止，都能够正确完成累加。原因是中断切换线程执行的时候，两个线程都能够完成所有的累加，就不会出现存在竞态条件的情况。</p>
<h3 id="4-1"><a href="#4-1" class="headerlink" title="4."></a>4.</h3><p>这里我让循环为50次</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$./x86.py -p flag.s -R ax,bx -M flag,count -c -a bx=50,bx=50 -i 3</span><br><span class="line">...</span><br><span class="line"> flag count      ax    bx          Thread 0                Thread 1</span><br><span class="line"></span><br><span class="line">    0     0       0     2</span><br><span class="line">    0     0       0     2   1000 mov  flag, %ax</span><br><span class="line">    0     0       0     2   1001 <span class="built_in">test</span> <span class="variable">$0</span>, %ax</span><br><span class="line">    0     0       0     2   1002 jne  .acquire</span><br><span class="line">    1     0       0     2   1003 mov  <span class="variable">$1</span>, flag</span><br><span class="line">    1     0       0     2   1004 mov  count, %ax</span><br><span class="line">    1     0       1     2   1005 add  <span class="variable">$1</span>, %ax</span><br><span class="line">    1     1       1     2   1006 mov  %ax, count</span><br><span class="line">    0     1       1     2   1007 mov  <span class="variable">$0</span>, flag</span><br><span class="line">...</span><br><span class="line">  	1    57      57     1   1006 mov  %ax, count</span><br><span class="line">    0    57      57     1   1007 mov  <span class="variable">$0</span>, flag</span><br><span class="line">    0    57      57     1   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    0    57      57     0   1008 sub  <span class="variable">$1</span>, %bx</span><br><span class="line">    0    57      57     0   1009 <span class="built_in">test</span> <span class="variable">$0</span>, %bx</span><br><span class="line">    0    57      57     0   1010 jgt .top</span><br><span class="line">    0    57      57     0   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    0    57      57     0   1011 halt</span><br></pre></td></tr></table></figure>
<p>你能够看到两个线程循环50次，应该要能够累加100次，但是最后的结果是只累加了57次。此时我们说出现了不确定现象。</p>
<p>由于以flag作为锁，它的加锁和解锁本身没有原子性，所以并不能够起到保护共享资源的作用。所以随着<code>bx</code>增大，<code>i</code>减小，越容易产生不好的结果。反过来<code>bx</code>减小，<code>i</code>增大越趋向于产生确定的好的结果。</p>
<h3 id="5"><a href="#5" class="headerlink" title="5."></a>5.</h3><p>现在我们研究另外一个文件，它是个使用硬件原语<code>test-and-set</code>的指令，详细看看：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> test-and-set.s</span><br><span class="line">.var mutex</span><br><span class="line">.var count</span><br><span class="line"></span><br><span class="line">.main</span><br><span class="line">.top</span><br><span class="line"></span><br><span class="line">.acquire</span><br><span class="line">mov  <span class="variable">$1</span>, %ax</span><br><span class="line">xchg %ax, mutex     <span class="comment"># atomic swap of 1 and mutex</span></span><br><span class="line"><span class="built_in">test</span> <span class="variable">$0</span>, %ax        <span class="comment"># if we get 0 back: lock is free!</span></span><br><span class="line">jne  .acquire       <span class="comment"># if not, try again</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># critical section</span></span><br><span class="line">mov  count, %ax     <span class="comment"># get the value at the address</span></span><br><span class="line">add  <span class="variable">$1</span>, %ax        <span class="comment"># increment it</span></span><br><span class="line">mov  %ax, count     <span class="comment"># store it back</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># release lock</span></span><br><span class="line">mov  <span class="variable">$0</span>, mutex</span><br><span class="line"></span><br><span class="line"><span class="comment"># see if we&#x27;re still looping</span></span><br><span class="line">sub  <span class="variable">$1</span>, %bx</span><br><span class="line"><span class="built_in">test</span> <span class="variable">$0</span>, %bx</span><br><span class="line">jgt .top</span><br><span class="line"></span><br><span class="line">halt</span><br></pre></td></tr></table></figure>
<p>同样针对上面的汇编代码我们写出c语言版本</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> <span class="type">mutex_t</span>;</span><br><span class="line"><span class="type">mutex_t</span> mutex;</span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> i = n;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">/* 等待锁空闲，如果有空闲锁就上锁 */</span></span><br><span class="line">        <span class="keyword">while</span> (test_and_set(&amp;mutex, <span class="number">0x1</span>) != <span class="number">0x0</span>)</span><br><span class="line">            ; <span class="comment">// spin</span></span><br><span class="line">        <span class="comment">/* 临界区 */</span></span><br><span class="line">        count++;</span><br><span class="line">        <span class="comment">/* 解锁 */</span></span><br><span class="line">        mutex = <span class="number">0x0</span>;</span><br><span class="line">        i--;</span><br><span class="line">    &#125; <span class="keyword">while</span> (i &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="comment">/* halt */</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中获取锁部分：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 等待锁空闲，如果有空闲锁就上锁 */</span></span><br><span class="line"><span class="keyword">while</span> (test_and_set(&amp;mutex, <span class="number">0x1</span>) != <span class="number">0x0</span>)</span><br><span class="line">    ; <span class="comment">// spin</span></span><br><span class="line">=&gt;</span><br><span class="line">.acquire</span><br><span class="line">mov  $<span class="number">1</span>, %ax</span><br><span class="line">xchg %ax, mutex     <span class="meta"># atomic swap of 1 and mutex</span></span><br><span class="line">test $<span class="number">0</span>, %ax        <span class="meta"># <span class="keyword">if</span> we get 0 back: lock is free!</span></span><br><span class="line">jne  .acquire       <span class="meta"># <span class="keyword">if</span> not, try again</span></span><br></pre></td></tr></table></figure>
<p>释放锁部分：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 解锁 */</span></span><br><span class="line">mutex = <span class="number">0x0</span>;</span><br><span class="line">=&gt;</span><br><span class="line">mov  $<span class="number">0</span>, mutex</span><br></pre></td></tr></table></figure>
<h3 id="6"><a href="#6" class="headerlink" title="6."></a>6.</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ ./x86.py -p test-and-set.s -i 3 -a bx=50,bx=50 -M mutex,count -R ax,bx -c</span><br><span class="line">...</span><br><span class="line">mutex count      ax    bx          Thread 0                Thread 1</span><br><span class="line"></span><br><span class="line">    0     0       0    50</span><br><span class="line">    0     0       1    50   1000 mov  <span class="variable">$1</span>, %ax</span><br><span class="line">    1     0       0    50   1001 xchg %ax, mutex</span><br><span class="line">    1     0       0    50   1002 <span class="built_in">test</span> <span class="variable">$0</span>, %ax</span><br><span class="line">    1     0       0    50   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    1     0       1    50                            1000 mov  <span class="variable">$1</span>, %ax</span><br><span class="line">    1     0       1    50                            1001 xchg %ax, mutex</span><br><span class="line">    1     0       1    50                            1002 <span class="built_in">test</span> <span class="variable">$0</span>, %ax</span><br><span class="line">    1     0       0    50   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">... </span><br><span class="line">   	0   100     100     0                            1008 sub  <span class="variable">$1</span>, %bx</span><br><span class="line">    0   100     100     0   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    0   100     100     0                            1009 <span class="built_in">test</span> <span class="variable">$0</span>, %bx</span><br><span class="line">    0   100     100     0                            1010 jgt .top</span><br><span class="line">    0   100     100     0                            1011 halt</span><br></pre></td></tr></table></figure>
<p>可以看到在这种<code>test-and-set</code>的硬件原语支持下，能够保证原子性。所以最后计算的结果能够满足预期。但是可以从上面的代码中的看出，虽然保证了加锁的原子性，进而控制了了每次只能有一个线程在临界区。但是，由于当线程没有抢占到锁，就会在while中自旋等待，倘若拥有锁定的线程迟迟不释放锁，其他大量的线程就可能都处于自选等待的状态。而如果线程间调度采用的是类似轮转这样的算法，那么就会有大量的CPU资源用来自选。这种自选显然不是我们想要的，因此由于分时共享CPU的存在，CPU的使用率虽然比较高，但是做的有用功却不是很高，大部分时间在做自选等待。</p>
<p>现在考虑如何量化这样的CPU使用率的描述。就比如上面的示例代码两个线程一共做了100次累加，每次累加只有下面3条指令是经行累加的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># critical section</span><br><span class="line">mov  count, %ax     # get the value at the address</span><br><span class="line">add  $1, %ax        # increment it</span><br><span class="line">mov  %ax, count     # store it back</span><br></pre></td></tr></table></figure>
<p>因此也就只有3*100 = 300条指令做有用功，剩下的通通是无用功。可以统计上面的计算共有2010行。由于整个计算过程CPU都处于工作状态。因此使用率100%。但是有效使用率仅有300/2010 = 14.93%</p>
<h3 id="7"><a href="#7" class="headerlink" title="7."></a>7.</h3><p>首先我们需要通过增加<code>-P</code>属性来规定执行的顺序。例如：<code>-P 1100111000111000111000</code>就会依次按照t1，t1，t0，t0，t1，…，t0，t0，t0的顺序执行线程</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ ./x86.py -p test-and-set.s -i 10 -R ax,bx -M mutex,count -a bx=5 -P 1100111000111000111000 -c</span><br><span class="line">...</span><br><span class="line">mutex count      ax    bx          Thread 0                Thread 1</span><br><span class="line"></span><br><span class="line">    0     0       0     5</span><br><span class="line">    0     0       1     5                            1000 mov  <span class="variable">$1</span>, %ax</span><br><span class="line">    1     0       0     5                            1001 xchg %ax, mutex</span><br><span class="line">    1     0       0     5   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    1     0       1     5   1000 mov  <span class="variable">$1</span>, %ax</span><br><span class="line">    1     0       1     5   1001 xchg %ax, mutex</span><br><span class="line">    1     0       0     5   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    1     0       0     5                            1002 <span class="built_in">test</span> <span class="variable">$0</span>, %ax</span><br><span class="line">    1     0       0     5                            1003 jne  .acquire</span><br><span class="line">...</span><br><span class="line">    1    10      10     1   1006 mov  %ax, count</span><br><span class="line">    0    10      10     1   1007 mov  <span class="variable">$0</span>, mutex</span><br><span class="line">    0    10      10     0   1008 sub  <span class="variable">$1</span>, %bx</span><br><span class="line">    0    10      10     0   1009 <span class="built_in">test</span> <span class="variable">$0</span>, %bx</span><br><span class="line">    0    10      10     0   1010 jgt .top</span><br><span class="line">    0    10      10     0   1011 halt</span><br></pre></td></tr></table></figure>
<p>可以看到最后结果是正确的，由于上面的获取锁过程是具有原子性的，也就是说每一次只能有一个线程执行成功(成功把flag从0变成1)获得锁。因此也就保证了正确性。</p>
<h2 id="第30章"><a href="#第30章" class="headerlink" title="第30章"></a>第30章</h2><p>由于第30章中文版课本上没有题目，因此在这里放出英文课本原题。</p>
<h3 id="1-2"><a href="#1-2" class="headerlink" title="1."></a>1.</h3><p><img src="/2022/05/19/OS-thread-homework/image-20220516082241930.png" alt="image-20220516082241930"></p>
<p>这个题目要我们专注于文件<code>main-two-cvs-while.c</code>。首先需要先了解代码的含义，理解代码运行会发生什么。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* src: main-two-cvs-while.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common_threads.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pc-header.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是用于生产者消费者的信号量</span></span><br><span class="line"><span class="comment">// empty 用于通知生产者复工</span></span><br><span class="line"><span class="comment">// fill  用于通知消费者消费</span></span><br><span class="line"><span class="comment">// m     锁</span></span><br><span class="line"><span class="type">pthread_cond_t</span> empty  = PTHREAD_COND_INITIALIZER;</span><br><span class="line"><span class="type">pthread_cond_t</span> fill   = PTHREAD_COND_INITIALIZER;</span><br><span class="line"><span class="type">pthread_mutex_t</span> m     = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main-header.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 填充函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_fill</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="comment">// 确保在这个函数使用前buffer[fill_ptr]是空的</span></span><br><span class="line">    <span class="comment">// 否则打印错误讯息</span></span><br><span class="line">    ensure(buffer[fill_ptr] == EMPTY, <span class="string">&quot;error: tried to fill a non-empty buffer&quot;</span>);</span><br><span class="line">    <span class="comment">// 填充缓冲区特定位置</span></span><br><span class="line">    buffer[fill_ptr] = value;</span><br><span class="line">    <span class="comment">// 填充指针指向下一位置</span></span><br><span class="line">    fill_ptr = (fill_ptr + <span class="number">1</span>) % max;</span><br><span class="line">    <span class="comment">// 已经填充数量加一</span></span><br><span class="line">    num_full++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">do_get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取特定位置的值</span></span><br><span class="line">    <span class="type">int</span> tmp = buffer[use_ptr];</span><br><span class="line">    <span class="comment">// 确保缓冲区有值</span></span><br><span class="line">    <span class="comment">// 否则打印错误讯息</span></span><br><span class="line">    ensure(tmp != EMPTY, <span class="string">&quot;error: tried to get an empty buffer&quot;</span>);</span><br><span class="line">    <span class="comment">// 取完商品把这个位置置空</span></span><br><span class="line">    buffer[use_ptr] = EMPTY;</span><br><span class="line">    <span class="comment">// 使用指针指向下一位置</span></span><br><span class="line">    use_ptr = (use_ptr + <span class="number">1</span>) % max;</span><br><span class="line">    <span class="comment">// 已经填充数量减一</span></span><br><span class="line">    num_full--;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者函数</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">producer</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="comment">// 根据arg所指的数值设置生产者的id</span></span><br><span class="line">    <span class="type">int</span> id = (<span class="type">int</span>) arg;</span><br><span class="line">    <span class="comment">// 确保每一个生产者能够生产自己专属的值(与id关联)</span></span><br><span class="line">    <span class="type">int</span> base = id * loops;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loops; i++) &#123;   p0;	<span class="comment">// 循环生产商品</span></span><br><span class="line">        Mutex_lock(&amp;m);             p1;	<span class="comment">// 获取锁</span></span><br><span class="line">        <span class="keyword">while</span> (num_full == max) &#123;   p2;	<span class="comment">// 如果货架满了</span></span><br><span class="line">            Cond_wait(&amp;empty, &amp;m);  p3;	<span class="comment">// 则睡眠等待货架再次为空时复工</span></span><br><span class="line">        &#125;</span><br><span class="line">        do_fill(base + i);          p4;	<span class="comment">// 进行一次货架填充</span></span><br><span class="line">        Cond_signal(&amp;fill);         p5;	<span class="comment">// 通知消费者可消费</span></span><br><span class="line">        Mutex_unlock(&amp;m);           p6;	<span class="comment">// 释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">consumer</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="comment">// 消费者根据arg产生唯一id</span></span><br><span class="line">    <span class="type">int</span> id = (<span class="type">int</span>) arg;					</span><br><span class="line">    <span class="type">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> consumed_count = <span class="number">0</span>;			   <span class="comment">// 消费数量</span></span><br><span class="line">    <span class="keyword">while</span> (tmp != END_OF_STREAM) &#123; c0; <span class="comment">// 循环直到生产商品流的最后元素</span></span><br><span class="line">        Mutex_lock(&amp;m);            c1; <span class="comment">// 获取锁</span></span><br><span class="line">        <span class="keyword">while</span> (num_full == <span class="number">0</span>) &#123;    c2; <span class="comment">// 如果货架空了</span></span><br><span class="line">            Cond_wait(&amp;fill, &amp;m);  c3; <span class="comment">// 等待生产者填充货架</span></span><br><span class="line">        &#125;</span><br><span class="line">        tmp = do_get();            c4; <span class="comment">// 获取货物</span></span><br><span class="line">        Cond_signal(&amp;empty);       c5; <span class="comment">// </span></span><br><span class="line">        Mutex_unlock(&amp;m);          c6; <span class="comment">// 释放锁</span></span><br><span class="line">        consumed_count++;			   <span class="comment">// 消费数量加一</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回consumer_count-1是因为END_OF_STREAM并不是有效商品</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span> *) (<span class="type">long</span> <span class="type">long</span>) (consumed_count - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置控制信号</span></span><br><span class="line"><span class="type">pthread_cond_t</span> *fill_cv = &amp;fill;</span><br><span class="line"><span class="type">pthread_cond_t</span> *empty_cv = &amp;empty;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有代码使用这个文件里的东西</span></span><br><span class="line"><span class="comment">// 包括主函数等启动问题程序</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main-common.c&quot;</span></span></span><br></pre></td></tr></table></figure>
<p>对上面的代码我们做出了解析，如注释所示。我们的生产者会调用<code>do_fill</code>进行生产活动，一次只生产一个货物到空货架上。消费者会调用<code>do_get</code>获取货物，一次只获得一个商品。货架是一个数组，上面依次存取商品，由<code>fill_ptr</code>指明放入位置，由<code>use_ptr</code>知名从哪个位置取商品。</p>
<h3 id="2-2"><a href="#2-2" class="headerlink" title="2."></a>2.</h3><p><img src="/2022/05/19/OS-thread-homework/image-20220516085555854.png" alt="image-20220516085555854"></p>
<p>运行一个生产者一个消费者程序，然后让生产者生产一些特定的值。一开始我们只是使用一个长度大小只有1的buffer，然后慢慢增长它。当货架增大，程序代码会做和行为？你认为<code>num_full</code>会随着buffer的容量变大有什么不同（例如可以设成-<code>l 100</code>），当你改变消费者字符串，从默认的不睡眠到<code>-C 0,0,0,0,0,0,1</code>会发生什么？</p>
<p>这是一个项目程序，我们应该先编译他们：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sh&gt; make</span><br></pre></td></tr></table></figure>
<p>编译完成生成了几个可执行的程序，现在我们让buffer长度为1，然后仅仅看看一个生产者和一个消费者的情况</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/ostep-homework/threads-cv</span><br><span class="line">$ ./main-two-cvs-while -p 1 -c1 -m 1 -v</span><br><span class="line"> NF         P0 C0 </span><br><span class="line">  0 [*--- ]    c0</span><br><span class="line">  0 [*--- ] p0</span><br><span class="line">  0 [*--- ]    c1</span><br><span class="line">  0 [*--- ]    c2</span><br><span class="line">  0 [*--- ] p1</span><br><span class="line">  1 [*  0 ] p4</span><br><span class="line">  1 [*  0 ] p5</span><br><span class="line">  1 [*  0 ] p6</span><br><span class="line">  1 [*  0 ]    c3</span><br><span class="line">  0 [*--- ]    c4</span><br><span class="line">  0 [*--- ]    c5</span><br><span class="line">  1 [*EOS ] [main: added end-of-stream marker]</span><br><span class="line">  1 [*EOS ]    c6</span><br><span class="line">  1 [*EOS ]    c0</span><br><span class="line">  1 [*EOS ]    c1</span><br><span class="line">  0 [*--- ]    c4</span><br><span class="line">  0 [*--- ]    c5</span><br><span class="line">  0 [*--- ]    c6</span><br><span class="line"></span><br><span class="line">Consumer consumption:</span><br><span class="line">  C0 -&gt; 1</span><br></pre></td></tr></table></figure>
<p>上面的数码做了一件事：[]中放的是buffer的内容，再往左是buffer的<code>full_num</code>。然后是对应的生产者消费者执行的步骤。（具体请见上面c代码）首先消费者执行c0，然后是消费者执行p0。然后消费者执行c1获取锁。然后while判断货架为空准备进入等待并释放锁。然后生产者获取锁，while判断货架为空跳过等待进行生产，然后唤醒消费者并释放锁。然后消费者苏醒获取锁，进行消费。此时以达到生产线最后元素（EOS）。然后消费者退出循环并返回。最后我们可以看到消费者C0消费了一个商品。上面过程没有出现什么问题。</p>
<p>接下来我们增大buffer尺寸。比如加到10</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/ostep-homework/threads-cv</span><br><span class="line">$ ./main-two-cvs-while -p 1 -c1 -m 10 -v</span><br><span class="line"> NF                                                      P0 C0 </span><br><span class="line">  0 [*---  ---  ---  ---  ---  ---  ---  ---  ---  --- ]    c0</span><br><span class="line">  0 [*---  ---  ---  ---  ---  ---  ---  ---  ---  --- ] p0</span><br><span class="line">  0 [*---  ---  ---  ---  ---  ---  ---  ---  ---  --- ] p1</span><br><span class="line">  1 [u  0 f---  ---  ---  ---  ---  ---  ---  ---  --- ] p4</span><br><span class="line">  1 [u  0 f---  ---  ---  ---  ---  ---  ---  ---  --- ] p5</span><br><span class="line">  1 [u  0 f---  ---  ---  ---  ---  ---  ---  ---  --- ] p6</span><br><span class="line">  1 [u  0 f---  ---  ---  ---  ---  ---  ---  ---  --- ]    c1</span><br><span class="line">  0 [ --- *---  ---  ---  ---  ---  ---  ---  ---  --- ]    c4</span><br><span class="line">  0 [ --- *---  ---  ---  ---  ---  ---  ---  ---  --- ]    c5</span><br><span class="line">  1 [ --- uEOS f---  ---  ---  ---  ---  ---  ---  --- ] [main: added end-of-stream marker]</span><br><span class="line">  1 [ --- uEOS f---  ---  ---  ---  ---  ---  ---  --- ]    c6</span><br><span class="line">  1 [ --- uEOS f---  ---  ---  ---  ---  ---  ---  --- ]    c0</span><br><span class="line">  1 [ --- uEOS f---  ---  ---  ---  ---  ---  ---  --- ]    c1</span><br><span class="line">  0 [ ---  --- *---  ---  ---  ---  ---  ---  ---  --- ]    c4</span><br><span class="line">  0 [ ---  --- *---  ---  ---  ---  ---  ---  ---  --- ]    c5</span><br><span class="line">  0 [ ---  --- *---  ---  ---  ---  ---  ---  ---  --- ]    c6</span><br><span class="line"></span><br><span class="line">Consumer consumption:</span><br><span class="line">  C0 -&gt; 1</span><br></pre></td></tr></table></figure>
<p>可以看到<code>-l</code>不发生变化，实际上和前面差不多，都没有什么问题。</p>
<p>然后我们现在增加生产次数</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/ostep-homework/threads-cv$ ./main-two-cvs-while -p 1 -c1 -m 10 -l 100  -v</span><br><span class="line"> NF                                                      P0 C0 </span><br><span class="line">  0 [*---  ---  ---  ---  ---  ---  ---  ---  ---  --- ] p0</span><br><span class="line">  0 [*---  ---  ---  ---  ---  ---  ---  ---  ---  --- ]    c0</span><br><span class="line">  0 [*---  ---  ---  ---  ---  ---  ---  ---  ---  --- ] p1</span><br><span class="line">  1 [u  0 f---  ---  ---  ---  ---  ---  ---  ---  --- ] p4</span><br><span class="line">  1 [u  0 f---  ---  ---  ---  ---  ---  ---  ---  --- ] p5</span><br><span class="line">  1 [u  0 f---  ---  ---  ---  ---  ---  ---  ---  --- ] p6</span><br><span class="line">...</span><br><span class="line">  1 [f---  ---  ---  ---  ---  ---  ---  ---  --- u 99 ] p5</span><br><span class="line">  1 [f---  ---  ---  ---  ---  ---  ---  ---  --- u 99 ] p6</span><br><span class="line">  1 [f---  ---  ---  ---  ---  ---  ---  ---  --- u 99 ]    c1</span><br><span class="line">  0 [*---  ---  ---  ---  ---  ---  ---  ---  ---  --- ]    c4</span><br><span class="line">  0 [*---  ---  ---  ---  ---  ---  ---  ---  ---  --- ]    c5</span><br><span class="line">  1 [uEOS f---  ---  ---  ---  ---  ---  ---  ---  --- ] [main: added end-of-stream marker]</span><br><span class="line">  1 [uEOS f---  ---  ---  ---  ---  ---  ---  ---  --- ]    c6</span><br><span class="line">  1 [uEOS f---  ---  ---  ---  ---  ---  ---  ---  --- ]    c0</span><br><span class="line">  1 [uEOS f---  ---  ---  ---  ---  ---  ---  ---  --- ]    c1</span><br><span class="line">  0 [ --- *---  ---  ---  ---  ---  ---  ---  ---  --- ]    c4</span><br><span class="line">  0 [ --- *---  ---  ---  ---  ---  ---  ---  ---  --- ]    c5</span><br><span class="line">  0 [ --- *---  ---  ---  ---  ---  ---  ---  ---  --- ]    c6</span><br><span class="line"></span><br><span class="line">Consumer consumption:</span><br><span class="line">  C0 -&gt; 100</span><br></pre></td></tr></table></figure>
<p>可以看到消费者都能够正常获得商品。</p>
<p>现在改变消费者睡眠字符串</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/ostep-homework/threads-cv$ ./main-two-cvs-while -p 1 -c1 -m 10 -l 100  -v</span><br><span class="line"> NF                                                      P0 C0 </span><br><span class="line">  0 [*---  ---  ---  ---  ---  ---  ---  ---  ---  --- ] p0</span><br><span class="line">  0 [*---  ---  ---  ---  ---  ---  ---  ---  ---  --- ]    c0</span><br><span class="line">  0 [*---  ---  ---  ---  ---  ---  ---  ---  ---  --- ] p1</span><br><span class="line">  1 [u  0 f---  ---  ---  ---  ---  ---  ---  ---  --- ] p4</span><br><span class="line">  1 [u  0 f---  ---  ---  ---  ---  ---  ---  ---  --- ] p5</span><br><span class="line">  1 [u  0 f---  ---  ---  ---  ---  ---  ---  ---  --- ] p6</span><br><span class="line">  1 [u  0 f---  ---  ---  ---  ---  ---  ---  ---  --- ]    c1</span><br><span class="line">  0 [ --- *---  ---  ---  ---  ---  ---  ---  ---  --- ]    c4</span><br><span class="line">  0 [ --- *---  ---  ---  ---  ---  ---  ---  ---  --- ] p0</span><br><span class="line">  0 [ --- *---  ---  ---  ---  ---  ---  ---  ---  --- ]    c5</span><br><span class="line">  0 [ --- *---  ---  ---  ---  ---  ---  ---  ---  --- ]    c6</span><br><span class="line">  0 [ --- *---  ---  ---  ---  ---  ---  ---  ---  --- ] p1</span><br><span class="line">  0 [ --- *---  ---  ---  ---  ---  ---  ---  ---  --- ]    c0</span><br><span class="line">  1 [ --- u  1 f---  ---  ---  ---  ---  ---  ---  --- ] p4</span><br><span class="line">  1 [ --- u  1 f---  ---  ---  ---  ---  ---  ---  --- ] p5</span><br><span class="line">...</span><br><span class="line"> 0 [ ---  ---  ---  ---  --- *---  ---  ---  ---  --- ] p1</span><br><span class="line">  1 [ ---  ---  ---  ---  --- u 25 f---  ---  ---  --- ] p4</span><br><span class="line">  1 [ ---  ---  ---  ---  --- u 25 f---  ---  ---  --- ]    c0</span><br><span class="line">  1 [ ---  ---  ---  ---  --- u 25 f---  ---  ---  --- ] p5</span><br><span class="line">  1 [ ---  ---  ---  ---  --- u 25 f---  ---  ---  --- ] p6</span><br><span class="line">  1 [ ---  ---  ---  ---  --- u 25 f---  ---  ---  --- ]    c1</span><br><span class="line">  1 [ ---  ---  ---  ---  --- u 25 f---  ---  ---  --- ] p0</span><br><span class="line">  0 [ ---  ---  ---  ---  ---  --- *---  ---  ---  --- ]    c4</span><br><span class="line">  0 [ ---  ---  ---  ---  ---  --- *---  ---  ---  --- ]    c5</span><br><span class="line">  0 [ ---  ---  ---  ---  ---  --- *---  ---  ---  --- ]    c6</span><br><span class="line">  0 [ ---  ---  ---  ---  ---  --- *---  ---  ---  --- ] p1</span><br><span class="line">  1 [ ---  ---  ---  ---  ---  --- u 26 f---  ---  --- ] p4</span><br><span class="line">  1 [ ---  ---  ---  ---  ---  --- u 26 f---  ---  --- ]    c0</span><br><span class="line">  1 [ ---  ---  ---  ---  ---  --- u 26 f---  ---  --- ] p5</span><br><span class="line">  1 [ ---  ---  ---  ---  ---  --- u 26 f---  ---  --- ] p6</span><br><span class="line">  1 [ ---  ---  ---  ---  ---  --- u 26 f---  ---  --- ] p0</span><br><span class="line">  1 [ ---  ---  ---  ---  ---  --- u 26 f---  ---  --- ]    c1</span><br><span class="line">  0 [ ---  ---  ---  ---  ---  ---  --- *---  ---  --- ]    c4</span><br><span class="line">  0 [ ---  ---  ---  ---  ---  ---  --- *---  ---  --- ]    c5</span><br><span class="line">  0 [ ---  ---  ---  ---  ---  ---  --- *---  ---  --- ]    c6</span><br><span class="line">  0 [ ---  ---  ---  ---  ---  ---  --- *---  ---  --- ] p1</span><br><span class="line">  0 [ ---  ---  ---  ---  ---  ---  --- *---  ---  --- ]    c0</span><br><span class="line">  1 [ ---  ---  ---  ---  ---  ---  --- u 27 f---  --- ] p4</span><br><span class="line">  1 [ ---  ---  ---  ---  ---  ---  --- u 27 f---  --- ] p5</span><br><span class="line">  1 [ ---  ---  ---  ---  ---  ---  --- u 27 f---  --- ] p6</span><br><span class="line">  1 [ ---  ---  ---  ---  ---  ---  --- u 27 f---  --- ]    c1</span><br><span class="line">  1 [ ---  ---  ---  ---  ---  ---  --- u 27 f---  --- ] p0</span><br><span class="line">  0 [ ---  ---  ---  ---  ---  ---  ---  --- *---  --- ]    c4</span><br><span class="line">...</span><br><span class="line">  9 [f--- u  1    2    3    4    5    6    7    8    9 ] p0</span><br><span class="line">  9 [f--- u  1    2    3    4    5    6    7    8    9 ] p1</span><br><span class="line"> 10 [  10 *  1    2    3    4    5    6    7    8    9 ] p4</span><br><span class="line"> 10 [  10 *  1    2    3    4    5    6    7    8    9 ] p5</span><br><span class="line"> 10 [  10 *  1    2    3    4    5    6    7    8    9 ] p6</span><br><span class="line"> 10 [  10 *  1    2    3    4    5    6    7    8    9 ] p0</span><br><span class="line"> 10 [  10 *  1    2    3    4    5    6    7    8    9 ] p1</span><br><span class="line"> 10 [  10 *  1    2    3    4    5    6    7    8    9 ] p2</span><br><span class="line"> 10 [  10 *  1    2    3    4    5    6    7    8    9 ]    c0</span><br><span class="line"> 10 [  10 *  1    2    3    4    5    6    7    8    9 ]    c1</span><br><span class="line">  9 [  10 f--- u  2    3    4    5    6    7    8    9 ]    c4</span><br><span class="line">  9 [  10 f--- u  2    3    4    5    6    7    8    9 ]    c5</span><br><span class="line">  9 [  10 f--- u  2    3    4    5    6    7    8    9 ]    c6</span><br><span class="line">  9 [  10 f--- u  2    3    4    5    6    7    8    9 ] p3</span><br><span class="line">...</span><br><span class="line">  1 [uEOS f---  ---  ---  ---  ---  ---  ---  ---  --- ]    c0</span><br><span class="line">  1 [uEOS f---  ---  ---  ---  ---  ---  ---  ---  --- ]    c1</span><br><span class="line">  0 [ --- *---  ---  ---  ---  ---  ---  ---  ---  --- ]    c4</span><br><span class="line">  0 [ --- *---  ---  ---  ---  ---  ---  ---  ---  --- ]    c5</span><br><span class="line">  0 [ --- *---  ---  ---  ---  ---  ---  ---  ---  --- ]    c6</span><br><span class="line"></span><br><span class="line">Consumer consumption:</span><br><span class="line">  C0 -&gt; 100</span><br></pre></td></tr></table></figure>
<p>看到上面的代码，生产f总是在使用u之前。</p>
<p>同时消费者总是等到缓冲区满了才开始消费。然后消费一个就通知生产者生产直到生产完毕。</p>
<p>此时一切生产消费活动都处于正常状态。</p>
<h3 id="4-2"><a href="#4-2" class="headerlink" title="4."></a>4.</h3><p><img src="/2022/05/19/OS-thread-homework/image-20220516100021157.png" alt="image-20220516100021157"></p>
<p>如果只有一个生产者，三个消费者，只有一个单一入口的buffer，每个消费者在c3指令执行的时候入睡要一秒钟（-C 0,0,0,1,0,0,0）</p>
<p>我们输入指令看看情况发生了什么？</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/ostep-homework/threads-cv</span><br><span class="line">$ ./main-two-cvs-while -p 1 -c 3 -m 1 -C 0,0,0,1,0,0,0:0,0,0,1,0,0,0:0,0,0,1,0,0,0 -l 10 -v -t</span><br><span class="line"> NF         P0 C0 C1 C2 </span><br><span class="line">  0 [*--- ]    c0</span><br><span class="line">  0 [*--- ] p0</span><br><span class="line">  0 [*--- ]       c0</span><br><span class="line">  0 [*--- ]          c0</span><br><span class="line">  0 [*--- ]    c1</span><br><span class="line">  0 [*--- ]    c2</span><br><span class="line">  0 [*--- ] p1</span><br><span class="line">  1 [*  0 ] p4</span><br><span class="line">  1 [*  0 ] p5</span><br><span class="line">  1 [*  0 ] p6</span><br><span class="line">  1 [*  0 ]       c1</span><br><span class="line">...</span><br><span class="line">Consumer consumption:</span><br><span class="line">  C0 -&gt; 0</span><br><span class="line">  C1 -&gt; 10</span><br><span class="line">  C2 -&gt; 0</span><br><span class="line"></span><br><span class="line">Total time: 13.07 seconds</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">Consumer consumption:</span><br><span class="line">  C0 -&gt; 9</span><br><span class="line">  C1 -&gt; 0</span><br><span class="line">  C2 -&gt; 1</span><br><span class="line"></span><br><span class="line">Total time: 12.08 seconds</span><br></pre></td></tr></table></figure>
<p>不同次运行同样的命令，每次的运行时间不一致。但至少10s，因为消费者会取出10个数据。每取一个都会有1s的休眠。</p>
<p>可以看到上面的代码能够保证生产10个消费10个，但是存在消费者会被饿死的情况。</p>
<h3 id="8"><a href="#8" class="headerlink" title="8."></a>8.</h3><p><img src="/2022/05/19/OS-thread-homework/image-20220516101427280.png" alt="image-20220516101427280"></p>
<p>现在看看<code>main-one-cv-while.c</code>，现在我们要写一个睡眠字符串，在只有一个生产者和一个消费者和一个缓冲区只有1大小的情况下产生问题。</p>
<p>一个生产者一个消费者不会产生什么问题，因为通信的只有生产者和消费者。但是如果出现两个生产者或者两个消费者的时候，一个条件变量就会不清楚通知的是生产者还是消费者。</p>
<h3 id="9"><a href="#9" class="headerlink" title="9."></a>9.</h3><p><img src="/2022/05/19/OS-thread-homework/image-20220516103344533.png" alt="image-20220516103344533"></p>
<p>这个问题是课本257页表格表示的只有一个条件变量的问题。因为条件变量只有一个，所以所以可能存在一个消费者消费完试图唤醒生产者，但是不是唤醒生产者而是唤醒另外一个消费者，最终造成发出信号的消费者睡着，生产者没有醒过来，另外一个消费者醒过来发现没有东西消费，然后又睡着的情况。最终三个人都睡着了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生产者</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loops; i++) &#123;   p0;	<span class="comment">// 循环生产商品</span></span><br><span class="line">        Mutex_lock(&amp;m);             p1;	<span class="comment">// 获取锁</span></span><br><span class="line">        <span class="keyword">while</span> (num_full == max) &#123;   p2;	<span class="comment">// 如果货架满了</span></span><br><span class="line">            Cond_wait(&amp;empty, &amp;m);  p3;	<span class="comment">// 则睡眠等待货架再次为空时复工</span></span><br><span class="line">        &#125;</span><br><span class="line">        do_fill(base + i);          p4;	<span class="comment">// 进行一次货架填充</span></span><br><span class="line">        Cond_signal(&amp;fill);         p5;	<span class="comment">// 通知消费者可消费</span></span><br><span class="line">        Mutex_unlock(&amp;m);           p6;	<span class="comment">// 释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 消费者</span></span><br><span class="line"><span class="keyword">while</span> (tmp != END_OF_STREAM) &#123; c0; <span class="comment">// 循环直到生产商品流的最后元素</span></span><br><span class="line">        Mutex_lock(&amp;m);            c1; <span class="comment">// 获取锁</span></span><br><span class="line">        <span class="keyword">while</span> (num_full == <span class="number">0</span>) &#123;    c2; <span class="comment">// 如果货架空了</span></span><br><span class="line">            Cond_wait(&amp;fill, &amp;m);  c3; <span class="comment">// 等待生产者填充货架</span></span><br><span class="line">        &#125;</span><br><span class="line">        tmp = do_get();            c4; <span class="comment">// 获取货物</span></span><br><span class="line">        Cond_signal(&amp;empty);       c5; <span class="comment">// </span></span><br><span class="line">        Mutex_unlock(&amp;m);          c6; <span class="comment">// 释放锁</span></span><br></pre></td></tr></table></figure>
<p>我们可以看到p3是进行苏醒的，我们让它睡久一点，就能够触发问题了。比如这里我们让他睡五秒。</p>
<p>得到结果如下</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/ostep-homework/threads-cv</span><br><span class="line">$ ./main-one-cv-while -m 1 -l 5 -c 2 -p 1 -P 0,0,0,10,0,0,0 -v -t</span><br><span class="line"> NF         P0 C0 C1 </span><br><span class="line">  0 [*--- ]       c0</span><br><span class="line">  0 [*--- ] p0</span><br><span class="line">  0 [*--- ]    c0</span><br><span class="line">  0 [*--- ] p1</span><br><span class="line">  1 [*  0 ] p4</span><br><span class="line">...</span><br><span class="line">  0 [*--- ]       c5</span><br><span class="line">  0 [*--- ]       c6</span><br><span class="line"></span><br><span class="line">Consumer consumption:</span><br><span class="line">  C0 -&gt; 5</span><br><span class="line">  C1 -&gt; 0</span><br></pre></td></tr></table></figure>
<p><img src="/2022/05/19/OS-thread-homework/image-20220516105426143.png" alt="image-20220516105426143"></p>
<p>可以看到上面蓝色框框的部分C0消费完，不是唤醒P0，而是唤醒C1。</p>
<p>但是由于它编写的调度器总会在所有程序睡眠后调用生产者进行生产。所以可以看到蓝色框框下面又出现了生产者进行生产。但是实际上如果它的调度程序不这么智慧的话，三个线程都会进入睡眠状态。</p>
<h3 id="10"><a href="#10" class="headerlink" title="10."></a>10.</h3><p><img src="/2022/05/19/OS-thread-homework/image-20220516105828890.png" alt="image-20220516105828890"></p>
<p>这个题目要我们运行<code>main-two-cvs-if.c</code>文件。这个文件对等待函数是用<code>if</code>，也就是说仅仅进行一次判定。要我们考虑一个生产者一个消费者的情况，然后增加消费者的数量。试图产生问题。</p>
<p>我们说一个生产者一个消费者是不会有任何问题的。</p>
<p>但是如果有一个消费者或者以上，那么问题就出现了。这个问题其实就是书本255页介绍的问题。就是说只是进行一次等待判断，但是在两个消费者的时候，可能一个消费者判断有货物可取，然后再在它取之前发生中断，然后另外一个消费者也看到了这个货物，然后它一口气取完了。然后前面一个消费者还蒙在鼓里，以为自己还有货物，实际上已经没有货物了。</p>
<p>所以我们在其中一个消费者的去货物之前让它睡久一点就好，可以看到到c4是去货物所以试着构造这样的字符串</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-C 0,0,0,0,5,0,0:0,0,0,0,0,0,0</span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/ostep-homework/threads-cv</span><br><span class="line">$ ./main-two-cvs-if -m 1 -l 5 -c 2 -p 1 -C 0,0,0,0,5,0,0:0,0,0,0,0,0,0 -v -t</span><br><span class="line"> NF        P0 C0 C1 </span><br><span class="line">  0 [*--- ]    c0</span><br><span class="line">  0 [*--- ] p0</span><br><span class="line">  0 [*--- ]    c1</span><br><span class="line">  0 [*--- ]       c0</span><br><span class="line">  0 [*--- ]    c2</span><br><span class="line">  0 [*--- ] p1</span><br><span class="line">  1 [*  0 ] p4</span><br><span class="line">  1 [*  0 ] p5</span><br><span class="line">  1 [*  0 ] p6</span><br><span class="line">  1 [*  0 ]       c1</span><br><span class="line">  1 [*  0 ] p0</span><br><span class="line">  0 [*--- ]       c4</span><br><span class="line">  0 [*--- ]       c5</span><br><span class="line">  0 [*--- ]       c6</span><br><span class="line">  0 [*--- ]    c3</span><br><span class="line">  0 [*--- ]       c0</span><br><span class="line">error: tried to get an empty buffer</span><br></pre></td></tr></table></figure>
<p>我们很容易就出发了这个错误。问题就是消费者2消费的速度明显更快，然后在15行的地方很快消费了货物，但是消费者1在c3的地方苏醒过来，没有再次判断是不是“假唤醒”（课本260页提示，所谓假唤醒就是唤醒你，但是你但是你没有货物），然后它认为它是有货物取得，所以在20行本来应该是消费者1进行取货c4操作，但是没有货物引起报错。</p>
<h3 id="11"><a href="#11" class="headerlink" title="11."></a>11.</h3><p><img src="/2022/05/19/OS-thread-homework/image-20220516112113947.png" alt="image-20220516112113947"></p>
<p>我们最后考察一个这样的程序<code>main-two-cvs-while-extra-unlock.c</code>。考察它会发生什么样的问题。如果你在放一个货物或者取一个货物之前就释放锁会发生什么。你可依托这一点给出一个睡眠字符串吗？分析发生了什么不好的事情。</p>
<p>和前面的代码不同的地方就在于它的生产者和消费者函数，是在释放锁之后才取资源。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">do_fill</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="comment">// ensure empty before usage</span></span><br><span class="line">    ensure(buffer[fill_ptr] == EMPTY, <span class="string">&quot;error: tried to fill a non-empty buffer&quot;</span>);</span><br><span class="line">    buffer[fill_ptr] = value;</span><br><span class="line">    fill_ptr = (fill_ptr + <span class="number">1</span>) % max;</span><br><span class="line">    num_full++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">do_get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> tmp = buffer[use_ptr];</span><br><span class="line">    ensure(tmp != EMPTY, <span class="string">&quot;error: tried to get an empty buffer&quot;</span>);</span><br><span class="line">    buffer[use_ptr] = EMPTY; </span><br><span class="line">    use_ptr = (use_ptr + <span class="number">1</span>) % max;</span><br><span class="line">    num_full--;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">producer</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="type">int</span> id = (<span class="type">int</span>) arg;</span><br><span class="line">    <span class="comment">// make sure each producer produces unique values</span></span><br><span class="line">    <span class="type">int</span> base = id * loops; </span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loops; i++) &#123;   p0;</span><br><span class="line">        Mutex_lock(&amp;m);             p1;</span><br><span class="line">        <span class="keyword">while</span> (num_full == max) &#123;   p2;</span><br><span class="line">            Cond_wait(&amp;empty, &amp;m);  p3;</span><br><span class="line">        &#125;</span><br><span class="line">        Mutex_unlock(&amp;m);</span><br><span class="line">        do_fill(base + i);          p4;</span><br><span class="line">        Mutex_lock(&amp;m);</span><br><span class="line">        Cond_signal(&amp;fill);         p5;</span><br><span class="line">        Mutex_unlock(&amp;m);           p6;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">                                                                               </span><br><span class="line"><span class="type">void</span> *<span class="title function_">consumer</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="type">int</span> id = (<span class="type">int</span>) arg;</span><br><span class="line">    <span class="type">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> consumed_count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (tmp != END_OF_STREAM) &#123; c0;</span><br><span class="line">        Mutex_lock(&amp;m);            c1;</span><br><span class="line">        <span class="keyword">while</span> (num_full == <span class="number">0</span>) &#123;    c2;</span><br><span class="line">            Cond_wait(&amp;fill, &amp;m);  c3;</span><br><span class="line">        &#125;</span><br><span class="line">        Mutex_unlock(&amp;m);</span><br><span class="line">        tmp = do_get();            c4;</span><br><span class="line">        Mutex_lock(&amp;m);</span><br><span class="line">        Cond_signal(&amp;empty);       c5;</span><br><span class="line">        Mutex_unlock(&amp;m);          c6;</span><br><span class="line">        consumed_count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// return consumer_count-1 because END_OF_STREAM does not count</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span> *) (<span class="type">long</span> <span class="type">long</span>) (consumed_count - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们的公共资源就是buffer，但是把<code>do_fill</code>和<code>do_get</code>放在锁的外面，这个锁就不起作用了。</p>
<p>如果只有一个消费者和生产者由于条件变量和full_num的共同作用，能够保证生产时消费者在睡，消费时生产者在睡。但是，如果有多个生产者和多个消费者的情况下，由于只能保证一个生产者和一个消费者互斥。所以其他的就可以对公共资源进行改写。比如在一个消费者取货物之前可能另外一个生产者覆盖了这个货物。</p>
<p><img src="/2022/05/19/OS-thread-homework/image-20220516114048979.png" alt="image-20220516114048979"></p>
<p>比如这里的2是被消费者0消费了，但是它很可能在c4消费之前，他消费的东西就被别的消费者覆盖了。</p>
<p>我们可以让c4执行慢一点，刚好让别的生产者抢占锁</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">-C 0,0,0,0,5,0,0:0,0,0,0,5,0,0</span><br></pre></td></tr></table></figure>
<h2 id="第31章"><a href="#第31章" class="headerlink" title="第31章"></a>第31章</h2><h3 id="1-3"><a href="#1-3" class="headerlink" title="1."></a>1.</h3><p><img src="/2022/05/19/OS-thread-homework/image-20220517094824131.png" alt="image-20220517094824131"></p>
<p>第一题要我们实现fork/join问题，要求自己写一个线程fork-join的程序，你要工作的是作业目录下的<code>fork-join.c</code>文件。同时在<code>child</code>添加<code>sleep(1)</code>试着确定他的正确性。</p>
<p>和课本266页一致，但是要注意几点：</p>
<ul>
<li><code>child</code>释放<code>post</code>信号量应该在孩子已经工作完的情况下</li>
<li>创建完子线程之后，主线程等待子线程完毕</li>
</ul>
<p>下面书写代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common_threads.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">sem_t</span> s; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">child</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child\n&quot;</span>);</span><br><span class="line">    sleep(<span class="number">1</span>); <span class="comment">// 验证父线程是否等待子线程完成</span></span><br><span class="line">    <span class="comment">// use semaphore here</span></span><br><span class="line">    Sem_post(&amp;s)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;parent: begin\n&quot;</span>);</span><br><span class="line">    <span class="comment">// init semaphore here</span></span><br><span class="line">    Sem_init(&amp;s, <span class="number">0</span>)</span><br><span class="line">    Pthread_create(&amp;p, <span class="literal">NULL</span>, child, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// use semaphore here</span></span><br><span class="line">    Sem_wait(&amp;s)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;parent: end\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于上述代码有几点说明：</p>
<ul>
<li>这里关于信号量的使用用的是宏定义函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> Sem_init(sem, value)                             assert(sem_init(sem, 0, value) == 0);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Sem_wait(sem)                                    assert(sem_wait(sem) == 0);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Sem_post(sem)                                    assert(sem_post(sem) == 0);</span></span><br></pre></td></tr></table></figure>
<ul>
<li>运行编译时，需要加上<code>-pthread</code>的<code>tag</code>运行结果如下</li>
</ul>
<p>​    <img src="/2022/05/19/OS-thread-homework/image-20220517114856648.png" alt="image-20220517114856648"></p>
<ul>
<li>当加入<code>sleep(1)</code>的时候同样运行正确，验证代码正确性。</li>
</ul>
<h3 id="2-3"><a href="#2-3" class="headerlink" title="2."></a>2.</h3><p><img src="/2022/05/19/OS-thread-homework/image-20220517115033332.png" alt="image-20220517115033332"></p>
<p>现在看看<code>rendezvous</code>问题。这个问题表述如下：你有两个线程，每一个线程都将要进入到<code>rendezvous</code>点执行代码。每一部分都不会在其他线程进入这个代码的时候退出，而是等待。思考使用两个信号量实现这个过程。详见<code>rendezvous.c</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common_threads.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果编写的代码正确，每一个子线程会打印各自的before信息，然后再打印各自的after信息</span></span><br><span class="line"><span class="comment">// 加入sleep(1)测试程序正确性</span></span><br><span class="line"></span><br><span class="line"><span class="type">sem_t</span> s1, s2;</span><br><span class="line"><span class="comment">// 两个信号量用于分别管理child1和child2的等待和继续</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">child_1</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child 1: before\n&quot;</span>);</span><br><span class="line">    <span class="comment">// what goes here?</span></span><br><span class="line">    Sem_wait(&amp;s1)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child 1: after\n&quot;</span>);</span><br><span class="line">    Sem_post(&amp;s2)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">child_2</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">	sleep(<span class="number">1</span>);	<span class="comment">// 先睡一会在工作</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child 2: before\n&quot;</span>);</span><br><span class="line">    <span class="comment">// what goes here?</span></span><br><span class="line">    Sem_post(&amp;s1)</span><br><span class="line">    Sem_wait(&amp;s2)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child 2: after\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> p1, p2;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;parent: begin\n&quot;</span>);</span><br><span class="line">    <span class="comment">// init semaphores here</span></span><br><span class="line">    Sem_init(&amp;s1, <span class="number">0</span>)</span><br><span class="line">    Sem_init(&amp;s2, <span class="number">0</span>)</span><br><span class="line">    Pthread_create(&amp;p1, <span class="literal">NULL</span>, child_1, <span class="literal">NULL</span>);</span><br><span class="line">    Pthread_create(&amp;p2, <span class="literal">NULL</span>, child_2, <span class="literal">NULL</span>);</span><br><span class="line">    Pthread_join(p1, <span class="literal">NULL</span>);</span><br><span class="line">    Pthread_join(p2, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;parent: end\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一点说明：这里把信号量作为条件变量使用，当条件变量发生变化，可以继续执行。可以看到如果<code>child1</code>先工作，它打印完它的before信息之后，会等待s1的讯息。然后<code>child2</code>输出它的before信息，然后它唤醒<code>child1</code>，然后自己进入睡眠等待<code>child1</code>打印它的after信息，然后<code>child1</code>打印完会唤醒<code>child2</code>，<code>child2</code>打印after讯息。最终实现次序打印。</p>
<p>结果如下：</p>
<p><img src="/2022/05/19/OS-thread-homework/image-20220517121316512.png" alt="image-20220517121316512"></p>
<h3 id="4-3"><a href="#4-3" class="headerlink" title="4."></a>4.</h3><p><img src="/2022/05/19/OS-thread-homework/image-20220517123707241.png" alt="image-20220517123707241"></p>
<p>这道题要求我们自己编写读写锁的详细代码。在这里我们不需要考虑饿死的问题。</p>
<p>代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common_threads.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Your code goes in the structure and functions below</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">rwlock_t</span> &#123;</span></span><br><span class="line">    <span class="type">sem_t</span> lock;						<span class="comment">// 二值信号量，用作基础锁，保证对readers操作的原子性</span></span><br><span class="line">    <span class="type">sem_t</span> writelock;				<span class="comment">// 写锁</span></span><br><span class="line">    <span class="type">int</span> readers;					<span class="comment">// 读者的数量</span></span><br><span class="line">&#125; <span class="type">rwlock_t</span>;</span><br><span class="line"></span><br><span class="line">			</span><br><span class="line"><span class="type">void</span> <span class="title function_">rwlock_init</span><span class="params">(<span class="type">rwlock_t</span> *rw)</span> &#123;</span><br><span class="line">    rw-&gt;readers = <span class="number">0</span>;				<span class="comment">// 读者的数量</span></span><br><span class="line">    Sem_init(&amp;rw-&gt;lock, <span class="number">1</span>)			<span class="comment">// 基础锁初始化</span></span><br><span class="line">    Sem_init(&amp;rw-&gt;writelock, <span class="number">1</span>)		<span class="comment">// 写锁初始化</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rwlock_acquire_readlock</span><span class="params">(<span class="type">rwlock_t</span> *rw)</span> &#123;</span><br><span class="line">    Sem_wait(&amp;rw-&gt;lock)</span><br><span class="line">    rw-&gt;readers++;</span><br><span class="line">    <span class="keyword">if</span> (rw-&gt;readers == <span class="number">1</span>)</span><br><span class="line">        Sem_wait(&amp;rw-&gt;writelock)</span><br><span class="line">    Sem_post(&amp;rw-&gt;lock)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rwlock_release_readlock</span><span class="params">(<span class="type">rwlock_t</span> *rw)</span> &#123;</span><br><span class="line">    Sem_wait(&amp;rw-&gt;lock)</span><br><span class="line">    rw-&gt;readers--;</span><br><span class="line">    <span class="keyword">if</span> (rw-&gt;readers == <span class="number">0</span>)</span><br><span class="line">        Sem_post(&amp;rw-&gt;writelock)</span><br><span class="line">    Sem_post(&amp;rw-&gt;lock)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rwlock_acquire_writelock</span><span class="params">(<span class="type">rwlock_t</span> *rw)</span> &#123;</span><br><span class="line">    Sem_wait(&amp;rw-&gt;writelock)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rwlock_release_writelock</span><span class="params">(<span class="type">rwlock_t</span> *rw)</span> &#123;</span><br><span class="line">    Sem_post(&amp;rw-&gt;writelock)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Don&#x27;t change the code below (just use it!)</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> loops;</span><br><span class="line"><span class="type">int</span> value = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">rwlock_t</span> lock;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">reader</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loops; i++) &#123;</span><br><span class="line">        rwlock_acquire_readlock(&amp;lock);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;read %d\n&quot;</span>, value);</span><br><span class="line">        rwlock_release_readlock(&amp;lock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">writer</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loops; i++) &#123;</span><br><span class="line">        rwlock_acquire_writelock(&amp;lock);</span><br><span class="line">        value++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;write %d\n&quot;</span>, value);</span><br><span class="line">        rwlock_release_writelock(&amp;lock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="comment">// 获取参数</span></span><br><span class="line">    assert(argc == <span class="number">4</span>);</span><br><span class="line">    <span class="type">int</span> num_readers = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="type">int</span> num_writers = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">    loops = atoi(argv[<span class="number">3</span>]);</span><br><span class="line">    <span class="comment">// 创建进程池</span></span><br><span class="line">    <span class="type">pthread_t</span> pr[num_readers], pw[num_writers];</span><br><span class="line">    <span class="comment">// 读写锁初始化</span></span><br><span class="line">    rwlock_init(&amp;lock);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;begin\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 创建所有读者和写着</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_readers; i++)</span><br><span class="line">        Pthread_create(&amp;pr[i], <span class="literal">NULL</span>, reader, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_writers; i++)</span><br><span class="line">        Pthread_create(&amp;pw[i], <span class="literal">NULL</span>, writer, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 主线程等待所有读者写者完成任务</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_readers; i++)</span><br><span class="line">        Pthread_join(pr[i], <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_writers; i++)</span><br><span class="line">        Pthread_join(pw[i], <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;end: value %d\n&quot;</span>, value);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下</p>
<p><img src="/2022/05/19/OS-thread-homework/image-20220517131624836.png" alt="image-20220517131624836"></p>
<p>存在读者饿死写着的问题。看到上面的实验结果显示只有读者全部读完了才开始写。根据代码我们也可以看出来。第一个读者获取写锁，所以任何写者都不可以写，而在第一个读者获得写锁后，其他的读者是可以获得读锁的。一旦某一个读者抢到了写锁，其他的读者都会蜂拥而入（它们不受任何阻碍）然后执行读操作。而写者呢？它们很不幸，如果它们没有任何一个读者快抢到<code>writelock</code>，则它们不能够执行写，因为<code>writelock</code>还在第一个读者手上(<code>writelock</code>移交到最后一个读者手上了才释放)，所以这些读者只能够等待几乎所有读者读完才能够进行写操作。同时还要保证在它们被最后一个读者唤醒之后没有其他读者和他们竞争，才能够安稳进行写操作。</p>
<h3 id="5-1"><a href="#5-1" class="headerlink" title="5."></a>5.</h3><p><img src="/2022/05/19/OS-thread-homework/image-20220517133750012.png" alt="image-20220517133750012"></p>
<p>现在我们要写一个没有上面描述到的饥饿问题的程序。实际上我们需要做到的是：如何能够在有写者等待的时候，避免有更多的读者进入并持有锁。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common_threads.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Your code goes in the structure and functions below</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">rwlock_t</span> &#123;</span></span><br><span class="line">    <span class="type">sem_t</span> lock;						<span class="comment">// 二值信号量，用作基础锁</span></span><br><span class="line">    								<span class="comment">// 保证对writers和readers操作的原子性</span></span><br><span class="line">    <span class="type">sem_t</span> writelock;				<span class="comment">// 写锁</span></span><br><span class="line">    <span class="type">int</span> readers;					<span class="comment">// 读者的数量</span></span><br><span class="line">    <span class="type">int</span> writers;</span><br><span class="line">&#125; <span class="type">rwlock_t</span>;</span><br><span class="line"></span><br><span class="line">			</span><br><span class="line"><span class="type">void</span> <span class="title function_">rwlock_init</span><span class="params">(<span class="type">rwlock_t</span> *rw)</span> &#123;</span><br><span class="line">    rw-&gt;readers = <span class="number">0</span>;				<span class="comment">// 读者的数量</span></span><br><span class="line">    rw-&gt;writers = <span class="number">0</span>;				<span class="comment">// 等待写的写者数量</span></span><br><span class="line">    Sem_init(&amp;rw-&gt;lock, <span class="number">1</span>)			<span class="comment">// 基础锁初始化</span></span><br><span class="line">    Sem_init(&amp;rw-&gt;writelock, <span class="number">1</span>)		<span class="comment">// 写锁初始化</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rwlock_acquire_readlock</span><span class="params">(<span class="type">rwlock_t</span> *rw)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    Sem_wait(&amp;rw-&gt;lock)</span><br><span class="line">    <span class="keyword">while</span> (rw-&gt;writers &gt; <span class="number">0</span>)			<span class="comment">// 判断是否有写者进行等待</span></span><br><span class="line">        ; <span class="comment">// spin					// 自旋等待</span></span><br><span class="line">    rw-&gt;readers++;</span><br><span class="line">    <span class="keyword">if</span> (rw-&gt;readers == <span class="number">1</span>)</span><br><span class="line">        Sem_wait(&amp;rw-&gt;writelock)</span><br><span class="line">    Sem_post(&amp;rw-&gt;lock)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rwlock_release_readlock</span><span class="params">(<span class="type">rwlock_t</span> *rw)</span> &#123;</span><br><span class="line">    Sem_wait(&amp;rw-&gt;lock)</span><br><span class="line">    rw-&gt;readers--;</span><br><span class="line">    <span class="keyword">if</span> (rw-&gt;readers == <span class="number">0</span>)</span><br><span class="line">        Sem_post(&amp;rw-&gt;writelock)</span><br><span class="line">    Sem_post(&amp;rw-&gt;lock)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rwlock_acquire_writelock</span><span class="params">(<span class="type">rwlock_t</span> *rw)</span> &#123;</span><br><span class="line">    <span class="comment">// 写者申请写锁前先将等待数目加一</span></span><br><span class="line">    Sem_wait(&amp;rw-&gt;lock)</span><br><span class="line">    rw-&gt;writers++;</span><br><span class="line">    Sem_post(&amp;rw-&gt;lock)</span><br><span class="line">    <span class="comment">// 申请写锁</span></span><br><span class="line">    Sem_wait(&amp;rw-&gt;writelock)</span><br><span class="line">    <span class="comment">// 写者获得写锁把等待数目减一</span></span><br><span class="line">    Sem_wait(&amp;rw-&gt;lock)</span><br><span class="line">    rw-&gt;writers--;</span><br><span class="line">    Sem_post(&amp;rw-&gt;lock)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rwlock_release_writelock</span><span class="params">(<span class="type">rwlock_t</span> *rw)</span> &#123;</span><br><span class="line">    Sem_post(&amp;rw-&gt;writelock)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面的代码和上面的文件没有什么区别</span></span><br></pre></td></tr></table></figure>
<p>这种策略实际上是一种写者优先的策略。由于读写锁的策略是针对多数读者少数写者的情况。这里我采用简单的自旋技术，让读者在申请锁之前总需要先判断一下是否有写者等待，如果有读者自选等待。然后在<code>rwlock_acquire_writelock</code>的代码中对<code>writers</code>的改写需要保证原子性，所以需要上锁。但是我们需要把锁的范围缩小到上面的仅对加减<code>writers</code>的操作上锁解锁。从第51行到第53行可能发生中断，使得尽管写者已经释放了锁，但是等待数目没有来得及减。但是此时所有读者仍然在等待减完才能抢占CPU。这一点在这里不用担心。</p>
<p>最后我们看一种夸张的情况，每一个读者在抢占锁之前都睡眠一秒钟。结果显示能够让写者先进行写操作。说明我们解决了饥饿的问题。</p>
<p><img src="/2022/05/19/OS-thread-homework/image-20220517145756037.png" alt="image-20220517145756037"></p>
<h3 id="6-1"><a href="#6-1" class="headerlink" title="6."></a>6.</h3><p><img src="/2022/05/19/OS-thread-homework/image-20220517145842415.png" alt="image-20220517145842415"></p>
<p>现在要用信号量实现没有饥饿问题的互斥量也就是锁。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common_threads.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Here, you have to write (almost) ALL the code. Oh no!</span></span><br><span class="line"><span class="comment">// How can you show that a thread does not starve</span></span><br><span class="line"><span class="comment">// when attempting to acquire this mutex you build?</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">ns_mutex_t</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> ticket;</span><br><span class="line">	<span class="type">int</span> turn;</span><br><span class="line">	<span class="type">sem_t</span> stic;</span><br><span class="line">	<span class="type">sem_t</span> stur;</span><br><span class="line">&#125; <span class="type">ns_mutex_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ns_mutex_init</span><span class="params">(<span class="type">ns_mutex_t</span> *m)</span> &#123;</span><br><span class="line">	Sem_init(&amp;m-&gt;stic, <span class="number">1</span>)</span><br><span class="line">	Sem_init(&amp;m-&gt;stur, <span class="number">1</span>)</span><br><span class="line">	m-&gt;ticket = <span class="number">0</span>;</span><br><span class="line">	m-&gt;turn = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ns_mutex_acquire</span><span class="params">(<span class="type">ns_mutex_t</span> *m)</span> &#123;</span><br><span class="line">	<span class="comment">// FetchAndAdd(&amp;m-&gt;stic)</span></span><br><span class="line">	Sem_wait(&amp;m-&gt;stic)</span><br><span class="line">	<span class="type">int</span> myturn = m-&gt;ticket++;</span><br><span class="line">	Sem_post(&amp;m-&gt;stic)</span><br><span class="line">    <span class="comment">// 自旋等待轮询到自己</span></span><br><span class="line">	<span class="keyword">while</span> (m-&gt;turn != myturn)</span><br><span class="line">		; <span class="comment">// spin</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ns_mutex_release</span><span class="params">(<span class="type">ns_mutex_t</span> *m)</span> &#123;</span><br><span class="line">	<span class="comment">// FetchAndAdd(&amp;m-&gt;stur)</span></span><br><span class="line">	Sem_wait(&amp;m-&gt;stur)</span><br><span class="line">	m-&gt;turn++;</span><br><span class="line">	Sem_post(&amp;m-&gt;stur)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> value = <span class="number">0</span>;</span><br><span class="line"><span class="type">ns_mutex_t</span> lock;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">worker</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">	ns_mutex_acquire(&amp;lock);</span><br><span class="line">	<span class="type">int</span> tmp = value++;</span><br><span class="line">	ns_mutex_release(&amp;lock);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;tid: %ld &gt; %d\n&quot;</span>, pthread_self(), tmp);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">	assert(argc == <span class="number">2</span>);</span><br><span class="line">	<span class="type">int</span> num_workers = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">	</span><br><span class="line">	<span class="type">pthread_t</span> pool[num_workers];</span><br><span class="line">	ns_mutex_init(&amp;lock);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;parent: begin\n&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_workers; i++)</span><br><span class="line">		Pthread_create(&amp;pool[i], <span class="literal">NULL</span>, worker, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_workers; i++)</span><br><span class="line">		Pthread_join(pool[i], <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;parent: end\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于上面的代码，我们需要的是公平性，我们可以通过学习Mellor-Crummey和Michael Scott提出来的ticket和turn的机制（课本228页）写出代码如上。主要是用了这种turn的轮询机制。通过锁的全局<code>ticket</code>和<code>turn</code>，以及每个线程申请时的<code>myturn</code>来实现公平。课本上主要使用原语<code>FetchAndAdd</code>实现对<code>lock-&gt;turn</code>和<code>lock-&gt;ticket</code>原子操作，这里我们用信号量生成的锁来实现这种原语。其实上面带有<code>FetchAndAdd</code>的注释的地方的代码相当于下面</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FetchAndAdd(sema) &#123;</span></span><br><span class="line">	Sem_wait(&amp;m-&gt;stic)			 \</span><br><span class="line">	<span class="comment">/* 某些操作 */</span>				  \</span><br><span class="line">	Sem_post(&amp;m-&gt;stic)			\</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终运行结果如下，我们可以清楚看到，每个线程都调度了，达到了相对的公平性。</p>
<p><img src="/2022/05/19/OS-thread-homework/image-20220519222752600.png" alt="image-20220519222752600"></p>
]]></content>
      <categories>
        <category>courses-learning</category>
        <category>大二下期末</category>
      </categories>
      <tags>
        <tag>ostep-homework</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP:shlab-report</title>
    <url>/2022/05/26/CSAPP-shlab-report/</url>
    <content><![CDATA[<h1 id="CSAPP-LAB4-SHELL-LAB-REPORT"><a href="#CSAPP-LAB4-SHELL-LAB-REPORT" class="headerlink" title="CSAPP-LAB4-SHELL-LAB-REPORT"></a>CSAPP-LAB4-SHELL-LAB-REPORT</h1><p>计科2002班</p>
<p>202001130329</p>
<p>杨铭</p>
<h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><p>通过这个实验能够更加深刻理解进程控制和信号控制的相关概念。本次实验我们要写一个自己的类linux/unix的shell程序，它能够支持工作的控制。</p>
<h2 id="实验平台准备"><a href="#实验平台准备" class="headerlink" title="实验平台准备"></a>实验平台准备</h2><ul>
<li>Ubuntu-32 VMfare虚拟机</li>
<li>typora编写实验报告(经授课老师许可)</li>
</ul>
<h2 id="Hand-Out-介绍"><a href="#Hand-Out-介绍" class="headerlink" title="Hand Out 介绍"></a>Hand Out 介绍</h2><p>首先解压实验文件，然后做如下工作：</p>
<ul>
<li>使用命令<code>tar xvf shlab-handout.tar</code>解压文件</li>
<li>使用命令<code>make</code>来编译和链接测试程序</li>
<li>输入(你的队员)没有队员，把你的大名写在<code>tsh.c</code>程序的顶部注释中</li>
</ul>
<p>注意到你的<code>tsh.c</code>(<em>tiny shell</em>)文件，你会看到它包含了一个简单Unix的shell的函数框架。为了简化实验，实际上题目已经帮我们实现了一些没那么有趣的函数。我们的任务就是完成剩下的空的函数。</p>
<p><strong>需要实现</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>目标函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>eval</td>
<td>主例程，用以分析和解释命令行（原型在课本8.4节）</td>
</tr>
<tr>
<td>builtin_cmd</td>
<td>执行bg和fg内置命令</td>
</tr>
<tr>
<td>waitfg</td>
<td>等待前台作业执行</td>
</tr>
<tr>
<td>sigchld_handler</td>
<td>响应处理SIGCHILD信号</td>
</tr>
<tr>
<td>sigint_handler</td>
<td>响应处理SIGINT（ctrl-c）信号</td>
</tr>
<tr>
<td>sigtstp_handler</td>
<td>响应处理SIGTP（ctrl-z）信号</td>
</tr>
</tbody>
</table>
</div>
<p>每一次修改<code>tsh.c</code>，都需要输入<code>make</code>来重编译它。运行你的<em>shell</em>，在命令行输入<code>tsh</code>如下</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">unix&gt; ./tsh</span><br><span class="line">tsh&gt; [<span class="built_in">type</span> commands to your shell here]</span><br></pre></td></tr></table></figure>
<h2 id="普通的Unix-Shells概述"><a href="#普通的Unix-Shells概述" class="headerlink" title="普通的Unix Shells概述"></a>普通的Unix Shells概述</h2><p>一个<em>shell</em>是一个对于用户层面的交互程序，它能够对用户输入的命令行进行解析。一个<em>shell</em>通常会重复输出一个标识符（通常是’prompt‘），然后等待一个命令行输入或者<code>stdin</code>标准输入。一旦它取得了命令行之后就会用它的内容进行一系列的解析工作。</p>
<p>命令行是一个有序的ASCII字符序列，它们使用空格相隔。命令行的第一个单词通常是一个<em>shell</em>的内部命令或者一个可执行文件的路径名称。剩下的单词是命令行的参数。如果第一个单词是一个命令行的内部命令，<em>shell</em>会立即在当前进程（也就是<em>shell</em>）立即执行。否则的话，它是一个可执行文件的路径。在这个情况之下<em>shell</em>通过<code>fork</code>一个子进程，然后在子进程的上下文中加载并运行程序。由于解析一个命令行而创建的子进程又被称作是<code>job</code>（作业）。总的来说，一个job是由若干子进程组成的，这些子进程通过Unix管道进行连接。</p>
<p>如果一个命令行以“&amp;”符号结尾，那么这个job就会在<em>background</em>运行该程序。也就是在后台运行这个程序，这意味着<em>shell</em>不会等待这个子进程结束后才打印下一个prompt来解析下一条命令行。因此在任何时候，最多只有一个任务能够在前台运行。然而在后台可以运行任意数目的作业。</p>
<p>例如，输入命令行</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br></pre></td></tr></table></figure>
<p>会导致<em>shell</em>执行一个内置的作业命令。输入命令如下</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">tsh&gt; /bin/ls -l -d</span><br></pre></td></tr></table></figure>
<p>来在前台运行一个<code>ls</code>程序。按照惯例，<em>shell</em>确保当程序开始执行的时候，它的主例程</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br></pre></td></tr></table></figure>
<p>这里的<code>argc</code>和<code>argv</code>拥有了如下值：</p>
<ul>
<li>argc ==  3，</li>
<li>argv[0] == “/bin/ls”,</li>
<li>argv[1] == “-l”,</li>
<li>argv[2] == “-d”.</li>
</ul>
<p>或者另一方面，我们输入命令行如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">tsh&gt; /bin/ls -l -d &amp;</span><br></pre></td></tr></table></figure>
<p>就会使得<code>ls</code>程序在后台运行。</p>
<p>Unix shells支持<code>job control</code>，它能够允许用户对将作业在前台和后台之间移动，同时也能够改变进程的状态（running, stopped, or terminated）。输入<code>ctrl-c</code>会导致产生一个SIGINT信号，它被发送到前台的每个作业。类似的，如果你输入一个<code>ctrl-z</code>会导致一个SIGTSTP信号产生，并被发送给每一个前台的工作。对于SIGTSTP的默认行为是设置一个进程为stopped状态，它会保持停止状态直到直到它收到SIGCONT信号后才被唤醒。Unix shells同样提供不同的内置命令来支持这种工作的控制。例如</p>
<ul>
<li><code>jobs</code>：列出正在运行的以及停止的的后台作业</li>
<li><code>bg &lt;job&gt;</code>：改变一个停止的后台作业为一个后台运行态作业</li>
<li><code>fg &lt;job&gt;</code>：改变一个停止或运行的后台作业为一个运行的前台作业</li>
<li><code>kill &lt;job&gt;</code>：终止一个作业</li>
</ul>
<h2 id="tsh的特点"><a href="#tsh的特点" class="headerlink" title="tsh的特点"></a>tsh的特点</h2><p>我们的<code>tsh</code>应该具备以下特点</p>
<ul>
<li>标志符prompt应该是字符串“tsh&gt;”</li>
<li>用户输入的字符串应该由一个可执行的程序或者内嵌的指令开头（<code>name</code>），然后紧跟着0个或者更若干个参数。它们由一个或者更更多的空格隔开。如果<code>name</code>是一个内置指令，tsh直接处理执行，然后等待下一条指令。否则<code>tsh</code>就会把这个<code>name</code>当成是一个可执行文件的路径，然后初始化一个子进程，然后在这个子进程的上下文中加载执行这个程序（在这种情况下，我们所说的作业通常指这个子进程）</li>
<li><code>tsh</code>不需要支持管道符（|）或者I/O的重定向（&lt;和&gt;）</li>
<li>输入ctrl-c（ctrl-z）应该导致SIGINT（SIGTSTP）信号产生然后被发送到当前的前台作业那里去，这些信号同样会被发送到这些前台进程的后代进程那里去。（例如它所派生的子进程）。如果没有任何前台进程，那么这个信号将不会有任何的效果</li>
<li>如果这个命令行是以&amp;结尾的，那么<code>tsh</code>应该让这个作业在后台运行。</li>
<li>每一个作业能够唯一的ID（PID）标识或者我们说这是一个作业ID（JID），它是一个<code>tsh</code>所分配的标识符。JIDs应该在命令行上用一个前缀’%‘来表示。例如：“%5”表示的是JID为5。（实验中提供了所有作业列表所需要的例程）</li>
<li><code>tsh</code>应该支持以下内置命令<ul>
<li><code>quit</code>命令用来终止<em>shell</em></li>
<li><code>jobs</code>用来列出所有后台作业</li>
<li><code>bg &lt;job&gt;</code>通过向<code>&lt;job&gt;</code>发送SIGCONT来重启它，然后让它运行在后台中，<code>&lt;job&gt;</code>参数可以用PID或者JID</li>
<li><code>fg &lt;job&gt;</code>命令通过发送SIGCONT信号给进程<code>&lt;job&gt;</code>，然后把它运行在前台中，<code>&lt;job&gt;</code>参数可以用PID或者JID</li>
</ul>
</li>
<li><code>tsh</code>应该回收它的所有僵尸孩子。如果任何作业因为接收到未捕获的信号而终止，则<code>tsh</code>应识别此事件并打印带有作业 PID 的消息和违规信号的描述</li>
</ul>
<h2 id="检查工作的正确性"><a href="#检查工作的正确性" class="headerlink" title="检查工作的正确性"></a>检查工作的正确性</h2><p>实验提供了一些工具来帮助我们检查工作是否正确。</p>
<p><strong>Reference solution.</strong><code>tshref</code>是一个Linux下的可执行文件为我们的<em>shell</em>提供了一个参考解决办法。运行这个程序来解决问题，看看我们的<code>tsh</code>执行的怎么样。你的<em>shell</em>应该提交输出和参考解决办法完全相同。</p>
<p><strong>Shell driver.</strong><code>sdriver.pl</code>程序将我们的<code>tsh</code>作为子进程执行，按照跟踪文件的指令向其发送命令和信号，并捕获显示<em>shell</em>的输出。使用<code>-h</code>。</p>
<p>我们有16个trace文件trace{01-16}.txt，用来和shell driver一起使用，用来测试我们的<em>shell</em>的正确性。那些数字小的trace文件做一些简单的测试，大的数字做的是更加复杂的测试。</p>
<p>可以简单通过</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">unix&gt; make test01		<span class="comment">#执行test01</span></span><br><span class="line">unix&gt; make rtest01		<span class="comment">#用reference solution(tshref)执行test01</span></span><br></pre></td></tr></table></figure>
<p>看输出结果是否一致即可。</p>
<h2 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h2><p>为了保证实验的顺利进行，首先阅读课本第八章的内容。</p>
<p>根据实验指导书，这边建议根据trace文件来进行实验，trace给出你要做的事情的提示。</p>
<h3 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * main - The shell&#x27;s main routine </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">char</span> cmdline[MAXLINE];</span><br><span class="line">    <span class="type">int</span> emit_prompt = <span class="number">1</span>; <span class="comment">/* emit prompt (default) */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Redirect stderr to stdout (so that driver will get all output</span></span><br><span class="line"><span class="comment">     * on the pipe connected to stdout) */</span></span><br><span class="line">    dup2(<span class="number">1</span>, <span class="number">2</span>);	<span class="comment">// 把错误信息重定向到标准输出上，也就是输出到屏幕上</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Parse the command line */</span></span><br><span class="line">    <span class="comment">// 处理参数</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * -h 帮助文件</span></span><br><span class="line"><span class="comment">    * -v 发送额外的诊断信息</span></span><br><span class="line"><span class="comment">    * -p 不打印prompt</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">while</span> ((c = getopt(argc, argv, <span class="string">&quot;hvp&quot;</span>)) != EOF) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:             <span class="comment">/* print help message */</span></span><br><span class="line">            usage();</span><br><span class="line">	    <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;v&#x27;</span>:             <span class="comment">/* emit additional diagnostic info */</span></span><br><span class="line">            verbose = <span class="number">1</span>;</span><br><span class="line">	    <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;p&#x27;</span>:             <span class="comment">/* don&#x27;t print a prompt */</span></span><br><span class="line">            emit_prompt = <span class="number">0</span>;  <span class="comment">/* handy for automatic testing */</span></span><br><span class="line">	    <span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">            usage();</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Install the signal handlers */</span></span><br><span class="line">	<span class="comment">// 对各种信号进行处理</span></span><br><span class="line">    <span class="comment">/* These are the ones you will need to implement */</span></span><br><span class="line">    Signal(SIGINT,  sigint_handler);   <span class="comment">/* ctrl-c */</span></span><br><span class="line">    Signal(SIGTSTP, sigtstp_handler);  <span class="comment">/* ctrl-z */</span></span><br><span class="line">    Signal(SIGCHLD, sigchld_handler);  <span class="comment">/* Terminated or stopped child */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This one provides a clean way to kill the shell */</span></span><br><span class="line">    Signal(SIGQUIT, sigquit_handler); </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initialize the job list */</span></span><br><span class="line">    <span class="comment">// 初始化作业列表</span></span><br><span class="line">    initjobs(jobs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Execute the shell&#x27;s read/eval loop */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Read command line */</span></span><br><span class="line">    <span class="comment">// 打印一个prompt符</span></span><br><span class="line">	<span class="keyword">if</span> (emit_prompt) &#123;</span><br><span class="line">	    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, prompt);</span><br><span class="line">	    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 从标准获得命令行</span></span><br><span class="line">	<span class="keyword">if</span> ((fgets(cmdline, MAXLINE, <span class="built_in">stdin</span>) == <span class="literal">NULL</span>) &amp;&amp; ferror(<span class="built_in">stdin</span>))</span><br><span class="line">	    app_error(<span class="string">&quot;fgets error&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// EOF: 当输入ctrl-d的时候表示标准输入(文件)结束，此时直接退出</span></span><br><span class="line">	<span class="keyword">if</span> (feof(<span class="built_in">stdin</span>)) &#123; <span class="comment">/* End of file (ctrl-d) */</span></span><br><span class="line">	    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">	    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Evaluate the command line */</span></span><br><span class="line">	eval(cmdline);		<span class="comment">// 解析命令行</span></span><br><span class="line">	fflush(<span class="built_in">stdout</span>);</span><br><span class="line">	fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">/* control never reaches here */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码我们可以看出，<code>main</code>函数的主要工作就是从标准输出中读出命令行，然后把它交给<code>eval</code>来处理。</p>
<p>参考CSAPP官方网站上给出阉割版本的<em>shell.c</em>，我们可以看到eval主要工作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * eval - evaluate a command line</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">eval</span><span class="params">(<span class="type">char</span> *cmdline)</span> </span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">	<span class="comment">// 通过把argv传递给buildin_command让它判断是不是内置命令并执行</span></span><br><span class="line">    <span class="comment">// 如果不是返回零</span></span><br><span class="line">    <span class="keyword">if</span> (!builtin_command(argv)) &#123; </span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">* buildin_cmd</span></span><br><span class="line"><span class="comment">*/</span>  </span><br><span class="line"><span class="type">int</span> <span class="title function_">builtin_cmd</span><span class="params">(<span class="type">char</span> **argv)</span> </span><br><span class="line">&#123;</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>
<p>我们理清楚主要执行流程如下</p>
<p><img src="/2022/05/26/CSAPP-shlab-report/image-20220525154122346.png" alt="image-20220525154122346"></p>
<h3 id="test01"><a href="#test01" class="headerlink" title="test01"></a>test01</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest01</span><br><span class="line">./sdriver.pl -t trace01.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace01.txt - Properly terminate on EOF.</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure>
<p>我们参考第一个<code>test</code>，对<code>tshref</code>输出了如上结果。这个对于标准输入结束（EOF）的处理。实际上就是对ctrl-d的处理。我们观察到上面<code>main</code>函数中已经有包含对EOF的处理</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// EOF: 当输入ctrl-d的时候表示标准输入(文件)结束，此时直接退出</span></span><br><span class="line">	<span class="keyword">if</span> (feof(<span class="built_in">stdin</span>)) &#123; <span class="comment">/* End of file (ctrl-d) */</span></span><br><span class="line">	    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">	    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>因此我们不许要做什么，可以看到测试结果和参考一致。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make test01</span><br><span class="line">./sdriver.pl -t trace01.txt -s ./tsh -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace01.txt - Properly terminate on EOF.</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure>
<h3 id="test02"><a href="#test02" class="headerlink" title="test02"></a>test02</h3><p>这个一个明显需要做些什么。（不可能又帮你写好）</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest02</span><br><span class="line">./sdriver.pl -t trace02.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace02.txt - Process builtin quit command.</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure>
<p>这个测试要求我们完成对<code>tsh</code>的一条内嵌指令（quit）的处理。它完成的任务就是退出<code>tsh</code>。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ ./tsh</span><br><span class="line">tsh&gt; quit</span><br><span class="line">tsh&gt; </span><br></pre></td></tr></table></figure>
<p>我们可以看到如果什么都不做，是不能够退出的。</p>
<p>现在对这个<code>quit</code>指令的位置有两种思考方向。根据上面<code>main</code>的执行流程，我们说有两个后续处理的方向，一个就是放在eval里面处理，一个就是放在<code>buildin_cmd</code>里面。后者很好理解，这个<code>quit</code>本来就是内嵌指令，所以可以放在后者里面。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">builtin_cmd</span><span class="params">(<span class="type">char</span> **argv)</span>;</span><br></pre></td></tr></table></figure>
<p>可以看到<code>buildin_cmd</code>虽然是对内置指令的处理，这样一条<code>quit</code>非常简单，只要读到这条指令，直接<code>exit(0)</code>，就是它的全部逻辑了。</p>
<p>首先用到<code>parseline</code>来解析命令行，并建立<code>argv</code>，我们可以看到<code>parseline</code>函数的说明如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * parseline - Parse the command line and build the argv array.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Characters enclosed in single quotes are treated as a single</span></span><br><span class="line"><span class="comment"> * argument.  Return true if the user has requested a BG job, false if</span></span><br><span class="line"><span class="comment"> * the user has requested a FG job.  </span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>这个函数主要主要功能就是解析命令行字符串，然后建立<code>argv</code>参数数组，用来给后面execve使用等。</p>
<p>所以代码实现起来就是如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">eval</span><span class="params">(<span class="type">char</span> *cmdline)</span> </span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">// 参数字符串数组</span></span><br><span class="line">	<span class="type">char</span> *argv[MAXARGS]; <span class="comment">/* argv for execve() */</span></span><br><span class="line">	<span class="type">int</span> bg;              <span class="comment">/* should the job run in bg or fg? */</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* parse command line */</span></span><br><span class="line">    <span class="comment">// 解析cmdline获得argv</span></span><br><span class="line">    bg = parseline(cmdline, argv); </span><br><span class="line">	<span class="keyword">if</span> (!builtin_cmd(argv)) &#123; </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * builtin_cmd - If the user has typed a built-in command then execute</span></span><br><span class="line"><span class="comment"> *    it immediately.  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">builtin_cmd</span><span class="params">(<span class="type">char</span> **argv)</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;quit&quot;</span>))</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);  <span class="comment">/* terminate shell */</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>然后我们<code>make</code>编译以下，查看测试情况，</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make test02</span><br><span class="line">./sdriver.pl -t trace02.txt -s ./tsh -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace02.txt - Process builtin quit command.</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure>
<p>和参考一样，通关~</p>
<h3 id="test03-amp-test04"><a href="#test03-amp-test04" class="headerlink" title="test03 &amp; test04"></a>test03 &amp; test04</h3><p>测试3和测试4的内容放在一起讲好了，因为</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest03</span><br><span class="line">./sdriver.pl -t trace03.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace03.txt - Run a foreground job.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; quit</span><br><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest04</span><br><span class="line">./sdriver.pl -t trace04.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace04.txt - Run a background job.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./myspin 1 &amp;</span><br><span class="line">[1] (9950) ./myspin 1 &amp;</span><br></pre></td></tr></table></figure>
<p>可以看到参考程序中，对于测试3，它测试了前台运行<code>quit</code>，测试4在后台运行了<code>myspin</code>，<code>myspin</code>是自旋等待了1秒。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in `parseline`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* should the job run in the background? */</span></span><br><span class="line">    <span class="keyword">if</span> ((bg = (*argv[argc<span class="number">-1</span>] == <span class="string">&#x27;&amp;&#x27;</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">	argv[--argc] = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在<code>parseline</code>通过上面的步骤解析判断了是否需要讲进程运行在后台。主要是通过检索命令行末尾的字符是否是‘&amp;’</p>
<p><strong>前台工作需要等待工作执行完毕就好了。不论是前台还是后台程序，都需要加入到jobs</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* global variables */</span></span><br><span class="line"><span class="type">int</span> nextjid = <span class="number">1</span>;            <span class="comment">/* next job ID to allocate */</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">/* addjob - Add a job to the job list */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">addjob</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span> *jobs, <span class="type">pid_t</span> pid, <span class="type">int</span> state, <span class="type">char</span> *cmdline)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">1</span>)	<span class="comment">// 无效pid</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++) &#123;	</span><br><span class="line">        <span class="comment">/* 如果jobs数组里面有pid等于0等于0的表项，表示这个位置可以用，把这个作业放进去 */</span></span><br><span class="line">        <span class="keyword">if</span> (jobs[i].pid == <span class="number">0</span>) &#123;</span><br><span class="line">            jobs[i].pid = pid;</span><br><span class="line">            jobs[i].state = state;</span><br><span class="line">            jobs[i].jid = nextjid++;</span><br><span class="line">            <span class="keyword">if</span> (nextjid &gt; MAXJOBS)</span><br><span class="line">                nextjid = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">strcpy</span>(jobs[i].cmdline, cmdline);</span><br><span class="line">            <span class="keyword">if</span>(verbose)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Added job [%d] %d %s\n&quot;</span>, jobs[i].jid, jobs[i].pid, jobs[i].cmdline);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Tried to create too many jobs\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>addjob</code>的工作就是为PID为pid的子进程分配一个jid，然后把jid保存在进程结构中,然后根据全局变量JID来给这个子进程为<code>tsh</code>编写这个子进程的JID。通过是为了防止JID越界的情况，需要额外对的<code>nextjid</code>进行判断。我们对此更加加深了对jid的理解。jid就是现在一共有几个job在<code>tsh</code>下面运行。由于<code>jobs</code>数组是有限的，所以jid超过了MAXJOBS的话是需要重置的。如果发生这种事情的话，只有当一个作业结束，<code>jobs</code>才能让出位置来，这是后才可以再分配工作。值得一提的是，根据课本<em>shell.c</em>的代码，我们可以在这里加一个，如果<code>verbose</code>有效的话，打印详细信息（加入的作业是啥）</p>
<p>我们还需要等待前台运行的子进程运行完，所以我们还要解决<code>waitfg</code>函数的问题。这个函数是需要我们自己编写的。主要功能就是阻塞当前进程也就是<code>tsh</code>，直到我们pid命名的子进程结束。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* fgpid - Return PID of current foreground job, 0 if no such job */</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fgpid</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span> *jobs)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++)</span><br><span class="line">	<span class="keyword">if</span> (jobs[i].state == FG)</span><br><span class="line">	    <span class="keyword">return</span> jobs[i].pid;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这个函数就是循环查看当前前台工作的作业的pid是多少。知道了这个我们就可以写<code>waitfg</code>函数了。当<code>pid</code>对应的进程还是前台进程的时候就一直循环等待。指导书里面说可以用循环<code>sleep(0)</code>进行等待。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">waitfg</span><span class="params">(<span class="type">pid_t</span> pid)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (pid == fgpid(jobs))</span><br><span class="line">        sleep(<span class="number">0</span>); <span class="comment">// 这里是指主动让出CPU的意思</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具备上面的基础，我们可以写出代码如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in `eval`</span></span><br><span class="line">...  </span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> (!builtin_cmd(argv)) &#123; </span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) == <span class="number">0</span>) &#123;  <span class="comment">/* child */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Background jobs should ignore SIGINT (ctrl-c)  */</span></span><br><span class="line">        <span class="comment">/* and SIGTSTP (ctrl-z) */</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        if (bg) &#123;</span></span><br><span class="line"><span class="comment">            // 课本对SIG_IGN有详细解释</span></span><br><span class="line"><span class="comment">            // 如果信号的handler是SIG_IGN，会忽略这个信号</span></span><br><span class="line"><span class="comment">            Signal(SIGINT, SIG_IGN);</span></span><br><span class="line"><span class="comment">            Signal(SIGTSTP, SIG_IGN);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        </span><br><span class="line">		<span class="comment">// 前台执行</span></span><br><span class="line">        <span class="keyword">if</span> (execve(argv[<span class="number">0</span>], argv, environ) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s: Command not found.\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">            fflush(<span class="built_in">stdout</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">// 如果没有这个可执行程序，那么直接终止这个子进程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* parent waits for foreground job to terminate or stop */</span></span><br><span class="line">    addjob(jobs, pid, (bg == <span class="number">1</span> ? BG : FG), cmdline);</span><br><span class="line">    <span class="keyword">if</span> (!bg) <span class="comment">// 前台运行则等待子进程</span></span><br><span class="line">        waitfg(pid);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%d] (%d) %s&quot;</span>, pid2jid(pid), pid, cmdline);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到上面的函数<code>fork</code>出一个子进程，然后<code>execve</code>执行某个可执行程序。对于父进程，父进程把这个进程添加到jobs队列中去。然后如果这是一个前台程序，就调用<code>waitfg</code>等待子进程结束。如果子进程结束了。通过SIGCHLD信号给父进程发信息，唤醒父进程回收自己。</p>
<p>父进程回收处理程序如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * sigchld_handler - The kernel sends a SIGCHLD to the shell whenever</span></span><br><span class="line"><span class="comment"> *     a child job terminates (becomes a zombie), or stops because it</span></span><br><span class="line"><span class="comment"> *     received a SIGSTOP or SIGTSTP signal. The handler reaps all</span></span><br><span class="line"><span class="comment"> *     available zombie children, but doesn&#x27;t wait for any other</span></span><br><span class="line"><span class="comment"> *     currently running children to terminate.  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sigchld_handler</span><span class="params">(<span class="type">int</span> sig)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (verbose)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sigchld_handler: entering \n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    * 回收僵尸进程</span></span><br><span class="line"><span class="comment">    * 这里的WNOHANG是非常重要的。</span></span><br><span class="line"><span class="comment">    * 它的本意是如果所有孩子都没有僵尸(终止)状态的，直接退出</span></span><br><span class="line"><span class="comment">    * 这个能够避免在这里等待所有前台的running和stopped程序终止</span></span><br><span class="line"><span class="comment">    * 这样tsh就不能正常接受用户的输入了</span></span><br><span class="line"><span class="comment">    * WUNTRACED是等待直到有一个子进程变成僵尸退出，返回它的pid</span></span><br><span class="line"><span class="comment">    * 这个选项开启能够检查已终止和被停止的子进程</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">while</span> ((pid = waitpid(<span class="number">-1</span>, &amp;status, WNOHANG | WUNTRACED)) &gt; <span class="number">0</span>) &#123; </span><br><span class="line">        <span class="comment">// 这里不管是不是正常exit或者ctrl-c或者ctrl-z退出的</span></span><br><span class="line">        <span class="comment">// 子进程都结束了，都要回收资源</span></span><br><span class="line">        deletejob(jobs, pid);</span><br><span class="line">        <span class="keyword">if</span> (verbose)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;sigchld_handler: job %d deleted\n&quot;</span>, pid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (verbose)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sigchld_handler: exiting\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>像上面这样写看起来是没有什么问题了。但是课本519中提示了一种苛刻同步问题。如果子进程在父进程将自己加入到<code>jobs</code>之前就执行完毕，然后<code>exit</code>退出，就会触发父进程的回收<code>sigchld_handler</code>程序，实际上，这样的删除显然没有任何意义。后续又将这个工作<code>addjob</code>，这也是没有什么意义的。</p>
<p>因此我们还要对上面的<code>eval</code>进一步修改为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in `eval`</span></span><br><span class="line">...   </span><br><span class="line"><span class="type">sigset_t</span> mask;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> (!builtin_cmd(argv)) &#123;</span><br><span class="line">        Sigprocmask(SIG_BLOCK, &amp;mask, &amp;prev);  <span class="comment">/* 阻塞SIGCHLD */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((pid = fork()) == <span class="number">0</span>) &#123;   <span class="comment">/* Child runs user job */</span></span><br><span class="line">            <span class="comment">/* 给fork出来的子进程设置一个独立的组，</span></span><br><span class="line"><span class="comment">	 		 * 子进程是这个组的组长,组id为子进程的pid */</span></span><br><span class="line">            setpgid(<span class="number">0</span>, <span class="number">0</span>);	</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/* 对于子进程并不需要阻塞SIGCHLD的信号 */</span></span><br><span class="line">            Sigprocmask(SIG_UNBLOCK, &amp;prev, <span class="literal">NULL</span>);  <span class="comment">// unblock SIGCHLD</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">/* </span></span><br><span class="line"><span class="comment">            * 前台执行 </span></span><br><span class="line"><span class="comment">            * 如果没有这个可执行程序，那么直接终止这个子进程</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">if</span> (execve(argv[<span class="number">0</span>], argv, environ) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s: Command not found.\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">                _exit(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        addjob(jobs, pid, bg ? BG : FG, cmdline);</span><br><span class="line">        <span class="comment">/* 已经加到jobs了，解除阻塞 */</span></span><br><span class="line">        Sigprocmask(SIG_SETMASK, &amp;prev, <span class="literal">NULL</span>);  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Parent waits for foreground job to terminate */</span></span><br><span class="line">        <span class="keyword">if</span> (!bg)  <span class="comment">// 前台运行则等待子进程</span></span><br><span class="line">            waitfg(pid);</span><br><span class="line">        <span class="keyword">else</span>      <span class="comment">// background</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[%d] (%d) %s&quot;</span>, pid2jid(pid), pid, cmdline);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>测试以下我们的代码的正确性</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest03</span><br><span class="line">./sdriver.pl -t trace03.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace03.txt - Run a foreground job.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; quit</span><br><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make test03</span><br><span class="line">./sdriver.pl -t trace03.txt -s ./tsh -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace03.txt - Run a foreground job.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; quit</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest04</span><br><span class="line">./sdriver.pl -t trace04.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace04.txt - Run a background job.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./myspin 1 &amp;</span><br><span class="line">[1] (10488) ./myspin 1 &amp;</span><br><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make test04</span><br><span class="line">./sdriver.pl -t trace04.txt -s ./tsh -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace04.txt - Run a background job.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./myspin 1 &amp;</span><br><span class="line">[1] (10494) ./myspin 1 &amp;</span><br></pre></td></tr></table></figure>
<p>测试程序都相同了，成功~</p>
<h3 id="test05"><a href="#test05" class="headerlink" title="test05"></a>test05</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest05</span><br><span class="line">./sdriver.pl -t trace05.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace05.txt - Process jobs builtin command.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./myspin 2 &amp;</span><br><span class="line">[1] (10504) ./myspin 2 &amp;</span><br><span class="line">tsh&gt; ./myspin 3 &amp;</span><br><span class="line">[2] (10506) ./myspin 3 &amp;</span><br><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br><span class="line">[1] (10504) Running ./myspin 2 &amp;</span><br><span class="line">[2] (10506) Running ./myspin 3 &amp;</span><br></pre></td></tr></table></figure>
<p>这里的任务是完成内嵌指令<code>jobs</code>的工作。它能够列出作业列表中的所有作业。</p>
<p>这个很简单，起始只要用一个<code>listjobs</code>就可已完成这个工作了，这个函数是实验已经帮我们实现了的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* listjobs - Print the job list */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">listjobs</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span> *jobs)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (jobs[i].pid != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[%d] (%d) &quot;</span>, jobs[i].jid, jobs[i].pid);</span><br><span class="line">            <span class="keyword">switch</span> (jobs[i].state) &#123;</span><br><span class="line">                <span class="keyword">case</span> BG: </span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Running &quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> FG: </span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Foreground &quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> ST: </span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Stopped &quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;listjobs: Internal error: job[%d].state=%d &quot;</span>, </span><br><span class="line">                           i, jobs[i].state);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, jobs[i].cmdline);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在<code>builtin_cmd</code>中加入<code>jobs</code>命令的入口就好。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">builtin_cmd</span><span class="params">(<span class="type">char</span> **argv)</span> </span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// jobs command    </span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;jobs&quot;</span>)) &#123;        </span><br><span class="line">        listjobs(jobs);        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>我们看看测试结果</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest05</span><br><span class="line">./sdriver.pl -t trace05.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace05.txt - Process jobs builtin command.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./myspin 2 &amp;</span><br><span class="line">[1] (10613) ./myspin 2 &amp;</span><br><span class="line">tsh&gt; ./myspin 3 &amp;</span><br><span class="line">[2] (10615) ./myspin 3 &amp;</span><br><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br><span class="line">[1] (10613) Running ./myspin 2 &amp;</span><br><span class="line">[2] (10615) Running ./myspin 3 &amp;</span><br><span class="line"></span><br><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make test05</span><br><span class="line">./sdriver.pl -t trace05.txt -s ./tsh -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace05.txt - Process jobs builtin command.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./myspin 2 &amp;</span><br><span class="line">[1] (10622) ./myspin 2 &amp;</span><br><span class="line">tsh&gt; ./myspin 3 &amp;</span><br><span class="line">[2] (10624) ./myspin 3 &amp;</span><br><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br><span class="line">[1] (10622) Running ./myspin 2 &amp;</span><br><span class="line">[2] (10624) Running ./myspin 3 &amp;</span><br></pre></td></tr></table></figure>
<p>和参考一致，表示正确。这里你可能会被英文的实验指导书迷惑了，实际上列出的是工作列表的所有工作，而不是后台的所有工作。通关~</p>
<h3 id="test06-amp-test07-amp-test08"><a href="#test06-amp-test07-amp-test08" class="headerlink" title="test06 &amp; test07 &amp; test08"></a>test06 &amp; test07 &amp; test08</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest06</span><br><span class="line">./sdriver.pl -t trace06.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace06.txt - Forward SIGINT to foreground job.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./myspin 4</span><br><span class="line">Job [1] (10840) terminated by signal 2</span><br><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest07</span><br><span class="line">./sdriver.pl -t trace07.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace07.txt - Forward SIGINT only to foreground job.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./myspin 4 &amp;</span><br><span class="line">[1] (10846) ./myspin 4 &amp;</span><br><span class="line">tsh&gt; ./myspin 5</span><br><span class="line">Job [2] (10848) terminated by signal 2</span><br><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br><span class="line">[1] (10846) Running ./myspin 4 &amp;</span><br><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest08</span><br><span class="line">./sdriver.pl -t trace08.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace08.txt - Forward SIGTSTP only to foreground job.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./myspin 4 &amp;</span><br><span class="line">[1] (10856) ./myspin 4 &amp;</span><br><span class="line">tsh&gt; ./myspin 5</span><br><span class="line">Job [2] (10858) stopped by signal 20</span><br><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br><span class="line">[1] (10856) Running ./myspin 4 &amp;</span><br><span class="line">[2] (10858) Stopped ./myspin 5 </span><br></pre></td></tr></table></figure>
<p>测试678要完成的任务是对于SIGINT和SIGTSTP的处理。对于上面的测试，测试6启动一个自旋程序到前台并且发出SIGINT终止它。测试7启动两个自旋，一个在前台一个在后台，然后发出SIGINT，检测到只有前台进程被终止了。测试8类似。</p>
<p><img src="/2022/05/26/CSAPP-shlab-report/image-20220526003548830.png" alt="image-20220526003548830" style="zoom:67%;"></p>
<p>我们可以从课本上这幅图看到shell会给每一个子进程分配一个和PID一样的组id，这些shell的子进程的孩子都在这些子进程的组内。比如上图中的前台作业就是shell产生的子进程，但是它和shell不是一个组的，他自己独立成组，组id等于自己的pid，然后它的孩子都属于自己这个组。</p>
<p>首先需要完成SIGINT的处理，给前台进程的组的所有进程发送SIGINT信号(这里就是参数sig)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sigint_handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 这一步的保存和下一步的恢复，是由于在下面的kill系统调用中可能会覆盖errno的值</span></span><br><span class="line">    <span class="comment">// 导致现在的errno丢失</span></span><br><span class="line">    <span class="comment">// 而errno在sigchild_handler中还有使用到，为了避免产生这种错误需要在这里保存，在后面恢复</span></span><br><span class="line">    <span class="type">int</span> olderrno = errno;</span><br><span class="line">    <span class="comment">// get the foreground job pid</span></span><br><span class="line">    <span class="type">pid_t</span> fg_pid = fgpid(jobs);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * int kill(pid_t pid,int signo)</span></span><br><span class="line"><span class="comment"> 	* 功能: 向进程或进程组发送一个信号 （成功返回 0； 否则，返回 -1 ）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    kill(-fg_pid, sig); </span><br><span class="line">    <span class="comment">// -fg_pid表示向进程组号为pid的组中的每个进程发sig信号</span></span><br><span class="line">    <span class="comment">// 在这里就是向前台进程以及它的每一个子进程(子进程都在自己的父进程的pid为组id的组下)</span></span><br><span class="line">    errno = olderrno;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相同的原理，可以写出<code>sigtstp_handler</code>函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sigtstp_handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 为了异步信号安全防止errno被覆盖</span></span><br><span class="line">    <span class="type">int</span> olderrno = errno;</span><br><span class="line">    <span class="comment">// get the foreground job pid</span></span><br><span class="line">    <span class="type">pid_t</span> fg_pid = fgpid(jobs);</span><br><span class="line">    <span class="comment">// kill the group in the foreground</span></span><br><span class="line">    kill(-fg_pid, sig);</span><br><span class="line">    errno = olderrno;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的两个函数就是信号处理过程。<code>sigchld_handler</code>里收到子进程终止或停止的消息后给出对应的输出然后改变其状态，对于终止的进程就在jobs里将其删除，对于停止的进程则设置其state为ST。</p>
<p><img src="/2022/05/26/CSAPP-shlab-report/image-20220526081536379.png" alt="image-20220526081536379" style="zoom:80%;"></p>
<p>主要流程如上图。</p>
<p>然后就是对<code>sigchld_handler</code>的修改。我们需要针对上面的代码进一步进行修改。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sigchld_handler - The kernel sends a SIGCHLD to the shell whenever</span></span><br><span class="line"><span class="comment"> *     a child job terminates (becomes a zombie), or stops because it</span></span><br><span class="line"><span class="comment"> *     received a SIGSTOP or SIGTSTP signal. The handler reaps all</span></span><br><span class="line"><span class="comment"> *     available zombie children, but doesn&#x27;t wait for any other</span></span><br><span class="line"><span class="comment"> *     currently running children to terminate.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sigchld_handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> old_errno = errno;</span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (verbose)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sigchld_handler: entering \n&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* </span></span><br><span class="line"><span class="comment">    * 回收僵尸进程</span></span><br><span class="line"><span class="comment">    * 这里的WNOHANG是非常重要的。</span></span><br><span class="line"><span class="comment">    * 它的本意是如果所有孩子都没有僵尸(终止)状态的，直接退出</span></span><br><span class="line"><span class="comment">    * 这个能够避免在这里等待所有前台的running和stopped程序终止</span></span><br><span class="line"><span class="comment">    * 这样tsh就不能正常接受用户的输入了</span></span><br><span class="line"><span class="comment">    * WUNTRACED是等待直到有一个子进程变成僵尸退出，返回它的pid</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">while</span> ((pid = waitpid(<span class="number">-1</span>, &amp;status, WNOHANG | WUNTRACED)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* 这里实验指导书说不能用while，但是不用会出现错误。他说的while和我的判断条件不一样 */</span></span><br><span class="line">        <span class="comment">// 子进程正常退出</span></span><br><span class="line">        <span class="keyword">if</span> (WIFEXITED(status)) &#123;</span><br><span class="line">            deletejob(jobs, pid);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 子进程因为ctrl-c退出</span></span><br><span class="line">        <span class="keyword">if</span> (WIFSIGNALED(status)) &#123; <span class="comment">// terminated by ctrl-c</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Job [%d] (%d) terminated by signal %2d\n&quot;</span>, </span><br><span class="line">                   pid2jid(pid), pid, WTERMSIG(status));</span><br><span class="line">            deletejob(jobs, pid); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (WIFSTOPPED(status)) &#123; <span class="comment">// stopped by ctrl-z</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Job [%d] (%d) stopped by signal %2d\n&quot;</span>,</span><br><span class="line">                   pid2jid(pid), pid, WSTOPSIG(status));</span><br><span class="line">            <span class="comment">// 修改子进程状态为ST</span></span><br><span class="line">            getjobpid(jobs, pid)-&gt;state = ST;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    errno = old_errno;</span><br><span class="line">    <span class="keyword">if</span> (verbose) </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sigchld_handler: exiting\n&quot;</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的程序，在子进程发送SIGCHLD时处于不同状态的子进程，已经有了不同的处理。</p>
<p>但是还存在一个问题，就是<code>printf</code>是异步不安全的。可能出现死锁现象。</p>
<p><strong>死锁（Deadlock）：</strong>当你存在多个逻辑流在等待永远不会发生的场景时就会出现死锁。比如在信号处理程序中使用异步信号不安全的<code>printf</code>函数就可能会出现死锁现象。在主程序中执行了<code>printf</code>函数，则该函数会请求某些资源的一个锁，当该<code>printf</code>函数请求这个锁时它被某个信号处理程序中断了，而在信号处理程序中也要执行一个<code>printf</code>函数，这个<code>printf</code>也试图请求那个锁，但是由于主程序中的<code>printf</code>函数持有那个锁，所以信号处理程序中的<code>printf</code>得不到那个锁，所以这个<code>printf</code>就在等待那个锁被释放的锁，但是主程序只有在信号处理程序返回时才可能释放那个锁，所以这里就造成了死锁。</p>
<p>这里是线程安全但是不可重入的异步安全问题，使用锁是不能够解决的。</p>
<p>所以我们再主线程也就是<code>main</code>里面已经使用过<code>printf</code>了，就要避免在信号处理程序中在使用<code>printf</code>的出现。</p>
<p>我提供下面两种解决手段。</p>
<ul>
<li>一种想法是在这里使用<code>printf</code>的时候屏蔽或者说阻塞SIGCHLD信号，这样主线程在使用<code>printf</code>就不会被中断。但是带来的问题就是这个中断处理信号会被忽略。可能出现处理遗漏的情况。</li>
<li>还有一种处理手段是使用异步信号安全的可重入函数，如下</li>
</ul>
<blockquote>
<p>CSAPP课本实例程序提供了一种线程安全且可重入的函数sio系列函数，使用它，不调用<code>printf</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* private functions */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sio_reverse</span><span class="params">(<span class="type">char</span> s[])</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sio_ltoa</span><span class="params">(<span class="type">long</span> v, <span class="type">char</span> s[], <span class="type">int</span> b)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">size_t</span> <span class="title function_">sio_strlen</span><span class="params">(<span class="type">char</span> s[])</span>;</span><br><span class="line"><span class="comment">/* public functions */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sio_puts</span><span class="params">(<span class="type">char</span> s[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sio_putl</span><span class="params">(<span class="type">long</span> v)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sio_error</span><span class="params">(<span class="type">char</span> s[])</span>;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>查看Linux手册可以知道<code>write</code>是异步信号安全的，使用<code>write</code>就可以实现异步安全的输出了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sio_puts</span><span class="params">(<span class="type">char</span> s[])</span> <span class="comment">/* Put string */</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> write(STDOUT_FILENO, s, <span class="built_in">strlen</span>(s));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我对上面的sio族进行封装形成Sio系列。</p>
<p>我们把<code>sigchld_handler</code>修改以下如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sigchld_handler - The kernel sends a SIGCHLD to the shell whenever</span></span><br><span class="line"><span class="comment"> *     a child job terminates (becomes a zombie), or stops because it</span></span><br><span class="line"><span class="comment"> *     received a SIGSTOP or SIGTSTP signal. The handler reaps all</span></span><br><span class="line"><span class="comment"> *     available zombie children, but doesn&#x27;t wait for any other</span></span><br><span class="line"><span class="comment"> *     currently running children to terminate.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sigchld_handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> old_errno = errno;</span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (verbose)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sigchld_handler: entering \n&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* </span></span><br><span class="line"><span class="comment">    * 回收僵尸进程</span></span><br><span class="line"><span class="comment">    * 这里的WNOHANG是非常重要的。</span></span><br><span class="line"><span class="comment">    * 它的本意是如果所有孩子都没有僵尸(终止)状态的，直接退出</span></span><br><span class="line"><span class="comment">    * 这个能够避免在这里等待所有前台的running和stopped程序终止</span></span><br><span class="line"><span class="comment">    * 这样tsh就不能正常接受用户的输入了</span></span><br><span class="line"><span class="comment">    * WUNTRACED是等待直到有一个子进程变成僵尸退出，返回它的pid</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">while</span> ((pid = waitpid(<span class="number">-1</span>, &amp;status, WNOHANG | WUNTRACED)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程正常退出</span></span><br><span class="line">        <span class="keyword">if</span> (WIFEXITED(status)) &#123;</span><br><span class="line">            deletejob(jobs, pid);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 子进程因为ctrl-c退出</span></span><br><span class="line">        <span class="keyword">if</span> (WIFSIGNALED(status)) &#123; <span class="comment">// terminated by ctrl-c</span></span><br><span class="line">            <span class="comment">/* printf(&quot;Job [%d] (%d) terminated by signal %2d\n&quot;, </span></span><br><span class="line"><span class="comment">                   pid2jid(pid), pid, WTERMSIG(status)); */</span> &#123;</span><br><span class="line">            	Sio_puts(<span class="string">&quot;Job [&quot;</span>);</span><br><span class="line">                Sio_putl(pid2jid(pid));</span><br><span class="line">                Sio_puts(<span class="string">&quot;] (&quot;</span>);</span><br><span class="line">                Sio_putl(pid);</span><br><span class="line">                Sio_puts(<span class="string">&quot;) terminated by signal &quot;</span>);</span><br><span class="line">                Sio_putl(WTERMSIG(status));</span><br><span class="line">                Sio_puts(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            deletejob(jobs, pid); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (WIFSTOPPED(status)) &#123; <span class="comment">// stopped by ctrl-z</span></span><br><span class="line">            <span class="comment">/* printf(&quot;Job [%d] (%d) stopped by signal %2d\n&quot;,</span></span><br><span class="line"><span class="comment">                   pid2jid(pid), pid, WSTOPSIG(status)); */</span> &#123;</span><br><span class="line">            	Sio_puts(<span class="string">&quot;Job [&quot;</span>);</span><br><span class="line">                Sio_putl(pid2jid(pid));</span><br><span class="line">                Sio_puts(<span class="string">&quot;] (&quot;</span>);</span><br><span class="line">                Sio_putl(pid);</span><br><span class="line">                Sio_puts(<span class="string">&quot;) stopped by signal &quot;</span>);</span><br><span class="line">                Sio_putl(WSTOPSIG(status));</span><br><span class="line">                Sio_puts(<span class="string">&quot;\n&quot;</span>);           </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 修改子进程状态为ST</span></span><br><span class="line">            getjobpid(jobs, pid)-&gt;state = ST;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    errno = old_errno;</span><br><span class="line">    <span class="keyword">if</span> (verbose) &#123;</span><br><span class="line">        <span class="comment">/* printf(&quot;sigchld_handler: exiting\n&quot;); */</span> &#123;</span><br><span class="line">        	Sio_puts(<span class="string">&quot;sigchld_handler: exiting\n&quot;</span>);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就不会在处理信号程序中使用异步信号不安全的<code>printf</code>了。</p>
<p>然后，<em>shell</em>程序本身是所有子进程的父进程，按照<code>fork</code>函数简单实现，会被分配在一个组中。如果收到了SIGINT，发送给子进程的组，那也会发送给自己（子进程就在自己的组中），那么自己又会收到SIGINT，然后又会发送给自己的所有子进程，然后自己又收到…就陷入循环中无法继续，或者崩溃退出。所以<em>shell</em>不可以和它的子进程在同一个组内，就是要给每个子进程单独的组，组的id就是子进程的pid。我们应该把这个操作放在<code>fork</code>之后，修改它的组id，然后执行<code>execve</code>。</p>
<p>修改<code>eval</code>这一部分代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((pid = fork()) == <span class="number">0</span>) &#123;  <span class="comment">/* child */</span></span><br><span class="line">	<span class="comment">/* 给fork出来的子进程设置一个独立的组，</span></span><br><span class="line"><span class="comment">	 * 子进程是这个组的组长,组id为子进程的pid */</span></span><br><span class="line">    setpgid(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>setpgid</code>函数在实验英文指导书有介绍，用于设置进程组id</p>
<p>表头文件 #include<unistd.h></unistd.h></p>
<p>定义函数 int setpgid(pid_t pid,pid_t pgid);</p>
<p>功能：设置pid所在的进程组的进程组id设置成pgid</p>
<p>setpgid(0, 0)的含义：</p>
<ul>
<li>第一个参数pid是0，则使用当前进程的pid</li>
<li>第二个参数pgid是0，则使用当前进程pid作为pgid</li>
</ul>
</blockquote>
<p>测试结果</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest06</span><br><span class="line">./sdriver.pl -t trace06.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace06.txt - Forward SIGINT to foreground job.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./myspin 4</span><br><span class="line">Job [1] (3427) terminated by signal 2</span><br><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make test06</span><br><span class="line">./sdriver.pl -t trace06.txt -s ./tsh -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace06.txt - Forward SIGINT to foreground job.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./myspin 4</span><br><span class="line">Job [1] (3433) terminated by signal 2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest07</span><br><span class="line">./sdriver.pl -t trace07.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace07.txt - Forward SIGINT only to foreground job.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./myspin 4 &amp;</span><br><span class="line">[1] (3440) ./myspin 4 &amp;</span><br><span class="line">tsh&gt; ./myspin 5</span><br><span class="line">Job [2] (3442) terminated by signal 2</span><br><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br><span class="line">[1] (3440) Running ./myspin 4 &amp;</span><br><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make test07</span><br><span class="line">./sdriver.pl -t trace07.txt -s ./tsh -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace07.txt - Forward SIGINT only to foreground job.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./myspin 4 &amp;</span><br><span class="line">[1] (3449) ./myspin 4 &amp;</span><br><span class="line">tsh&gt; ./myspin 5</span><br><span class="line">Job [2] (3451) terminated by signal 2</span><br><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br><span class="line">[1] (3449) Running ./myspin 4 &amp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest08</span><br><span class="line">./sdriver.pl -t trace08.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace08.txt - Forward SIGTSTP only to foreground job.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./myspin 4 &amp;</span><br><span class="line">[1] (3459) ./myspin 4 &amp;</span><br><span class="line">tsh&gt; ./myspin 5</span><br><span class="line">Job [2] (3461) stopped by signal 20</span><br><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br><span class="line">[1] (3459) Running ./myspin 4 &amp;</span><br><span class="line">[2] (3461) Stopped ./myspin 5 </span><br><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make test08</span><br><span class="line">./sdriver.pl -t trace08.txt -s ./tsh -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace08.txt - Forward SIGTSTP only to foreground job.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./myspin 4 &amp;</span><br><span class="line">[1] (3469) ./myspin 4 &amp;</span><br><span class="line">tsh&gt; ./myspin 5</span><br><span class="line">Job [2] (3471) terminated by signal 20</span><br><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br><span class="line">[1] (3469) Running ./myspin 4 &amp;</span><br><span class="line">[2] (3471) Stopped ./myspin 5 </span><br></pre></td></tr></table></figure>
<p>可以看到与参考输出一致，通关~</p>
<h3 id="test09-amp-test10"><a href="#test09-amp-test10" class="headerlink" title="test09 &amp; test10"></a>test09 &amp; test10</h3><p>第九个和第十个放在一起写。请往下看。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest09</span><br><span class="line">./sdriver.pl -t trace09.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace09.txt - Process bg builtin command</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./myspin 4 &amp;</span><br><span class="line">[1] (3480) ./myspin 4 &amp;</span><br><span class="line">tsh&gt; ./myspin 5</span><br><span class="line">Job [2] (3482) stopped by signal 20</span><br><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br><span class="line">[1] (3480) Running ./myspin 4 &amp;</span><br><span class="line">[2] (3482) Stopped ./myspin 5 </span><br><span class="line">tsh&gt; <span class="built_in">bg</span> %2</span><br><span class="line">[2] (3482) ./myspin 5 </span><br><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br><span class="line">[1] (3480) Running ./myspin 4 &amp;</span><br><span class="line">[2] (3482) Running ./myspin 5 </span><br></pre></td></tr></table></figure>
<p>我们先看看第九个测试的参考输出。我们可以看到我们需要构建的是<code>bg</code>内置命令的相关功能。</p>
<blockquote>
<p><code>bg &lt;job&gt;</code>通过向<code>&lt;job&gt;</code>发送SIGCONT来重启它，然后让它运行在后台中，<code>&lt;job&gt;</code>参数可以用PID或者JID</p>
<ul>
<li>如果参数是PID则直接输入pid即可</li>
<li>如果参数是JID则输入“%jid”</li>
</ul>
</blockquote>
<p>我们看到上面的测试。首先是开启一个后台自旋和一个前台自旋的程序。然后发起ctrl-z终止前台的进程。然后jobs可以看到两个进程以及状态。后台的进程仍然在正常运行，但是前台的进程由于SIGTSTP信号而进入stopped状态。然后使用<code>bg %2</code>指令，把第二个子进程（停止的“./myspin 5”）唤醒，然后放到后台执行。输入<code>jobs</code>指令可以看到两个都在执行，但是后者是后来被切换到后台的，所以没有它的cmdline还没有更新还是显示原来的“./myspin 5”。</p>
<p>再看看<code>rtest10</code>，第十个测试</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest10</span><br><span class="line">./sdriver.pl -t trace10.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace10.txt - Process fg builtin command. </span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./myspin 4 &amp;</span><br><span class="line">[1] (3510) ./myspin 4 &amp;</span><br><span class="line">tsh&gt; <span class="built_in">fg</span> %1</span><br><span class="line">Job [1] (3510) stopped by signal 20</span><br><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br><span class="line">[1] (3510) Stopped ./myspin 4 &amp;</span><br><span class="line">tsh&gt; <span class="built_in">fg</span> %1</span><br><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br></pre></td></tr></table></figure>
<p>它针对的是fg这个内置命令的处理。</p>
<blockquote>
<p><code>fg &lt;job&gt;</code>命令通过发送SIGCONT信号给进程<code>&lt;job&gt;</code>，然后把它运行在前台中，<code>&lt;job&gt;</code>参数可以用PID或者JID</p>
<ul>
<li>如果参数是PID则直接输入pid即可</li>
<li>如果参数是JID则输入“%jid”</li>
</ul>
</blockquote>
<p>可以看到上面的测试样例，一开始，是后台运行一个“./myspin 4”，然后把它放到前台运行，使用“fg %1”命令，切换到前台执行，<em>shell</em>等待它执行完毕。然后<code>jobs</code>查看看到有一个停止的工作，然后把它放到前台并开始运行。最后<code>jobs</code>查看，由于已经运行完了，所以没有输出。</p>
<p>对于这两个功能我们要实现的是<code>do_fgbg</code>函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * do_bgfg - Execute the builtin bg and fg commands</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_bgfg</span><span class="params">(<span class="type">char</span>** argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">job_t</span>* <span class="title">job</span>;</span></span><br><span class="line">    <span class="type">char</span>* id = argv[<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断输入的是jid还是pid</span></span><br><span class="line">    <span class="keyword">if</span> (id[<span class="number">0</span>] == <span class="string">&#x27;%&#x27;</span>) &#123; <span class="comment">/* jid */</span></span><br><span class="line">        <span class="comment">//去掉&#x27;%&#x27;开始读jid，根据jid返回这个子进程的结构指针</span></span><br><span class="line">        <span class="type">int</span> jid = atoi(id + <span class="number">1</span>);</span><br><span class="line">        job = getjobjid(jobs, jid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;              <span class="comment">/* pid */</span></span><br><span class="line">        <span class="type">int</span> pid = atoi(id);</span><br><span class="line">        job = getjobpid(jobs, pid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    * kill不单是杀掉进程，还有发送信号的功能 </span></span><br><span class="line"><span class="comment">    * 这里唤醒job所在的组中的所有进程</span></span><br><span class="line"><span class="comment">    * 就是唤醒这个stopped的子进程，以及它派生的孙子进程</span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">    kill(-(job-&gt;pid), SIGCONT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;fg&quot;</span>)) &#123;  <span class="comment">// fg command</span></span><br><span class="line">        job-&gt;state = FG;</span><br><span class="line">        <span class="comment">// 等待该前台作业终止</span></span><br><span class="line">        waitfg(job-&gt;pid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;                         <span class="comment">// bg command</span></span><br><span class="line">        job-&gt;state = BG;</span><br><span class="line">        <span class="comment">/* 切换到bg后打印作业信息 */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%d] (%d) %s&quot;</span>, pid2jid(job-&gt;pid), job-&gt;pid, job-&gt;cmdline);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们在<code>builtin_cmd</code>中加入函数入口。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in `builtin_cmd`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// bg or fg command</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;bg&quot;</span>) || !<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;fg&quot;</span>)) &#123;</span><br><span class="line">    do_bgfg(argv);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查看测试结果</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest09</span><br><span class="line">./sdriver.pl -t trace09.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace09.txt - Process bg builtin command</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./myspin 4 &amp;</span><br><span class="line">[1] (3627) ./myspin 4 &amp;</span><br><span class="line">tsh&gt; ./myspin 5</span><br><span class="line">Job [2] (3629) stopped by signal 20</span><br><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br><span class="line">[1] (3627) Running ./myspin 4 &amp;</span><br><span class="line">[2] (3629) Stopped ./myspin 5 </span><br><span class="line">tsh&gt; <span class="built_in">bg</span> %2</span><br><span class="line">[2] (3629) ./myspin 5 </span><br><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br><span class="line">[1] (3627) Running ./myspin 4 &amp;</span><br><span class="line">[2] (3629) Running ./myspin 5 </span><br><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make test09</span><br><span class="line">./sdriver.pl -t trace09.txt -s ./tsh -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace09.txt - Process bg builtin command</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./myspin 4 &amp;</span><br><span class="line">[1] (3638) ./myspin 4 &amp;</span><br><span class="line">tsh&gt; ./myspin 5</span><br><span class="line">Job [2] (3640) terminated by signal 20</span><br><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br><span class="line">[1] (3638) Running ./myspin 4 &amp;</span><br><span class="line">[2] (3640) Stopped ./myspin 5 </span><br><span class="line">tsh&gt; <span class="built_in">bg</span> %2</span><br><span class="line">[2] (3640) ./myspin 5 </span><br><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br><span class="line">[1] (3638) Running ./myspin 4 &amp;</span><br><span class="line">[2] (3640) Running ./myspin 5 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest10</span><br><span class="line">./sdriver.pl -t trace10.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace10.txt - Process fg builtin command. </span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./myspin 4 &amp;</span><br><span class="line">[1] (7350) ./myspin 4 &amp;</span><br><span class="line">tsh&gt; <span class="built_in">fg</span> %1</span><br><span class="line">Job [1] (7350) stopped by signal 20</span><br><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br><span class="line">[1] (7350) Stopped ./myspin 4 &amp;</span><br><span class="line">tsh&gt; <span class="built_in">fg</span> %1</span><br><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make test10</span><br><span class="line">./sdriver.pl -t trace10.txt -s ./tsh -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace10.txt - Process fg builtin command. </span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./myspin 4 &amp;</span><br><span class="line">[1] (7361) ./myspin 4 &amp;</span><br><span class="line">tsh&gt; <span class="built_in">fg</span> %1</span><br><span class="line">Job [1] (7361) stopped by signal 20</span><br><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br><span class="line">[1] (7361) Stopped ./myspin 4 &amp;</span><br><span class="line">tsh&gt; <span class="built_in">fg</span> %1</span><br><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br></pre></td></tr></table></figure>
<p>与参考一致，通关~</p>
<h3 id="test11-amp-test12-amp-test13"><a href="#test11-amp-test12-amp-test13" class="headerlink" title="test11 &amp; test12 &amp; test13"></a>test11 &amp; test12 &amp; test13</h3><p>先看看test11</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest11</span><br><span class="line">./sdriver.pl -t trace11.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace11.txt - Forward SIGINT to every process in foreground process group</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure>
<p>要求我们接收到SIGINT的时候把它发送给前台进程所处的进程组的所有进程。这个在我们前面的代码中的<code>sigint_handler</code>就已经有所处理了。</p>
<p>然后看看test12</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest12</span><br><span class="line">./sdriver.pl -t trace12.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace12.txt - Forward SIGTSTP to every process in foreground process group</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure>
<p>和测试11类似，我们接受到SIGTSTP的时候要把信号发给前台进程所处的进程组的所有进程。这个在<code>sigtstp_handler</code>就已经处理了。</p>
<p>再看看test13</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest13</span><br><span class="line">./sdriver.pl -t trace13.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace13.txt - Restart every stopped process in process group</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure>
<p>这个测试检测的是能够重启一个进程(原来是stopped状态)，这个功能在对于内置指令<code>fg</code>以及<code>bg</code>的处理上已经实现了。</p>
<blockquote>
<p>对于Linux下的ps命令a参数表示显示所有的进程</p>
<p>状态码：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Here are the different values that the s, <span class="built_in">stat</span> and state output specifiers (header <span class="string">&quot;STAT&quot;</span> or <span class="string">&quot;S&quot;</span>) will display to describe the state of a process:</span><br><span class="line"></span><br><span class="line">        D    uninterruptible <span class="built_in">sleep</span> (usually IO)</span><br><span class="line">        R    running or runnable (on run queue)</span><br><span class="line">        S    interruptible <span class="built_in">sleep</span> (waiting <span class="keyword">for</span> an event to complete)</span><br><span class="line">        T    stopped by job control signal</span><br><span class="line">        t    stopped by debugger during the tracing</span><br><span class="line">        W    paging (not valid since the 2.6.xx kernel)</span><br><span class="line">        X    dead (should never be seen)</span><br><span class="line">        Z    defunct (<span class="string">&quot;zombie&quot;</span>) process, terminated but not reaped by its parent</span><br><span class="line"></span><br><span class="line">For BSD formats and when the <span class="built_in">stat</span> keyword is used, additional characters may be displayed:</span><br><span class="line">        &lt;    high-priority (not <span class="built_in">nice</span> to other <span class="built_in">users</span>)</span><br><span class="line">        N    low-priority (<span class="built_in">nice</span> to other <span class="built_in">users</span>)</span><br><span class="line">        L    has pages locked into memory (<span class="keyword">for</span> real-time and custom IO)</span><br><span class="line">        s    is a session leader</span><br><span class="line">        l    is multi-threaded (using CLONE_THREAD, like NPTL pthreads <span class="keyword">do</span>)</span><br><span class="line">           +    is <span class="keyword">in</span> the foreground process group</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>我们直接对比测试结果</strong></p>
<ul>
<li><strong>test11</strong></li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest11</span><br><span class="line">./sdriver.pl -t trace11.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace11.txt - Forward SIGINT to every process in foreground process group</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./mysplit 4</span><br><span class="line">Job [1] (7419) terminated by signal 2</span><br><span class="line">tsh&gt; /bin/ps a</span><br><span class="line">  PID TTY      STAT   TIME COMMAND</span><br><span class="line"> 1190 tty4     Ss+    0:00 /sbin/getty -8 38400 tty4</span><br><span class="line"> 1197 tty5     Ss+    0:00 /sbin/getty -8 38400 tty5</span><br><span class="line"> 1207 tty2     Ss+    0:00 /sbin/getty -8 38400 tty2</span><br><span class="line"> 1209 tty3     Ss+    0:00 /sbin/getty -8 38400 tty3</span><br><span class="line"> 1230 tty6     Ss+    0:00 /sbin/getty -8 38400 tty6</span><br><span class="line"> 1352 tty7     Ss+   23:36 /usr/bin/X :0 -auth /var/run/lightdm/root/:0 -nolisten tcp vt7 -novtswitch -background none</span><br><span class="line"> 1785 tty1     Ss+    0:00 /sbin/getty -8 38400 tty1</span><br><span class="line"> 6865 pts/0    Ss     0:00 bash</span><br><span class="line"> 6971 pts/1    Ss+    0:00 /bin/bash</span><br><span class="line"> 7255 pts/0    R     39:18 ./tsh -p</span><br><span class="line"> 7256 pts/0    Z      0:00 [<span class="built_in">echo</span>] &lt;defunct&gt;</span><br><span class="line"> 7414 pts/0    S+     0:00 make rtest11</span><br><span class="line"> 7415 pts/0    S+     0:00 /bin/sh -c ./sdriver.pl -t trace11.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"> 7416 pts/0    S+     0:00 /usr/bin/perl ./sdriver.pl -t trace11.txt -s ./tshref -a -p</span><br><span class="line"> 7417 pts/0    S+     0:00 ./tshref -p</span><br><span class="line"> 7422 pts/0    R      0:00 /bin/ps a</span><br><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make test11</span><br><span class="line">./sdriver.pl -t trace11.txt -s ./tsh -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace11.txt - Forward SIGINT to every process in foreground process group</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./mysplit 4</span><br><span class="line">Job [1] (7433) terminated by signal 2</span><br><span class="line">tsh&gt; /bin/ps a</span><br><span class="line">  PID TTY      STAT   TIME COMMAND</span><br><span class="line"> 1190 tty4     Ss+    0:00 /sbin/getty -8 38400 tty4</span><br><span class="line"> 1197 tty5     Ss+    0:00 /sbin/getty -8 38400 tty5</span><br><span class="line"> 1207 tty2     Ss+    0:00 /sbin/getty -8 38400 tty2</span><br><span class="line"> 1209 tty3     Ss+    0:00 /sbin/getty -8 38400 tty3</span><br><span class="line"> 1230 tty6     Ss+    0:00 /sbin/getty -8 38400 tty6</span><br><span class="line"> 1352 tty7     Ss+   23:37 /usr/bin/X :0 -auth /var/run/lightdm/root/:0 -nolisten tcp vt7 -novtswitch -background none</span><br><span class="line"> 1785 tty1     Ss+    0:00 /sbin/getty -8 38400 tty1</span><br><span class="line"> 6865 pts/0    Ss     0:00 bash</span><br><span class="line"> 6971 pts/1    Ss+    0:00 /bin/bash</span><br><span class="line"> 7255 pts/0    R     39:26 ./tsh -p</span><br><span class="line"> 7256 pts/0    Z      0:00 [<span class="built_in">echo</span>] &lt;defunct&gt;</span><br><span class="line"> 7428 pts/0    S+     0:00 make test11</span><br><span class="line"> 7429 pts/0    S+     0:00 /bin/sh -c ./sdriver.pl -t trace11.txt -s ./tsh -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"> 7430 pts/0    S+     0:00 /usr/bin/perl ./sdriver.pl -t trace11.txt -s ./tsh -a -p</span><br><span class="line"> 7431 pts/0    R+     0:02 ./tsh -p</span><br><span class="line"> 7436 pts/0    R      0:00 /bin/ps a</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>test12</strong>和<strong>test13</strong>略（答案太长了）</li>
</ul>
<h3 id="test14"><a href="#test14" class="headerlink" title="test14"></a>test14</h3><p>这个测试需要对<code>fg</code>和<code>bg</code>的输入参数进行一些错误处理。例如没有参数或参数非数值或所选任务或进程不存在等。修改<code>do_bgfg</code>函数如。（/<em> ADD PART </em>/带有这个标签的就是增加的功能）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * do_bgfg - Execute the builtin bg and fg commands</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_bgfg</span><span class="params">(<span class="type">char</span>** argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">job_t</span>* <span class="title">job</span>;</span></span><br><span class="line">    <span class="type">char</span>* id = argv[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ADD PART bg和fg后边不跟任何参数不执行直接返回 */</span></span><br><span class="line">    <span class="comment">// no argument for bg/fg</span></span><br><span class="line">    <span class="keyword">if</span> (id == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s command requires PID or %%jobid argument\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 判断输入的是jid还是pid</span></span><br><span class="line">    <span class="keyword">if</span> (id[<span class="number">0</span>] == <span class="string">&#x27;%&#x27;</span>) &#123; <span class="comment">/* jid */</span></span><br><span class="line">        <span class="comment">/* ADD PART 检查输入的jid是不是数字 */</span></span><br><span class="line">        <span class="keyword">if</span> (!checkNum(id + <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s: argument must be a PID or %%jobid\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//去掉&#x27;%&#x27;开始读jid，根据jid返回这个子进程的结构指针</span></span><br><span class="line">        <span class="type">int</span> jid = atoi(id + <span class="number">1</span>);</span><br><span class="line">        job = getjobjid(jobs, jid);</span><br><span class="line">        <span class="comment">/* ADD PART 找不到输入的这个作业 */</span></span><br><span class="line">        <span class="keyword">if</span> (job == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%%%d: No such job\n&quot;</span>, jid);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;              <span class="comment">/* pid */</span></span><br><span class="line">        <span class="comment">/* ADD PART  检查输入的pid是不是数字 */</span></span><br><span class="line">        <span class="keyword">if</span> (!checkNum(id)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s: argument must be a PID or %%jobid\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> pid = atoi(id);</span><br><span class="line">        job = getjobpid(jobs, pid);</span><br><span class="line">        <span class="comment">/* ADD PART 找不到这个作业 */</span></span><br><span class="line">        <span class="keyword">if</span> (job == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;(%d): No such process\n&quot;</span>, pid);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    * kill不单是杀掉进程，还有发送信号的功能 </span></span><br><span class="line"><span class="comment">    * 这里唤醒job所在的组中的所有进程</span></span><br><span class="line"><span class="comment">    * 就是唤醒这个stopped的子进程，以及它派生的孙子进程</span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">    kill(-(job-&gt;pid), SIGCONT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;fg&quot;</span>)) &#123;  <span class="comment">// fg command</span></span><br><span class="line">        job-&gt;state = FG;</span><br><span class="line">        <span class="comment">// 等待该前台作业终止</span></span><br><span class="line">        waitfg(job-&gt;pid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;                         <span class="comment">// bg command</span></span><br><span class="line">        job-&gt;state = BG;</span><br><span class="line">        <span class="comment">/* 切换到bg后打印作业信息 */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%d] (%d) %s&quot;</span>, pid2jid(job-&gt;pid), job-&gt;pid, job-&gt;cmdline);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查看参考输出</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest14</span><br><span class="line">./sdriver.pl -t trace14.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace14.txt - Simple error handling</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./bogus</span><br><span class="line">./bogus: Command not found</span><br><span class="line">tsh&gt; ./myspin 4 &amp;</span><br><span class="line">[1] (7521) ./myspin 4 &amp;</span><br><span class="line">tsh&gt; <span class="built_in">fg</span></span><br><span class="line"><span class="built_in">fg</span> <span class="built_in">command</span> requires PID or %jobid argument</span><br><span class="line">tsh&gt; <span class="built_in">bg</span></span><br><span class="line"><span class="built_in">bg</span> <span class="built_in">command</span> requires PID or %jobid argument</span><br><span class="line">tsh&gt; <span class="built_in">fg</span> a</span><br><span class="line"><span class="built_in">fg</span>: argument must be a PID or %jobid</span><br><span class="line">tsh&gt; <span class="built_in">bg</span> a</span><br><span class="line"><span class="built_in">bg</span>: argument must be a PID or %jobid</span><br><span class="line">tsh&gt; <span class="built_in">fg</span> 9999999</span><br><span class="line">(9999999): No such process</span><br><span class="line">tsh&gt; <span class="built_in">bg</span> 9999999</span><br><span class="line">(9999999): No such process</span><br><span class="line">tsh&gt; <span class="built_in">fg</span> %2</span><br><span class="line">%2: No such job</span><br><span class="line">tsh&gt; <span class="built_in">fg</span> %1</span><br><span class="line">Job [1] (7521) stopped by signal 20</span><br><span class="line">tsh&gt; <span class="built_in">bg</span> %2</span><br><span class="line">%2: No such job</span><br><span class="line">tsh&gt; <span class="built_in">bg</span> %1</span><br><span class="line">[1] (7521) ./myspin 4 &amp;</span><br><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br><span class="line">[1] (7521) Running ./myspin 4 &amp;</span><br><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make test14</span><br><span class="line">./sdriver.pl -t trace14.txt -s ./tsh -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace14.txt - Simple error handling</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./bogus</span><br><span class="line">tsh&gt; ./myspin 4 &amp;</span><br><span class="line">[1] (7540) ./myspin 4 &amp;</span><br><span class="line">tsh&gt; <span class="built_in">fg</span></span><br><span class="line"><span class="built_in">fg</span> <span class="built_in">command</span> requires PID or %jobid argument</span><br><span class="line">tsh&gt; <span class="built_in">bg</span></span><br><span class="line"><span class="built_in">bg</span> <span class="built_in">command</span> requires PID or %jobid argument</span><br><span class="line">tsh&gt; <span class="built_in">fg</span> a</span><br><span class="line"><span class="built_in">fg</span>: argument must be a PID or %jobid</span><br><span class="line">tsh&gt; <span class="built_in">bg</span> a</span><br><span class="line"><span class="built_in">bg</span>: argument must be a PID or %jobid</span><br><span class="line">tsh&gt; <span class="built_in">fg</span> 9999999</span><br><span class="line">(9999999): No such process</span><br><span class="line">tsh&gt; <span class="built_in">bg</span> 9999999</span><br><span class="line">(9999999): No such process</span><br><span class="line">tsh&gt; <span class="built_in">fg</span> %2</span><br><span class="line">%2: No such job</span><br><span class="line">tsh&gt; <span class="built_in">fg</span> %1</span><br><span class="line">Job [1] (7540) stopped by signal 20</span><br><span class="line">tsh&gt; <span class="built_in">bg</span> %2</span><br><span class="line">%2: No such job</span><br><span class="line">tsh&gt; <span class="built_in">bg</span> %1</span><br><span class="line">[1] (7540) ./myspin 4 &amp;</span><br><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br><span class="line">[1] (7540) Running ./myspin 4 &amp;</span><br></pre></td></tr></table></figure>
<p>对于输入的不合法的pid不是数字（例如44行）或者没有没有参数（42行）或者单纯没有这个pid（48行），都会进行处理并返回而不是崩溃。这个功能的晚上增强了<em>shell</em>的鲁棒性。</p>
<p>和参考基本一致，通关~</p>
<h3 id="test15-amp-test16"><a href="#test15-amp-test16" class="headerlink" title="test15 &amp; test16"></a>test15 &amp; test16</h3><p>我们看看测试的要求</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest15</span><br><span class="line">./sdriver.pl -t trace15.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace15.txt - Putting it all together</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure>
<p>测试15是要我们把所有的方法放在一起。这个都不要做，本来就在一个文件<code>tsh.c</code>下写的。。。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">puitar@ubuntu:~/Desktop/LAB4/shlab-handout$ make rtest16</span><br><span class="line">./sdriver.pl -t trace16.txt -s ./tshref -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace16.txt - Tests whether the shell can handle SIGTSTP and SIGINT</span></span><br><span class="line"><span class="comment">#     signals that come from other processes instead of the terminal.</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure>
<p>这个测试要我们测试<em>shell</em>收到SIGINT或者SIGTSTP的来源不是中断而是其他进程是否仍然能够正常工作。这个也不需要做什么。原因有二</p>
<ul>
<li>我们前面的<code>make testn</code>的时候，就是把我们的<code>tsh</code>作为<code>shell driver</code>的子进程，然后驱动给我们的<code>tsh</code>发送测试指令。其中就有SIGINT和SIGTSTP，我们能过够通过前面的，肯定是对的。</li>
<li>我们的<code>tsh</code>至始至终实现对的都是收到信号，然后对自己的孩子怎么处理。至于如何接受外部信号，是从中断收到还是其他的进程收到，我们实验过程中虽然没有关注到。但是我们在从unix的<em>shell</em>输入“./tsh”之后进入到<em>tsh</em>。<ul>
<li>这个过程是内核捕捉到SIGINT等信号发送给我们的unix shell，然后unix shell会把这些信号有发送给tsh，然后tsh又把它发送给子进程们。</li>
<li>关系如下图。</li>
</ul>
</li>
</ul>
<p><img src="/2022/05/26/CSAPP-shlab-report/image-20220526221432408.png" alt="image-20220526221432408" style="zoom:80%;"></p>
<p>还有一个小知识点：参考<a href="https://stackoverflow.com/questions/5422831/what-is-the-difference-between-using-exit-exit-in-a-conventional-linux-fo">exit与_exit的区别</a>，可以知道<strong>在fork出的child中要用_exit来退出</strong>，否则exit会调用用atexit注册的函数并刷新父进程的缓冲区。一般来说在一个main函数中只调用一次exit或return。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in `eval`</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">/* </span></span><br><span class="line"><span class="comment">            * 前台执行 </span></span><br><span class="line"><span class="comment">            * 如果没有这个可执行程序，那么直接终止这个子进程</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">if</span> (execve(argv[<span class="number">0</span>], argv, environ) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s: Command not found.\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">                _exit(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>
<h3 id="tsh-c文件综合"><a href="#tsh-c文件综合" class="headerlink" title="tsh.c文件综合"></a>tsh.c文件综合</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * tsh - A tiny shell program with job control</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;Puitar&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Misc manifest constants */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLINE    1024   <span class="comment">/* max line size */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXARGS     128   <span class="comment">/* max args on a command line */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXJOBS      16   <span class="comment">/* max jobs at any point in time */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXJID    1&lt;&lt;16   <span class="comment">/* max job ID */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Job states */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNDEF 0 <span class="comment">/* undefined */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FG 1    <span class="comment">/* running in foreground */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BG 2    <span class="comment">/* running in background */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ST 3    <span class="comment">/* stopped */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Jobs states: FG (foreground), BG (background), ST (stopped)</span></span><br><span class="line"><span class="comment"> * Job state transitions and enabling actions:</span></span><br><span class="line"><span class="comment"> *     FG -&gt; ST  : ctrl-z</span></span><br><span class="line"><span class="comment"> *     ST -&gt; FG  : fg command</span></span><br><span class="line"><span class="comment"> *     ST -&gt; BG  : bg command</span></span><br><span class="line"><span class="comment"> *     BG -&gt; FG  : fg command</span></span><br><span class="line"><span class="comment"> * At most 1 job can be in the FG state.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Global variables */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span>** environ;      <span class="comment">/* defined in libc */</span></span><br><span class="line"><span class="type">char</span> prompt[] = <span class="string">&quot;tsh&gt; &quot;</span>;    <span class="comment">/* command line prompt (DO NOT CHANGE) */</span></span><br><span class="line"><span class="type">int</span> verbose = <span class="number">0</span>;            <span class="comment">/* if true, print additional output */</span></span><br><span class="line"><span class="type">int</span> nextjid = <span class="number">1</span>;            <span class="comment">/* next job ID to allocate */</span></span><br><span class="line"><span class="type">char</span> sbuf[MAXLINE];         <span class="comment">/* for composing sprintf messages */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> &#123;</span>              <span class="comment">/* The job struct */</span></span><br><span class="line">    <span class="type">pid_t</span> pid;              <span class="comment">/* job PID */</span></span><br><span class="line">    <span class="type">int</span> jid;                <span class="comment">/* job ID [1, 2, ...] */</span></span><br><span class="line">    <span class="type">int</span> state;              <span class="comment">/* UNDEF, BG, FG, or ST */</span></span><br><span class="line">    <span class="type">char</span> cmdline[MAXLINE];  <span class="comment">/* command line */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> <span class="title">jobs</span>[<span class="title">MAXJOBS</span>];</span> <span class="comment">/* The job list */</span></span><br><span class="line"><span class="comment">/* End global variables */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Function prototypes */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Here are the functions that you will implement */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">eval</span><span class="params">(<span class="type">char</span>* cmdline)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">builtin_cmd</span><span class="params">(<span class="type">char</span>** argv)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">do_bgfg</span><span class="params">(<span class="type">char</span>** argv)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">waitfg</span><span class="params">(<span class="type">pid_t</span> pid)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sigchld_handler</span><span class="params">(<span class="type">int</span> sig)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sigtstp_handler</span><span class="params">(<span class="type">int</span> sig)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sigint_handler</span><span class="params">(<span class="type">int</span> sig)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Here are helper routines that we&#x27;ve provided for you */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">parseline</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* cmdline, <span class="type">char</span>** argv)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sigquit_handler</span><span class="params">(<span class="type">int</span> sig)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">clearjob</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span>* job)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">initjobs</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span>* jobs)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">maxjid</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span>* jobs)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">addjob</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span>* jobs, <span class="type">pid_t</span> pid, <span class="type">int</span> state, <span class="type">char</span>* cmdline)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">deletejob</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span>* jobs, <span class="type">pid_t</span> pid)</span>;</span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fgpid</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span>* jobs)</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="type">job_t</span>* <span class="title function_">getjobpid</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span>* jobs, <span class="type">pid_t</span> pid)</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="type">job_t</span>* <span class="title function_">getjobjid</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span>* jobs, <span class="type">int</span> jid)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pid2jid</span><span class="params">(<span class="type">pid_t</span> pid)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">listjobs</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span>* jobs)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">usage</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">unix_error</span><span class="params">(<span class="type">char</span>* msg)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">app_error</span><span class="params">(<span class="type">char</span>* msg)</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> <span class="title function_">handler_t</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">handler_t</span>* <span class="title function_">Signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">handler_t</span>* handler)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// wrapper functions get from csapp.h</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Sigprocmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span>* <span class="built_in">set</span>, <span class="type">sigset_t</span>* oldset)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Sigemptyset</span><span class="params">(<span class="type">sigset_t</span>* <span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Sigaddset</span><span class="params">(<span class="type">sigset_t</span>* <span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sio package declaration from csapp.h</span></span><br><span class="line"><span class="comment">/* Sio (Signal-safe I/O) routines */</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">sio_puts</span><span class="params">(<span class="type">char</span> s[])</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">sio_putl</span><span class="params">(<span class="type">long</span> v)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sio_error</span><span class="params">(<span class="type">char</span> s[])</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Sio wrappers */</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">Sio_puts</span><span class="params">(<span class="type">char</span> s[])</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">Sio_putl</span><span class="params">(<span class="type">long</span> v)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Sio_error</span><span class="params">(<span class="type">char</span> s[])</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * main - The shell&#x27;s main routine</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">char</span> cmdline[MAXLINE];</span><br><span class="line">    <span class="type">int</span> emit_prompt = <span class="number">1</span>; <span class="comment">/* emit prompt (default) */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Redirect stderr to stdout (so that driver will get all output</span></span><br><span class="line"><span class="comment">     * on the pipe connected to stdout) */</span></span><br><span class="line">    dup2(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Parse the command line */</span></span><br><span class="line">    <span class="keyword">while</span> ((c = getopt(argc, argv, <span class="string">&quot;hvp&quot;</span>)) != EOF) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:             <span class="comment">/* print help message */</span></span><br><span class="line">                usage();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;v&#x27;</span>:             <span class="comment">/* emit additional diagnostic info */</span></span><br><span class="line">                verbose = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;p&#x27;</span>:             <span class="comment">/* don&#x27;t print a prompt */</span></span><br><span class="line">                emit_prompt = <span class="number">0</span>;  <span class="comment">/* handy for automatic testing */</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                usage();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Install the signal handlers */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* These are the ones you will need to implement */</span></span><br><span class="line">    Signal(SIGINT, sigint_handler);   <span class="comment">/* ctrl-c */</span></span><br><span class="line">    Signal(SIGTSTP, sigtstp_handler);  <span class="comment">/* ctrl-z */</span></span><br><span class="line">    Signal(SIGCHLD, sigchld_handler);  <span class="comment">/* Terminated or stopped child */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This one provides a clean way to kill the shell */</span></span><br><span class="line">    Signal(SIGQUIT, sigquit_handler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initialize the job list */</span></span><br><span class="line">    initjobs(jobs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Execute the shell&#x27;s read/eval loop */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Read command line */</span></span><br><span class="line">        <span class="keyword">if</span> (emit_prompt) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, prompt);</span><br><span class="line">            fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((fgets(cmdline, MAXLINE, <span class="built_in">stdin</span>) == <span class="literal">NULL</span>) &amp;&amp; ferror(<span class="built_in">stdin</span>))</span><br><span class="line">            app_error(<span class="string">&quot;fgets error&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (feof(<span class="built_in">stdin</span>)) &#123; <span class="comment">/* End of file (ctrl-d) */</span></span><br><span class="line">            fflush(<span class="built_in">stdout</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Evaluate the command line */</span></span><br><span class="line">        eval(cmdline);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">/* control never reaches here */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * eval - Evaluate the command line that the user has just typed in</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If the user has requested a built-in command (quit, jobs, bg or fg)</span></span><br><span class="line"><span class="comment"> * then execute it immediately. Otherwise, fork a child process and</span></span><br><span class="line"><span class="comment"> * run the job in the context of the child. If the job is running in</span></span><br><span class="line"><span class="comment"> * the foreground, wait for it to terminate and then return.  Note:</span></span><br><span class="line"><span class="comment"> * each child process must have a unique process group ID so that our</span></span><br><span class="line"><span class="comment"> * background children don&#x27;t receive SIGINT (SIGTSTP) from the kernel</span></span><br><span class="line"><span class="comment"> * when we type ctrl-c (ctrl-z) at the keyboard.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">eval</span><span class="params">(<span class="type">char</span>* cmdline)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>* argv[MAXARGS]; <span class="comment">/* argv for execve() */</span></span><br><span class="line">    <span class="type">int</span> bg;              <span class="comment">/* Should the job run in bg or fg? */</span></span><br><span class="line">    <span class="type">pid_t</span> pid;           <span class="comment">/* Process id */</span></span><br><span class="line">    <span class="type">sigset_t</span> mask, prev;</span><br><span class="line"></span><br><span class="line">    bg = parseline(cmdline, argv);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (argv[<span class="number">0</span>] == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;   <span class="comment">/* Ignore empty lines */</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 这里参考课本520的方法</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * sigemptyset是设置一个信号集</span></span><br><span class="line"><span class="comment">    * sigaddset是向mask中添加SIGCHLD信号</span></span><br><span class="line"><span class="comment">    * sigprocmask是保存现在的信号集到prev然后根据第一个参数设置信号集为mask</span></span><br><span class="line"><span class="comment">    *	第二个参数设置成当前阻塞信号集合</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    Sigemptyset(&amp;mask);</span><br><span class="line">    Sigaddset(&amp;mask, SIGCHLD);</span><br><span class="line">	</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!builtin_cmd(argv)) &#123;</span><br><span class="line">        Sigprocmask(SIG_BLOCK, &amp;mask, &amp;prev);  <span class="comment">/* 阻塞SIGCHLD */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((pid = fork()) == <span class="number">0</span>) &#123;   <span class="comment">/* Child runs user job */</span></span><br><span class="line">            <span class="comment">/* 给fork出来的子进程设置一个独立的组，</span></span><br><span class="line"><span class="comment">	 		 * 子进程是这个组的组长,组id为子进程的pid */</span></span><br><span class="line">            setpgid(<span class="number">0</span>, <span class="number">0</span>);	</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/* 对于子进程并不需要阻塞SIGCHLD的信号 */</span></span><br><span class="line">            Sigprocmask(SIG_UNBLOCK, &amp;prev, <span class="literal">NULL</span>);  <span class="comment">// unblock SIGCHLD</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">/* </span></span><br><span class="line"><span class="comment">            * 前台执行 </span></span><br><span class="line"><span class="comment">            * 如果没有这个可执行程序，那么直接终止这个子进程</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">if</span> (execve(argv[<span class="number">0</span>], argv, environ) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s: Command not found.\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">                _exit(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        addjob(jobs, pid, bg ? BG : FG, cmdline);</span><br><span class="line">        <span class="comment">/* 已经加到jobs了，解除阻塞 */</span></span><br><span class="line">        Sigprocmask(SIG_SETMASK, &amp;prev, <span class="literal">NULL</span>);  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Parent waits for foreground job to terminate */</span></span><br><span class="line">        <span class="keyword">if</span> (!bg)  <span class="comment">// 前台运行则等待子进程</span></span><br><span class="line">            waitfg(pid);</span><br><span class="line">        <span class="keyword">else</span>      <span class="comment">// background</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[%d] (%d) %s&quot;</span>, pid2jid(pid), pid, cmdline);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * parseline - Parse the command line and build the argv array.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Characters enclosed in single quotes are treated as a single</span></span><br><span class="line"><span class="comment"> * argument.  Return true if the user has requested a BG job, false if</span></span><br><span class="line"><span class="comment"> * the user has requested a FG job.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">parseline</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* cmdline, <span class="type">char</span>** argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> <span class="built_in">array</span>[MAXLINE]; <span class="comment">/* holds local copy of command line */</span></span><br><span class="line">    <span class="type">char</span>* buf = <span class="built_in">array</span>;          <span class="comment">/* ptr that traverses command line */</span></span><br><span class="line">    <span class="type">char</span>* delim;                <span class="comment">/* points to first space delimiter */</span></span><br><span class="line">    <span class="type">int</span> argc;                   <span class="comment">/* number of args */</span></span><br><span class="line">    <span class="type">int</span> bg;                     <span class="comment">/* background job? */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(buf, cmdline);</span><br><span class="line">    buf[<span class="built_in">strlen</span>(buf) - <span class="number">1</span>] = <span class="string">&#x27; &#x27;</span>;  <span class="comment">/* replace trailing &#x27;\n&#x27; with space */</span></span><br><span class="line">    <span class="keyword">while</span> (*buf &amp;&amp; (*buf == <span class="string">&#x27; &#x27;</span>)) <span class="comment">/* ignore leading spaces */</span></span><br><span class="line">        buf++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Build the argv list */</span></span><br><span class="line">    argc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (*buf == <span class="string">&#x27;\&#x27;&#x27;</span>) &#123;</span><br><span class="line">        buf++;</span><br><span class="line">        delim = <span class="built_in">strchr</span>(buf, <span class="string">&#x27;\&#x27;&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        delim = <span class="built_in">strchr</span>(buf, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (delim) &#123;</span><br><span class="line">        argv[argc++] = buf;</span><br><span class="line">        *delim = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        buf = delim + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (*buf &amp;&amp; (*buf == <span class="string">&#x27; &#x27;</span>)) <span class="comment">/* ignore spaces */</span></span><br><span class="line">            buf++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (*buf == <span class="string">&#x27;\&#x27;&#x27;</span>) &#123;</span><br><span class="line">            buf++;</span><br><span class="line">            delim = <span class="built_in">strchr</span>(buf, <span class="string">&#x27;\&#x27;&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            delim = <span class="built_in">strchr</span>(buf, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    argv[argc] = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">0</span>)  <span class="comment">/* ignore blank line */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* should the job run in the background? */</span></span><br><span class="line">    <span class="keyword">if</span> ((bg = (*argv[argc - <span class="number">1</span>] == <span class="string">&#x27;&amp;&#x27;</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">        argv[--argc] = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * builtin_cmd - If the user has typed a built-in command then execute</span></span><br><span class="line"><span class="comment"> *    it immediately.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">builtin_cmd</span><span class="params">(<span class="type">char</span>** argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// quit command</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;quit&quot;</span>))</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// jobs command</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;jobs&quot;</span>)) &#123;</span><br><span class="line">        listjobs(jobs);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bg or fg command</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;bg&quot;</span>) || !<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;fg&quot;</span>)) &#123;</span><br><span class="line">        do_bgfg(argv);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ignore singleton &amp; (不处理单独的 &#x27;&amp;&#x27;)</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;&amp;&quot;</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// not a build-in command</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// check if arg is a string of nums</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">checkNum</span><span class="params">(<span class="type">char</span>* arg)</span> &#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(arg);</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">isdigit</span>(arg[i])) <span class="comment">// not num</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * do_bgfg - Execute the builtin bg and fg commands</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_bgfg</span><span class="params">(<span class="type">char</span>** argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">job_t</span>* <span class="title">job</span>;</span></span><br><span class="line">    <span class="type">char</span>* id = argv[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// no argument for bg/fg</span></span><br><span class="line">    <span class="keyword">if</span> (id == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s command requires PID or %%jobid argument\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 判断输入的是jid还是pid</span></span><br><span class="line">    <span class="keyword">if</span> (id[<span class="number">0</span>] == <span class="string">&#x27;%&#x27;</span>) &#123; <span class="comment">/* jid */</span></span><br><span class="line">        <span class="keyword">if</span> (!checkNum(id + <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s: argument must be a PID or %%jobid\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//去掉&#x27;%&#x27;开始读jid，根据jid返回这个子进程的结构指针</span></span><br><span class="line">        <span class="type">int</span> jid = atoi(id + <span class="number">1</span>);</span><br><span class="line">        job = getjobjid(jobs, jid);</span><br><span class="line">        <span class="keyword">if</span> (job == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%%%d: No such job\n&quot;</span>, jid);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;              <span class="comment">/* pid */</span></span><br><span class="line">        <span class="keyword">if</span> (!checkNum(id)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s: argument must be a PID or %%jobid\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> pid = atoi(id);</span><br><span class="line">        job = getjobpid(jobs, pid);</span><br><span class="line">        <span class="keyword">if</span> (job == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;(%d): No such process\n&quot;</span>, pid);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    * kill不单是杀掉进程，还有发送信号的功能 </span></span><br><span class="line"><span class="comment">    * 这里唤醒job所在的组中的所有进程</span></span><br><span class="line"><span class="comment">    * 就是唤醒这个stopped的子进程，以及它派生的孙子进程</span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">    kill(-(job-&gt;pid), SIGCONT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;fg&quot;</span>)) &#123;  <span class="comment">// fg command</span></span><br><span class="line">        job-&gt;state = FG;</span><br><span class="line">        <span class="comment">// 等待该前台作业终止</span></span><br><span class="line">        waitfg(job-&gt;pid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;                         <span class="comment">// bg command</span></span><br><span class="line">        job-&gt;state = BG;</span><br><span class="line">        <span class="comment">/* 切换到bg后打印作业信息 */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%d] (%d) %s&quot;</span>, pid2jid(job-&gt;pid), job-&gt;pid, job-&gt;cmdline);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * waitfg - Block until process pid is no longer the foreground process</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">waitfg</span><span class="params">(<span class="type">pid_t</span> pid)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (pid == fgpid(jobs))</span><br><span class="line">        sleep(<span class="number">0</span>); <span class="comment">// 这里是主动让出CPU</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*****************</span></span><br><span class="line"><span class="comment"> * Signal handlers</span></span><br><span class="line"><span class="comment"> *****************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sigchld_handler - The kernel sends a SIGCHLD to the shell whenever</span></span><br><span class="line"><span class="comment"> *     a child job terminates (becomes a zombie), or stops because it</span></span><br><span class="line"><span class="comment"> *     received a SIGSTOP or SIGTSTP signal. The handler reaps all</span></span><br><span class="line"><span class="comment"> *     available zombie children, but doesn&#x27;t wait for any other</span></span><br><span class="line"><span class="comment"> *     currently running children to terminate.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sigchld_handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> old_errno = errno;</span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (verbose)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sigchld_handler: entering \n&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* </span></span><br><span class="line"><span class="comment">    * 回收僵尸进程</span></span><br><span class="line"><span class="comment">    * 这里的WNOHANG是非常重要的。</span></span><br><span class="line"><span class="comment">    * 它的本意是如果所有孩子都没有僵尸(终止)状态的，直接退出</span></span><br><span class="line"><span class="comment">    * 这个能够避免在这里等待所有前台的running和stopped程序终止</span></span><br><span class="line"><span class="comment">    * 这样tsh就不能正常接受用户的输入了</span></span><br><span class="line"><span class="comment">    * WUNTRACED是等待直到有一个子进程变成僵尸退出，返回它的pid</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">while</span> ((pid = waitpid(<span class="number">-1</span>, &amp;status, WNOHANG | WUNTRACED)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程正常退出</span></span><br><span class="line">        <span class="keyword">if</span> (WIFEXITED(status)) &#123;</span><br><span class="line">            deletejob(jobs, pid);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 子进程因为ctrl-c退出</span></span><br><span class="line">        <span class="keyword">if</span> (WIFSIGNALED(status)) &#123; <span class="comment">// terminated by ctrl-c</span></span><br><span class="line">            <span class="comment">/* printf(&quot;Job [%d] (%d) terminated by signal %2d\n&quot;, </span></span><br><span class="line"><span class="comment">                   pid2jid(pid), pid, WTERMSIG(status)); */</span> &#123;</span><br><span class="line">            	Sio_puts(<span class="string">&quot;Job [&quot;</span>);</span><br><span class="line">                Sio_putl(pid2jid(pid));</span><br><span class="line">                Sio_puts(<span class="string">&quot;] (&quot;</span>);</span><br><span class="line">                Sio_putl(pid);</span><br><span class="line">                Sio_puts(<span class="string">&quot;) terminated by signal &quot;</span>);</span><br><span class="line">                Sio_putl(WTERMSIG(status));</span><br><span class="line">                Sio_puts(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            deletejob(jobs, pid); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (WIFSTOPPED(status)) &#123; <span class="comment">// stopped by ctrl-z</span></span><br><span class="line">            <span class="comment">/* printf(&quot;Job [%d] (%d) stopped by signal %2d\n&quot;,</span></span><br><span class="line"><span class="comment">                   pid2jid(pid), pid, WSTOPSIG(status)); */</span> &#123;</span><br><span class="line">            	Sio_puts(<span class="string">&quot;Job [&quot;</span>);</span><br><span class="line">                Sio_putl(pid2jid(pid));</span><br><span class="line">                Sio_puts(<span class="string">&quot;] (&quot;</span>);</span><br><span class="line">                Sio_putl(pid);</span><br><span class="line">                Sio_puts(<span class="string">&quot;) stopped by signal &quot;</span>);</span><br><span class="line">                Sio_putl(WSTOPSIG(status));</span><br><span class="line">                Sio_puts(<span class="string">&quot;\n&quot;</span>);           </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 修改子进程状态为ST</span></span><br><span class="line">            getjobpid(jobs, pid)-&gt;state = ST;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    errno = old_errno;</span><br><span class="line">    <span class="keyword">if</span> (verbose) &#123;</span><br><span class="line">        <span class="comment">/* printf(&quot;sigchld_handler: exiting\n&quot;); */</span> &#123;</span><br><span class="line">        	Sio_puts(<span class="string">&quot;sigchld_handler: exiting\n&quot;</span>);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;      </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sigint_handler - The kernel sends a SIGINT to the shell whenver the</span></span><br><span class="line"><span class="comment"> *    user types ctrl-c at the keyboard.  Catch it and send it along</span></span><br><span class="line"><span class="comment"> *    to the foreground job.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sigint_handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> olderrno = errno;</span><br><span class="line">    <span class="comment">// get the foreground job pid</span></span><br><span class="line">    <span class="type">pid_t</span> fg_pid = fgpid(jobs);</span><br><span class="line">    <span class="comment">// kill the group in the foreground</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * int kill(pid_t pid,int signo)</span></span><br><span class="line"><span class="comment"> 	* 功能: 向进程或进程组发送一个信号 （成功返回 0； 否则，返回 -1 ）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    kill(-fg_pid, sig); </span><br><span class="line">    <span class="comment">// -fg_pid表示向进程组号为pid的组中的每个进程发sig信号</span></span><br><span class="line">    <span class="comment">// 在这里就是向前台进程以及它的每一个子进程(子进程都在自己的父进程的pid为组id的组下)</span></span><br><span class="line">    errno = olderrno;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sigtstp_handler - The kernel sends a SIGTSTP to the shell whenever</span></span><br><span class="line"><span class="comment"> *     the user types ctrl-z at the keyboard. Catch it and suspend the</span></span><br><span class="line"><span class="comment"> *     foreground job by sending it a SIGTSTP.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sigtstp_handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 为了异步信号安全防止errno被覆盖</span></span><br><span class="line">    <span class="type">int</span> olderrno = errno;</span><br><span class="line">    <span class="comment">// get the foreground job pid</span></span><br><span class="line">    <span class="type">pid_t</span> fg_pid = fgpid(jobs);</span><br><span class="line">    <span class="comment">// kill the group in the foreground</span></span><br><span class="line">    kill(-fg_pid, sig);</span><br><span class="line">    errno = olderrno;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********************</span></span><br><span class="line"><span class="comment"> * End signal handlers</span></span><br><span class="line"><span class="comment"> *********************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************************************</span></span><br><span class="line"><span class="comment">  * Helper routines that manipulate the job list</span></span><br><span class="line"><span class="comment">  **********************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* clearjob - Clear the entries in a job struct */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">clearjob</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span>* job)</span> &#123;</span><br><span class="line">    job-&gt;pid = <span class="number">0</span>;</span><br><span class="line">    job-&gt;jid = <span class="number">0</span>;</span><br><span class="line">    job-&gt;state = UNDEF;</span><br><span class="line">    job-&gt;cmdline[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* initjobs - Initialize the job list */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">initjobs</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span>* jobs)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++)</span><br><span class="line">        clearjob(&amp;jobs[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* maxjid - Returns largest allocated job ID */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">maxjid</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span>* jobs)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, max = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++)</span><br><span class="line">        <span class="keyword">if</span> (jobs[i].jid &gt; max)</span><br><span class="line">            max = jobs[i].jid;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* addjob - Add a job to the job list */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">addjob</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span>* jobs, <span class="type">pid_t</span> pid, <span class="type">int</span> state, <span class="type">char</span>* cmdline)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++) &#123;</span><br><span class="line">        <span class="comment">/* 如果jobs数组里面有pid等于0等于0的表项，表示这个位置可以用，把这个作业放进去 */</span></span><br><span class="line">        <span class="keyword">if</span> (jobs[i].pid == <span class="number">0</span>) &#123;</span><br><span class="line">            jobs[i].pid = pid;</span><br><span class="line">            jobs[i].state = state;</span><br><span class="line">            jobs[i].jid = nextjid++;</span><br><span class="line">            <span class="keyword">if</span> (nextjid &gt; MAXJOBS)</span><br><span class="line">                nextjid = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">strcpy</span>(jobs[i].cmdline, cmdline);</span><br><span class="line">            <span class="keyword">if</span> (verbose) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Added job [%d] %d %s\n&quot;</span>, jobs[i].jid, jobs[i].pid, jobs[i].cmdline);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Tried to create too many jobs\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* deletejob - Delete a job whose PID=pid from the job list */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">deletejob</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span>* jobs, <span class="type">pid_t</span> pid)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (jobs[i].pid == pid) &#123;</span><br><span class="line">            clearjob(&amp;jobs[i]);</span><br><span class="line">            nextjid = maxjid(jobs) + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* fgpid - Return PID of current foreground job, 0 if no such job */</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fgpid</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span>* jobs)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++)</span><br><span class="line">        <span class="keyword">if</span> (jobs[i].state == FG)</span><br><span class="line">            <span class="keyword">return</span> jobs[i].pid;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* getjobpid  - Find a job (by PID) on the job list */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="type">job_t</span>* <span class="title function_">getjobpid</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span>* jobs, <span class="type">pid_t</span> pid)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++)</span><br><span class="line">        <span class="keyword">if</span> (jobs[i].pid == pid)</span><br><span class="line">            <span class="keyword">return</span> &amp;jobs[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* getjobjid  - Find a job (by JID) on the job list */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="type">job_t</span>* <span class="title function_">getjobjid</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span>* jobs, <span class="type">int</span> jid)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (jid &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++)</span><br><span class="line">        <span class="keyword">if</span> (jobs[i].jid == jid)</span><br><span class="line">            <span class="keyword">return</span> &amp;jobs[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* pid2jid - Map process ID to job ID */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pid2jid</span><span class="params">(<span class="type">pid_t</span> pid)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++)</span><br><span class="line">        <span class="keyword">if</span> (jobs[i].pid == pid) &#123;</span><br><span class="line">            <span class="keyword">return</span> jobs[i].jid;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* listjobs - Print the job list */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">listjobs</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span>* jobs)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (jobs[i].pid != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[%d] (%d) &quot;</span>, jobs[i].jid, jobs[i].pid);</span><br><span class="line">            <span class="keyword">switch</span> (jobs[i].state) &#123;</span><br><span class="line">                <span class="keyword">case</span> BG:</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Running &quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> FG:</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Foreground &quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> ST:</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Stopped &quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;listjobs: Internal error: job[%d].state=%d &quot;</span>,</span><br><span class="line">                           i, jobs[i].state);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, jobs[i].cmdline);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment"> * end job list helper routines</span></span><br><span class="line"><span class="comment"> ******************************/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************</span></span><br><span class="line"><span class="comment">  * Other helper routines</span></span><br><span class="line"><span class="comment">  ***********************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   * usage - print a help message</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">usage</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Usage: shell [-hvp]\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;   -h   print this message\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;   -v   print additional diagnostic information\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;   -p   do not emit a command prompt\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * unix_error - unix-style error routine</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">unix_error</span><span class="params">(<span class="type">char</span>* msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;%s: %s\n&quot;</span>, msg, strerror(errno));</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * app_error - application-style error routine</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">app_error</span><span class="params">(<span class="type">char</span>* msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;%s\n&quot;</span>, msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Signal - wrapper for the sigaction function</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">handler_t</span>* <span class="title function_">Signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">handler_t</span>* handler)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">action</span>, <span class="title">old_action</span>;</span></span><br><span class="line"></span><br><span class="line">    action.sa_handler = handler;</span><br><span class="line">    sigemptyset(&amp;action.sa_mask); <span class="comment">/* block sigs of type being handled */</span></span><br><span class="line">    action.sa_flags = SA_RESTART; <span class="comment">/* restart syscalls if possible */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sigaction(signum, &amp;action, &amp;old_action) &lt; <span class="number">0</span>)</span><br><span class="line">        unix_error(<span class="string">&quot;Signal error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> (old_action.sa_handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sigquit_handler - The driver program can gracefully terminate the</span></span><br><span class="line"><span class="comment"> *    child shell by sending it a SIGQUIT signal.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sigquit_handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Terminating after receipt of SIGQUIT signal\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// The following function are from csapp.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment"> * Wrappers for blocking signals</span></span><br><span class="line"><span class="comment"> *************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Sigemptyset</span><span class="params">(<span class="type">sigset_t</span>* <span class="built_in">set</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (sigemptyset(<span class="built_in">set</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        unix_error(<span class="string">&quot;Sigemptyset error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Sigprocmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span>* <span class="built_in">set</span>, <span class="type">sigset_t</span>* oldset)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (sigprocmask(how, <span class="built_in">set</span>, oldset) &lt; <span class="number">0</span>)</span><br><span class="line">        unix_error(<span class="string">&quot;Sigprocmask error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Sigaddset</span><span class="params">(<span class="type">sigset_t</span>* <span class="built_in">set</span>, <span class="type">int</span> signum)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (sigaddset(<span class="built_in">set</span>, signum) &lt; <span class="number">0</span>)</span><br><span class="line">        unix_error(<span class="string">&quot;Sigaddset error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment"> * The Sio (Signal-safe I/O) package - simple reentrant output</span></span><br><span class="line"><span class="comment"> * functions that are safe for signal handlers.</span></span><br><span class="line"><span class="comment"> *************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Private sio functions */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* $begin sioprivate */</span></span><br><span class="line"><span class="comment">/* sio_reverse - Reverse a string (from K&amp;R) */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sio_reverse</span><span class="params">(<span class="type">char</span> s[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> c, i, j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, j = <span class="built_in">strlen</span>(s) - <span class="number">1</span>; i &lt; j; i++, j--) &#123;</span><br><span class="line">        c = s[i];</span><br><span class="line">        s[i] = s[j];</span><br><span class="line">        s[j] = c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* sio_ltoa - Convert long to base b string (from K&amp;R) */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sio_ltoa</span><span class="params">(<span class="type">long</span> v, <span class="type">char</span> s[], <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> c, i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> neg = v &lt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (neg)</span><br><span class="line">        v = -v;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        s[i++] = ((c = (v % b)) &lt; <span class="number">10</span>) ? c + <span class="string">&#x27;0&#x27;</span> : c - <span class="number">10</span> + <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> ((v /= b) &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (neg)</span><br><span class="line">        s[i++] = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    s[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    sio_reverse(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* sio_strlen - Return length of string (from K&amp;R) */</span></span><br><span class="line"><span class="type">static</span> <span class="type">size_t</span> <span class="title function_">sio_strlen</span><span class="params">(<span class="type">char</span> s[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (s[i] != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">        ++i;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* $end sioprivate */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Public Sio functions */</span></span><br><span class="line"><span class="comment">/* $begin siopublic */</span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">sio_puts</span><span class="params">(<span class="type">char</span> s[])</span> <span class="comment">/* Put string */</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> write(STDOUT_FILENO, s, sio_strlen(s)); <span class="comment">//line:csapp:siostrlen</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">sio_putl</span><span class="params">(<span class="type">long</span> v)</span> <span class="comment">/* Put long */</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> s[<span class="number">128</span>];</span><br><span class="line"></span><br><span class="line">    sio_ltoa(v, s, <span class="number">10</span>); <span class="comment">/* Based on K&amp;R itoa() */</span>  <span class="comment">//line:csapp:sioltoa</span></span><br><span class="line">    <span class="keyword">return</span> sio_puts(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sio_error</span><span class="params">(<span class="type">char</span> s[])</span> <span class="comment">/* Put error message and exit */</span></span><br><span class="line">&#123;</span><br><span class="line">    sio_puts(s);</span><br><span class="line">    _exit(<span class="number">1</span>);                                      <span class="comment">//line:csapp:sioexit</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* $end siopublic */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************************</span></span><br><span class="line"><span class="comment"> * Wrappers for the SIO routines</span></span><br><span class="line"><span class="comment"> ******************************/</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">Sio_putl</span><span class="params">(<span class="type">long</span> v)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">ssize_t</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((n = sio_putl(v)) &lt; <span class="number">0</span>)</span><br><span class="line">        sio_error(<span class="string">&quot;Sio_putl error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">Sio_puts</span><span class="params">(<span class="type">char</span> s[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">ssize_t</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((n = sio_puts(s)) &lt; <span class="number">0</span>)</span><br><span class="line">        sio_error(<span class="string">&quot;Sio_puts error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Sio_error</span><span class="params">(<span class="type">char</span> s[])</span></span><br><span class="line">&#123;</span><br><span class="line">    sio_error(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h2><p>通过这次实验，才算是比较彻底理解了，信号的相关知识。</p>
<ul>
<li>包括信号的发送和捕捉</li>
<li>异步的思考方式</li>
<li>信号的阻塞</li>
<li>拓展：异步安全问题</li>
<li>信号处理程序的编写和使用</li>
<li><code>signal</code>函数和<code>kill</code>以及相关的函数的使用等</li>
</ul>
<p>这个是本课程最后一个实验的，综合难度并不是最大的。但是是知识体系最为复杂的。总的来说非常喜欢这门课的实验。做完之后能够感觉到和知识的紧密连接。感谢陪伴~</p>
]]></content>
      <categories>
        <category>courses-learning</category>
        <category>大二下期末</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title>黑标签统计安排</title>
    <url>/2022/07/24/%E9%BB%91%E6%A0%87%E7%AD%BE%E7%BB%9F%E8%AE%A1%E5%AE%89%E6%8E%92/</url>
    <content><![CDATA[<h1 id="黑标签统计"><a href="#黑标签统计" class="headerlink" title="黑标签统计"></a>黑标签统计</h1><h2 id="实验安排（更新）"><a href="#实验安排（更新）" class="headerlink" title="实验安排（更新）"></a>实验安排（更新）</h2><p><img src="/2022/07/24/%E9%BB%91%E6%A0%87%E7%AD%BE%E7%BB%9F%E8%AE%A1%E5%AE%89%E6%8E%92/黑标签统计.png" alt></p>
<h2 id="基于内存版本"><a href="#基于内存版本" class="headerlink" title="基于内存版本"></a>基于内存版本</h2><p>基于内存版本的黑标签统计，在这里不做过多介绍。项目地址</p>
<blockquote>
<p>[基于内存黑标签统计]: <a href="https://github.com/PUITAR/BlackLabelCount">https://github.com/PUITAR/BlackLabelCount</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:PUITAR/BlackLabelCount.git</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="基于磁盘版本"><a href="#基于磁盘版本" class="headerlink" title="基于磁盘版本"></a>基于磁盘版本</h2><p>由于后续实验需要一个基准baseline，因此这里使用<code>RocksDB</code>作为基准工作的基础。</p>
<h3 id="1-0版本"><a href="#1-0版本" class="headerlink" title="1_0版本"></a>1_0版本</h3><blockquote>
<p>版本设计思路分为两个模块：</p>
<ul>
<li>小世界模型图生成</li>
<li>小世界模型图的读取和计算</li>
</ul>
</blockquote>
<h4 id="小世界模型图的生成"><a href="#小世界模型图的生成" class="headerlink" title="小世界模型图的生成"></a>小世界模型图的生成</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line">/* `Watts-Strogatz`小世界网络生成算法伪码 */</span><br><span class="line">Function SmallWorldNetwork(n, k, p)</span><br><span class="line">Output: 小世界网络图</span><br><span class="line">Require: k是偶数且p∈[0, 1]</span><br><span class="line">begin</span><br><span class="line">	procedure 参数初始化</span><br><span class="line">    	n: 网络节点总数;</span><br><span class="line">        k: 每个节点的边连接数;</span><br><span class="line">        p: 每条边发生重连的概率;</span><br><span class="line">	end</span><br><span class="line">    procedure 初始边连接</span><br><span class="line">    	for 网络中的每一个结点v do</span><br><span class="line">    		将其与所有距离小于等于k/2的其他结点相连; // 要求k为偶数</span><br><span class="line">    	end</span><br><span class="line">    end</span><br><span class="line">    procedure 已有边重连</span><br><span class="line">    	for 网络中的每一条边e do</span><br><span class="line">    		以概率p重连此边; // 要求不能有自环或者重复边</span><br><span class="line">    	end</span><br><span class="line">    end</span><br><span class="line">end 	</span><br></pre></td></tr></table></figure>
<p>生成的算法如上，但是实验还是先用已有数据集。</p>
<h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><p>和前面内存版本一样，只是获取一阶好友的方式由从内存取到从磁盘取。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description: 通过点的id从数据库获取一阶好友</span></span><br><span class="line"><span class="comment"> * @param &lt;str_t&gt; k 传入点id作为键</span></span><br><span class="line"><span class="comment"> * @param &lt;DB*&gt; db 传入数据库指针</span></span><br><span class="line"><span class="comment"> * @return &lt;*&gt; 返回一节好友的数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">vec_t</span> <span class="title">GetFriends1Vec</span><span class="params">(<span class="type">str_t</span> k, DB* db)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">str_t</span> v;</span><br><span class="line">    <span class="type">vec_t</span> vec;</span><br><span class="line">    db-&gt;<span class="built_in">Get</span>(<span class="built_in">ReadOptions</span>(), k, &amp;v);</span><br><span class="line">    <span class="function">stringstream <span class="title">ss</span><span class="params">(v)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (ss &gt;&gt; v)</span><br><span class="line">        vec.<span class="built_in">push_back</span>(v);</span><br><span class="line">    <span class="keyword">return</span> vec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于在数据库中以字节流的形式（字符串）存储，所以需要用<code>stringstream</code>读出每一个一阶好友。</p>
<h3 id="2-0"><a href="#2-0" class="headerlink" title="2_0"></a>2_0</h3><blockquote>
<p>该版本是多线程版本</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @author: puitar</span></span><br><span class="line"><span class="comment"> * @Description: 版本2.0</span></span><br><span class="line"><span class="comment"> * @Date: 2022-07-30 15:15:11</span></span><br><span class="line"><span class="comment"> * @LastEditTime: 2022-07-30 23:48:14</span></span><br><span class="line"><span class="comment"> * @FilePath: /rocksdb/bkc/2_0.cc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rocksdb/db.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rocksdb/slice.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rocksdb/options.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_MUT_NUM 40</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ROCKSDB_NAMESPACE::DB;</span><br><span class="line"><span class="keyword">using</span> ROCKSDB_NAMESPACE::Options;</span><br><span class="line"><span class="keyword">using</span> ROCKSDB_NAMESPACE::ReadOptions;</span><br><span class="line"><span class="keyword">using</span> ROCKSDB_NAMESPACE::Status;</span><br><span class="line"><span class="keyword">using</span> ROCKSDB_NAMESPACE::WriteBatch;</span><br><span class="line"><span class="keyword">using</span> ROCKSDB_NAMESPACE::WriteOptions;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ReturnType;</span><br><span class="line"><span class="keyword">typedef</span> string <span class="type">str_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">str_t</span>&gt; <span class="type">vec_str_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; <span class="type">vec_int_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> kDBPath[] = <span class="string">&quot;db/data2&quot;</span>;</span><br><span class="line"><span class="type">str_t</span> gTxtPath = <span class="string">&quot;2.txt&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">ReturValue</span> &#123;</span><br><span class="line">    SUCCESS,</span><br><span class="line">    FAILED,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 计算全局变量 */</span></span><br><span class="line">DB* db = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="type">vec_int_t</span> result;</span><br><span class="line"><span class="type">vec_str_t</span> visited;</span><br><span class="line">mutex mutexs[MAX_MUT_NUM];</span><br><span class="line"><span class="type">vec_str_t</span> blacks;</span><br><span class="line"><span class="type">int</span> threads = <span class="number">12</span>;</span><br><span class="line"><span class="type">int</span> bkn = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description: 从txt中读取将图以键值对形式存入数据库，其中键是点id，值是邻接表</span></span><br><span class="line"><span class="comment"> * @param &lt;str_t&gt; gTxtPath txt路径</span></span><br><span class="line"><span class="comment"> * @param &lt;DB*&gt; db 数据库指针</span></span><br><span class="line"><span class="comment"> * @return &lt;*&gt; 若成功返回SUCCESS, 否则返回FAILED</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">ReturnType <span class="title">Generation</span><span class="params">(<span class="type">str_t</span> gTxtPath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Status s;</span><br><span class="line">    ReturnType r = FAILED;</span><br><span class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(gTxtPath)</span></span>;</span><br><span class="line">    <span class="type">str_t</span> k, v;</span><br><span class="line">    unordered_map&lt;<span class="type">str_t</span>, <span class="type">str_t</span>&gt; g;</span><br><span class="line">    <span class="keyword">while</span> (fin &gt;&gt; k &gt;&gt; v) &#123;</span><br><span class="line">        g[k] += v + <span class="string">&quot; &quot;</span>;</span><br><span class="line">        g[v] += k + <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> n = g.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> u = <span class="number">0</span>; u &lt; n; u++) &#123;</span><br><span class="line">        <span class="type">str_t</span> v = <span class="built_in">to_string</span>(u);</span><br><span class="line">        s = db-&gt;<span class="built_in">Put</span>(<span class="built_in">WriteOptions</span>(), v, g[v]);</span><br><span class="line">        <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    r = SUCCESS;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description: 通过点的id从数据库获取一阶好友</span></span><br><span class="line"><span class="comment"> * @param &lt;str_t&gt; k 传入点id作为键</span></span><br><span class="line"><span class="comment"> * @param &lt;DB*&gt; db 传入数据库指针</span></span><br><span class="line"><span class="comment"> * @return &lt;*&gt; 返回一节好友的数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">vec_str_t</span> <span class="title">GetFriends1Vec</span><span class="params">(<span class="type">str_t</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">str_t</span> v;</span><br><span class="line">    <span class="type">vec_str_t</span> vec;</span><br><span class="line">    db-&gt;<span class="built_in">Get</span>(<span class="built_in">ReadOptions</span>(), k, &amp;v);</span><br><span class="line">    <span class="function">stringstream <span class="title">ss</span><span class="params">(v)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (ss &gt;&gt; v)</span><br><span class="line">        vec.<span class="built_in">push_back</span>(v);</span><br><span class="line">    <span class="keyword">return</span> vec;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description: 线程计算函数</span></span><br><span class="line"><span class="comment"> * @param &lt;int&gt; start 线程的初始黑点</span></span><br><span class="line"><span class="comment"> * @return &lt;*&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Computation</span><span class="params">(<span class="type">int</span> start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> u = start; u &lt; bkn; u += threads)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">str_t</span> v = blacks[u];</span><br><span class="line">        <span class="type">vec_str_t</span> friends1 = <span class="built_in">GetFriends1Vec</span>(v);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> f1: friends1) &#123;</span><br><span class="line">            <span class="type">int</span> f1_;</span><br><span class="line">            <span class="function">stringstream <span class="title">ss1</span><span class="params">(f1)</span></span>;</span><br><span class="line">            ss1 &gt;&gt; f1_;</span><br><span class="line">            mutexs[start].<span class="built_in">lock</span>();</span><br><span class="line">            <span class="keyword">if</span> (visited[f1_] != v) &#123;</span><br><span class="line">                result[f1_]++;</span><br><span class="line">                visited[f1_] = v;</span><br><span class="line">            &#125;</span><br><span class="line">            mutexs[start].<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="type">vec_str_t</span> friends2 = <span class="built_in">GetFriends1Vec</span>(f1);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> f2: friends2) &#123;</span><br><span class="line">                <span class="type">int</span> f2_;</span><br><span class="line">                <span class="function">stringstream <span class="title">ss2</span><span class="params">(f2)</span></span>;</span><br><span class="line">                ss2 &gt;&gt; f2_;</span><br><span class="line">                mutexs[start].<span class="built_in">lock</span>();</span><br><span class="line">                <span class="keyword">if</span> (visited[f2_] != v) &#123;</span><br><span class="line">                    result[f2_]++;</span><br><span class="line">                    visited[f2_] = v;</span><br><span class="line">                &#125;</span><br><span class="line">                mutexs[start].<span class="built_in">unlock</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> rm = <span class="built_in">system</span>(<span class="string">&quot;make rm2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 一些必要的声明 */</span></span><br><span class="line">    Options options;</span><br><span class="line">    Status s;</span><br><span class="line">    options.<span class="built_in">IncreaseParallelism</span>();</span><br><span class="line">    options.<span class="built_in">OptimizeLevelStyleCompaction</span>();</span><br><span class="line">    options.create_if_missing = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 参数列表有参数则生成图，否则直接计算</span></span><br><span class="line">    <span class="built_in">assert</span>(argc == <span class="number">2</span>);</span><br><span class="line">    gTxtPath = argv[<span class="number">1</span>];   </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 产生图 */</span></span><br><span class="line">generation: </span><br><span class="line">    <span class="built_in">assert</span>(DB::<span class="built_in">Open</span>(options, kDBPath, &amp;db).<span class="built_in">ok</span>());   </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;generation start!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">Generation</span>(gTxtPath) == SUCCESS);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;generation finish!&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 计算黑标签过程 */</span></span><br><span class="line">computation: </span><br><span class="line">    <span class="comment">/* 获取数据库中键值对的数量 */</span></span><br><span class="line">    <span class="type">uint64_t</span> n;</span><br><span class="line">    db-&gt;<span class="built_in">GetIntProperty</span>(<span class="string">&quot;rocksdb.estimate-num-keys&quot;</span>, &amp;n);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;vertex numbers: &quot;</span> &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 黑标签生成 */</span></span><br><span class="line">    <span class="type">float</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p&lt;=<span class="number">0</span> || p&gt;=<span class="number">1</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;black ratio: &quot;</span>; </span><br><span class="line">        cin &gt;&gt; p;</span><br><span class="line">        cout &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    bkn = n*p;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; bkn; i++) &#123;</span><br><span class="line">        blacks.<span class="built_in">push_back</span>(<span class="built_in">to_string</span>(<span class="built_in">rand</span>()%n));</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// cout &lt;&lt; &quot;blacks:\n&quot;;</span></span><br><span class="line">    <span class="comment">// for (auto b: blacks)</span></span><br><span class="line">    <span class="comment">//     cout &lt;&lt; b &lt;&lt; endl;</span></span><br><span class="line">    bkn = blacks.<span class="built_in">size</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;black numbers: &quot;</span> &lt;&lt; bkn &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 开始计算 */</span></span><br><span class="line">    result.<span class="built_in">resize</span>(n);</span><br><span class="line">    visited.<span class="built_in">resize</span>(n);</span><br><span class="line">    thread pool[threads];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> start = <span class="number">0</span>; start &lt; threads; start++)</span><br><span class="line">    &#123;</span><br><span class="line">        pool[start] = <span class="built_in">thread</span>(Computation, start);</span><br><span class="line">        pool[start].<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 输出结果 */</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; &quot;result:&quot; &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// for (int v = 0; v &lt; n; v++) &#123;</span></span><br><span class="line">    <span class="comment">//     cout &lt;&lt; v &lt;&lt; &quot;: &quot; &lt;&lt; result[v] &lt;&lt; endl; </span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;computation is finished!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;loading time: 1m&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> db;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="统计结果"><a href="#统计结果" class="headerlink" title="统计结果"></a>统计结果</h4><div class="table-container">
<table>
<thead>
<tr>
<th>点总数</th>
<th>黑点数目</th>
<th>时间</th>
<th>版本</th>
</tr>
</thead>
<tbody>
<tr>
<td>1791489</td>
<td>8957</td>
<td>20m44.408s</td>
<td>磁盘；12线程；PC；</td>
</tr>
<tr>
<td>1791489</td>
<td>8957</td>
<td>51s</td>
<td>内存；12线程；PC；</td>
</tr>
<tr>
<td>1791489</td>
<td>8957</td>
<td>10m31.302s</td>
<td>磁盘；40线程；服务器；</td>
</tr>
<tr>
<td>1791489</td>
<td>8957</td>
<td>10m30.668s</td>
<td>磁盘；20线程；服务器；</td>
</tr>
<tr>
<td>1791489</td>
<td>8957</td>
<td>10m25.065s</td>
<td>磁盘；10线程；服务器；</td>
</tr>
<tr>
<td>1791489</td>
<td>8957</td>
<td>10m23.144s</td>
<td>磁盘；1线程；服务器；</td>
</tr>
</tbody>
</table>
</div>
<h2 id="论文"><a href="#论文" class="headerlink" title="论文"></a>论文</h2><h3 id="HyperANF"><a href="#HyperANF" class="headerlink" title="HyperANF"></a>HyperANF</h3><blockquote>
<p>HyperANF_ Approximating the Neighbourhood Function of Very Large Graphs  on a Budget</p>
</blockquote>
<h3 id="Triangle-Enumeration"><a href="#Triangle-Enumeration" class="headerlink" title="Triangle Enumeration"></a>Triangle Enumeration</h3><blockquote>
<p>Improving I/O Complexity of Triangle Enumeration</p>
</blockquote>
<p>ICDE2023-VEND-524(RevisionOf-37)-C</p>
<p>先看这篇文章Introduction部分Algorithm 2 Trigon的原理，有助于理解</p>
<h2 id="GraphChi"><a href="#GraphChi" class="headerlink" title="GraphChi"></a>GraphChi</h2><p>（挂起）</p>
]]></content>
      <tags>
        <tag>并行计算</tag>
        <tag>黑标签统计</tag>
      </tags>
  </entry>
  <entry>
    <title>编译原理学习笔记4</title>
    <url>/2022/07/25/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04/</url>
    <content><![CDATA[<h1 id="自顶向下的分析"><a href="#自顶向下的分析" class="headerlink" title="自顶向下的分析"></a>自顶向下的分析</h1><blockquote>
<ul>
<li>从分析树的顶部（根节点）向底部（叶节点）方向构造分析树</li>
<li>可以看成从文法开始符号S推导出词串w的过程</li>
</ul>
</blockquote>
<p><img src="/2022/07/25/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04/image-20220725082423234.png" alt="image-20220725082423234"></p>
<ul>
<li>在每一步推导中，都需要做两个选择<ul>
<li>替换当前句型中哪一个非终结符</li>
<li>用该非终结符的哪一个候选式进行替换</li>
</ul>
</li>
</ul>
<h2 id="最左推导"><a href="#最左推导" class="headerlink" title="最左推导"></a>最左推导</h2><p>在最左推导中，总是选择每个句型的最左非终结符进行替换</p>
<p><img src="/2022/07/25/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04/image-20220725082742910.png" alt="image-20220725082742910"></p>
<p>最右归约过程是最左推导的逆过程。</p>
<h2 id="最右推导"><a href="#最右推导" class="headerlink" title="最右推导"></a>最右推导</h2><p>最右推导，总是选择每个句型的最右非终结符进行替换</p>
<p><img src="/2022/07/25/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04/image-20220725083615348.png" alt="image-20220725083615348" style="zoom: 50%;"></p>
<h2 id="最左推导和最右推导的唯一性"><a href="#最左推导和最右推导的唯一性" class="headerlink" title="最左推导和最右推导的唯一性"></a>最左推导和最右推导的唯一性</h2><p>在推导的过程中，可以选择不同的非终结符，因此推导不一定具备唯一性。</p>
<p>但是最左推导和最右推导总是选择最左或者最右的非终结符进行推导，因此最左推导和最右推导是唯一的。</p>
<blockquote>
<p>由于分析器总是自左向右扫描字串，因此自顶向下的语法分析总是最左推导。</p>
</blockquote>
<p>这个连接讲的非常清楚，可以直接看视频。</p>
<p><img src="/2022/07/25/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04/image-20220725084344378.png" alt="image-20220725084344378"></p>
<h2 id="自顶向下语法分析的通用形式"><a href="#自顶向下语法分析的通用形式" class="headerlink" title="自顶向下语法分析的通用形式"></a>自顶向下语法分析的通用形式</h2><p><img src="/2022/07/25/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04/image-20220725084542735.png" alt="image-20220725084542735"></p>
<h2 id="预测分析"><a href="#预测分析" class="headerlink" title="预测分析"></a>预测分析</h2><p><img src="/2022/07/25/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04/image-20220725084642107.png" alt="image-20220725084642107"></p>
<h1 id="文法转换"><a href="#文法转换" class="headerlink" title="文法转换"></a>文法转换</h1><p>不是所有文法适合自定线下分析</p>
<h2 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h2><p><img src="/2022/07/25/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04/image-20220725084803497.png" alt="image-20220725084803497"></p>
<p>匹配abc的第一个a的时候，有两个可能的候选项。</p>
<h2 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h2><p><img src="/2022/07/25/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04/image-20220725085030543.png" alt="image-20220725085030543" style="zoom:80%;"></p>
<p>左递归文法会使得递归下降分析器陷入无限循环。因此需要消除左递归</p>
<h2 id="消除直接左递归"><a href="#消除直接左递归" class="headerlink" title="消除直接左递归"></a>消除直接左递归</h2><p><img src="/2022/07/25/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04/image-20220725085616801.png" alt="image-20220725085616801"></p>
<h2 id="消除间接左递归"><a href="#消除间接左递归" class="headerlink" title="消除间接左递归"></a>消除间接左递归</h2><p><img src="/2022/07/25/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04/image-20220725085917479.png" alt="image-20220725085917479"></p>
<p>把S的定义带入到下面的S中，转换成直接左递归的形式，再用直接左递归的消除方法来消除直接左递归。</p>
<h2 id="提取左公因子"><a href="#提取左公因子" class="headerlink" title="提取左公因子"></a>提取左公因子</h2><p>文法中的某个符号的多个候选式存在公共前缀的情况</p>
<p><img src="/2022/07/25/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04/image-20220725090839053.png" alt="image-20220725090839053"></p>
<h2 id="消除左递归和回溯的方法-※"><a href="#消除左递归和回溯的方法-※" class="headerlink" title="消除左递归和回溯的方法(※)"></a>消除左递归和回溯的方法(※)</h2><h1 id="LL-1-文法"><a href="#LL-1-文法" class="headerlink" title="LL(1)文法"></a>LL(1)文法</h1><p>递归下降分析会遇到回溯，会影响效率，如果能预测每一步，就可以避免回溯。LL(1)文法可以使用预测分析技术。</p>
<h2 id="S-文法"><a href="#S-文法" class="headerlink" title="S_文法"></a>S_文法</h2><p><img src="/2022/07/25/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04/image-20220725222323392.png" alt="image-20220725222323392" style="zoom:80%;"></p>
<p><img src="/2022/07/25/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04/image-20220725222535036.png" alt="image-20220725222535036"></p>
<p>在上面的例子中，有两个输入字串，第一个使用空产生式没问题，第二个就有问题。但是不是所有都能使用。</p>
<p><img src="/2022/07/25/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04/image-20220725222705682.png" alt="image-20220725222705682"></p>
<h2 id="非终结符的后继符号集"><a href="#非终结符的后继符号集" class="headerlink" title="非终结符的后继符号集"></a>非终结符的后继符号集</h2><p><img src="/2022/07/25/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04/image-20220725222900128.png" alt="image-20220725222900128" style="zoom: 33%;"></p>
<h2 id="产生式的可选集"><a href="#产生式的可选集" class="headerlink" title="产生式的可选集"></a>产生式的可选集</h2><p><img src="/2022/07/25/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04/image-20220725224732986.png" alt="image-20220725224732986" style="zoom: 33%;"></p>
<h2 id="串首终结符集"><a href="#串首终结符集" class="headerlink" title="串首终结符集"></a>串首终结符集</h2><p><img src="/2022/07/25/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04/image-20220725224941060.png" alt="image-20220725224941060"></p>
<blockquote>
<p>写成=&gt;*指可以通过n步推导出来，n可以为0</p>
</blockquote>
<h2 id="LL-1-文法-1"><a href="#LL-1-文法-1" class="headerlink" title="LL(1)文法"></a>LL(1)文法</h2><p><img src="/2022/07/25/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04/image-20220726104545972.png" alt="image-20220726104545972"></p>
<blockquote>
<p>由于LL(1)文法中同一非终结符的各个候选式的SELECT集互不相交，因此可以构造预测分析器</p>
<ul>
<li>第一个L表示的是从左向右扫描输入</li>
<li>第二个L表示的是产生最左推导</li>
<li>“1”表示在每一步中只需要向前看一个输入符号来决定一个输入符号来决定语法分析动作</li>
</ul>
</blockquote>
<h1 id="FIRST集和FOLLOW集的计算"><a href="#FIRST集和FOLLOW集的计算" class="headerlink" title="FIRST集和FOLLOW集的计算"></a>FIRST集和FOLLOW集的计算</h1><h2 id="计算（一个）符号X的FIRST-X"><a href="#计算（一个）符号X的FIRST-X" class="headerlink" title="计算（一个）符号X的FIRST(X)"></a>计算（一个）符号X的FIRST(X)</h2><blockquote>
<p>FIRST(X)：可以从X推导出的所有串首终结符构成的集合</p>
<p>如果X=&gt;*ε，那么ε∈FIRST(X)</p>
</blockquote>
<p>先看一个例子，注意概念抽象，例子需要着重理解</p>
<p><img src="/2022/07/25/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04/image-20220726105546013.png" alt="image-20220726105546013"></p>
<p>需要着重理解非终结符的FIRST集的含义。其实就是说这个非终结符能够推导出什么终结符，它们的集合就是FIRST集。如果推导出的是非终结符，那么就和推导出的第一个非终结符的FIRST集相同。</p>
<h2 id="计算串X-1-X-2-X-n-的FIRST集"><a href="#计算串X-1-X-2-X-n-的FIRST集" class="headerlink" title="计算串X_{1}X_{2}...X_{n}的FIRST集"></a>计算串<script type="math/tex">X_{1}X_{2}...X_{n}</script>的FIRST集</h2><p><img src="/2022/07/25/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04/image-20220726110207539.png" alt="image-20220726110207539"></p>
<p>就是加入最左的一个非终结符的FIRST集合，但是如果这个非终结符可以推导出ε的话，那么就考虑它右边的非终结符。</p>
<h2 id="计算非终结符A的FOLLOW-A"><a href="#计算非终结符A的FOLLOW-A" class="headerlink" title="计算非终结符A的FOLLOW(A)"></a>计算非终结符A的FOLLOW(A)</h2><blockquote>
<p>FOLLOW(A)：可能在耨个句型中紧跟在A后面的终结符的集合</p>
<p>如果A是某个句型的最右符号，那么将结束符“$”加入到FOLLOW(A)中</p>
</blockquote>
<p>文法的开始符号本身就是一个句型，所以需要把$加入到开始符号的FOLLOW集中。同时终结符是不考虑空串ε的，所以第一个产生式的T后面跟了E‘，因此T的FOLLOW中应该有E’的FIRST集中的终结符（不包括ε）</p>
<p>这一讲比较难理解，建议看看视频理解</p>
<p><img src="/2022/07/25/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04/image-20220726113653932.png" alt="image-20220726113653932"></p>
<p><strong>算法如下</strong></p>
<p><img src="/2022/07/25/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04/image-20220726113636491.png" alt="image-20220726113636491"></p>
<p>这个算法最好在理解的基础上记忆，最好的办法就是能够做一个例题。</p>
<h2 id="例：表达式文法各产生式的SELECT集"><a href="#例：表达式文法各产生式的SELECT集" class="headerlink" title="例：表达式文法各产生式的SELECT集"></a>例：表达式文法各产生式的SELECT集</h2><p><img src="/2022/07/25/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04/image-20220726143426088.png" alt="image-20220726143426088"></p>
<p>第（2）个表达式和第（3）个表达式有相同的左部E‘，但是它们的SELECT集不相交，第（5）个表达式和第（6）个表达式也是如此。因此上面的文法是LL(1)文法。构造预测分析表如下</p>
<p><img src="/2022/07/25/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04/image-20220726143805504.png" alt="image-20220726143805504"></p>
<h2 id="LL-1）文法的分析方法"><a href="#LL-1）文法的分析方法" class="headerlink" title="LL(1）文法的分析方法"></a>LL(1）文法的分析方法</h2><ul>
<li>递归的预测分析法</li>
<li>非递归的预测分析法</li>
</ul>
<h1 id="递归的预测分析法"><a href="#递归的预测分析法" class="headerlink" title="递归的预测分析法"></a>递归的预测分析法</h1><blockquote>
<p>递归的预测分析法是指：在递归下降分析中，编写每一个非终结符对应的过程的时候，根据预测分析表进行产生式的选择</p>
</blockquote>
<p><img src="/2022/07/25/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04/image-20220726144719741.png" alt="image-20220726144719741"></p>
]]></content>
      <categories>
        <category>courses-learning</category>
        <category>编译原理笔记</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
      </tags>
  </entry>
</search>
